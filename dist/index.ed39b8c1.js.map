{"mappings":"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","sources":["<anon>","node_modules/chart.js/dist/chart.umd.js","node_modules/chart.js/src/helpers/helpers.core.ts","node_modules/chart.js/src/helpers/helpers.math.ts","node_modules/chart.js/src/helpers/helpers.collection.ts","node_modules/chart.js/src/helpers/helpers.extras.ts","node_modules/chart.js/src/core/core.animator.js","node_modules/chart.js/node_modules/.pnpm/@kurkle+color@0.3.2/node_modules/@kurkle/color/dist/color.esm.js","node_modules/chart.js/src/helpers/helpers.color.ts","node_modules/chart.js/src/core/core.animations.defaults.js","node_modules/chart.js/src/helpers/helpers.intl.ts","node_modules/chart.js/src/core/core.ticks.js","node_modules/chart.js/src/core/core.defaults.js","node_modules/chart.js/src/core/core.layouts.defaults.js","node_modules/chart.js/src/core/core.scale.defaults.js","node_modules/chart.js/src/helpers/helpers.dom.ts","node_modules/chart.js/src/helpers/helpers.canvas.ts","node_modules/chart.js/src/helpers/helpers.config.ts","node_modules/chart.js/src/helpers/helpers.curve.ts","node_modules/chart.js/src/helpers/helpers.easing.ts","node_modules/chart.js/src/helpers/helpers.interpolation.ts","node_modules/chart.js/src/helpers/helpers.options.ts","node_modules/chart.js/src/helpers/helpers.rtl.ts","node_modules/chart.js/src/helpers/helpers.segment.js","node_modules/chart.js/src/core/core.interaction.js","node_modules/chart.js/src/core/core.layouts.js","node_modules/chart.js/src/platform/platform.base.js","node_modules/chart.js/src/platform/platform.basic.js","node_modules/chart.js/src/platform/platform.dom.js","node_modules/chart.js/src/platform/index.js","node_modules/chart.js/src/core/core.animation.js","node_modules/chart.js/src/core/core.animations.js","node_modules/chart.js/src/core/core.datasetController.js","node_modules/chart.js/src/core/core.element.ts","node_modules/chart.js/src/core/core.scale.autoskip.js","node_modules/chart.js/src/core/core.scale.js","node_modules/chart.js/src/core/core.typedRegistry.js","node_modules/chart.js/src/core/core.registry.js","node_modules/chart.js/src/core/core.plugins.js","node_modules/chart.js/src/core/core.config.js","node_modules/chart.js/src/core/core.controller.js","node_modules/chart.js/src/core/core.adapters.ts","node_modules/chart.js/src/controllers/controller.bar.js","node_modules/chart.js/src/controllers/controller.doughnut.js","node_modules/chart.js/src/controllers/controller.polarArea.js","node_modules/chart.js/src/controllers/controller.bubble.js","node_modules/chart.js/src/controllers/controller.line.js","node_modules/chart.js/src/controllers/controller.pie.js","node_modules/chart.js/src/controllers/controller.radar.js","node_modules/chart.js/src/controllers/controller.scatter.js","node_modules/chart.js/src/elements/element.arc.ts","node_modules/chart.js/src/elements/element.line.js","node_modules/chart.js/src/elements/element.point.ts","node_modules/chart.js/src/elements/element.bar.js","node_modules/chart.js/src/scales/scale.category.js","node_modules/chart.js/src/scales/scale.linearbase.js","node_modules/chart.js/src/scales/scale.linear.js","node_modules/chart.js/src/scales/scale.logarithmic.js","node_modules/chart.js/src/scales/scale.radialLinear.js","node_modules/chart.js/src/scales/scale.time.js","node_modules/chart.js/src/scales/scale.timeseries.js","node_modules/chart.js/src/plugins/plugin.colors.ts","node_modules/chart.js/src/plugins/plugin.decimation.js","node_modules/chart.js/src/plugins/plugin.filler/filler.segment.js","node_modules/chart.js/src/plugins/plugin.filler/filler.helper.js","node_modules/chart.js/src/plugins/plugin.filler/filler.options.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.stack.js","node_modules/chart.js/src/plugins/plugin.filler/simpleArc.js","node_modules/chart.js/src/plugins/plugin.filler/filler.target.js","node_modules/chart.js/src/plugins/plugin.filler/filler.drawing.js","node_modules/chart.js/src/plugins/plugin.filler/index.js","node_modules/chart.js/src/plugins/plugin.legend.js","node_modules/chart.js/src/plugins/plugin.title.js","node_modules/chart.js/src/plugins/plugin.subtitle.js","node_modules/chart.js/src/plugins/plugin.tooltip.js","node_modules/chart.js/src/index.umd.ts"],"sourcesContent":["/*!\n * Chart.js v4.4.1\n * https://www.chartjs.org\n * (c) 2023 Chart.js Contributors\n * Released under the MIT License\n */ !function(t, e) {\n    \"object\" == typeof exports && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).Chart = e();\n}(this, function() {\n    \"use strict\";\n    var t = Object.freeze({\n        __proto__: null,\n        get Colors () {\n            return Go;\n        },\n        get Decimation () {\n            return Qo;\n        },\n        get Filler () {\n            return ma;\n        },\n        get Legend () {\n            return ya;\n        },\n        get SubTitle () {\n            return ka;\n        },\n        get Title () {\n            return Ma;\n        },\n        get Tooltip () {\n            return Ba;\n        }\n    });\n    function e() {}\n    const i = (()=>{\n        let t = 0;\n        return ()=>t++;\n    })();\n    function s(t) {\n        return null == t;\n    }\n    function n(t) {\n        if (Array.isArray && Array.isArray(t)) return !0;\n        const e = Object.prototype.toString.call(t);\n        return \"[object\" === e.slice(0, 7) && \"Array]\" === e.slice(-6);\n    }\n    function o(t) {\n        return null !== t && \"[object Object]\" === Object.prototype.toString.call(t);\n    }\n    function a(t) {\n        return (\"number\" == typeof t || t instanceof Number) && isFinite(+t);\n    }\n    function r(t, e) {\n        return a(t) ? t : e;\n    }\n    function l(t, e) {\n        return void 0 === t ? e : t;\n    }\n    const h = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 : +t / e, c = (t, e)=>\"string\" == typeof t && t.endsWith(\"%\") ? parseFloat(t) / 100 * e : +t;\n    function d(t, e, i) {\n        if (t && \"function\" == typeof t.call) return t.apply(i, e);\n    }\n    function u(t, e, i, s) {\n        let a, r, l;\n        if (n(t)) {\n            if (r = t.length, s) for(a = r - 1; a >= 0; a--)e.call(i, t[a], a);\n            else for(a = 0; a < r; a++)e.call(i, t[a], a);\n        } else if (o(t)) for(l = Object.keys(t), r = l.length, a = 0; a < r; a++)e.call(i, t[l[a]], l[a]);\n    }\n    function f(t, e) {\n        let i, s, n, o;\n        if (!t || !e || t.length !== e.length) return !1;\n        for(i = 0, s = t.length; i < s; ++i)if (n = t[i], o = e[i], n.datasetIndex !== o.datasetIndex || n.index !== o.index) return !1;\n        return !0;\n    }\n    function g(t) {\n        if (n(t)) return t.map(g);\n        if (o(t)) {\n            const e = Object.create(null), i = Object.keys(t), s = i.length;\n            let n = 0;\n            for(; n < s; ++n)e[i[n]] = g(t[i[n]]);\n            return e;\n        }\n        return t;\n    }\n    function p(t) {\n        return -1 === [\n            \"__proto__\",\n            \"prototype\",\n            \"constructor\"\n        ].indexOf(t);\n    }\n    function m(t, e, i, s) {\n        if (!p(t)) return;\n        const n = e[t], a = i[t];\n        o(n) && o(a) ? b(n, a, s) : e[t] = g(a);\n    }\n    function b(t, e, i) {\n        const s = n(e) ? e : [\n            e\n        ], a = s.length;\n        if (!o(t)) return t;\n        const r = (i = i || {}).merger || m;\n        let l;\n        for(let e = 0; e < a; ++e){\n            if (l = s[e], !o(l)) continue;\n            const n = Object.keys(l);\n            for(let e = 0, s = n.length; e < s; ++e)r(n[e], t, l, i);\n        }\n        return t;\n    }\n    function x(t, e) {\n        return b(t, e, {\n            merger: _\n        });\n    }\n    function _(t, e, i) {\n        if (!p(t)) return;\n        const s = e[t], n = i[t];\n        o(s) && o(n) ? x(s, n) : Object.prototype.hasOwnProperty.call(e, t) || (e[t] = g(n));\n    }\n    const y = {\n        \"\": (t)=>t,\n        x: (t)=>t.x,\n        y: (t)=>t.y\n    };\n    function v(t) {\n        const e = t.split(\".\"), i = [];\n        let s = \"\";\n        for (const t of e)s += t, s.endsWith(\"\\\\\") ? s = s.slice(0, -1) + \".\" : (i.push(s), s = \"\");\n        return i;\n    }\n    function M(t, e) {\n        const i = y[e] || (y[e] = function(t) {\n            const e = v(t);\n            return (t)=>{\n                for (const i of e){\n                    if (\"\" === i) break;\n                    t = t && t[i];\n                }\n                return t;\n            };\n        }(e));\n        return i(t);\n    }\n    function w(t) {\n        return t.charAt(0).toUpperCase() + t.slice(1);\n    }\n    const k = (t)=>void 0 !== t, S = (t)=>\"function\" == typeof t, P = (t, e)=>{\n        if (t.size !== e.size) return !1;\n        for (const i of t)if (!e.has(i)) return !1;\n        return !0;\n    };\n    function D(t) {\n        return \"mouseup\" === t.type || \"click\" === t.type || \"contextmenu\" === t.type;\n    }\n    const C = Math.PI, O = 2 * C, A = O + C, T = Number.POSITIVE_INFINITY, L = C / 180, E = C / 2, R = C / 4, I = 2 * C / 3, z = Math.log10, F = Math.sign;\n    function V(t, e, i) {\n        return Math.abs(t - e) < i;\n    }\n    function B(t) {\n        const e = Math.round(t);\n        t = V(t, e, t / 1e3) ? e : t;\n        const i = Math.pow(10, Math.floor(z(t))), s = t / i;\n        return (s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10) * i;\n    }\n    function W(t) {\n        const e = [], i = Math.sqrt(t);\n        let s;\n        for(s = 1; s < i; s++)t % s == 0 && (e.push(s), e.push(t / s));\n        return i === (0 | i) && e.push(i), e.sort((t, e)=>t - e).pop(), e;\n    }\n    function N(t) {\n        return !isNaN(parseFloat(t)) && isFinite(t);\n    }\n    function H(t, e) {\n        const i = Math.round(t);\n        return i - e <= t && i + e >= t;\n    }\n    function j(t, e, i) {\n        let s, n, o;\n        for(s = 0, n = t.length; s < n; s++)o = t[s][i], isNaN(o) || (e.min = Math.min(e.min, o), e.max = Math.max(e.max, o));\n    }\n    function $(t) {\n        return t * (C / 180);\n    }\n    function Y(t) {\n        return t * (180 / C);\n    }\n    function U(t) {\n        if (!a(t)) return;\n        let e = 1, i = 0;\n        for(; Math.round(t * e) / e !== t;)e *= 10, i++;\n        return i;\n    }\n    function X(t, e) {\n        const i = e.x - t.x, s = e.y - t.y, n = Math.sqrt(i * i + s * s);\n        let o = Math.atan2(s, i);\n        return o < -0.5 * C && (o += O), {\n            angle: o,\n            distance: n\n        };\n    }\n    function q(t, e) {\n        return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }\n    function K(t, e) {\n        return (t - e + A) % O - C;\n    }\n    function G(t) {\n        return (t % O + O) % O;\n    }\n    function Z(t, e, i, s) {\n        const n = G(t), o = G(e), a = G(i), r = G(o - n), l = G(a - n), h = G(n - o), c = G(n - a);\n        return n === o || n === a || s && o === a || r > l && h < c;\n    }\n    function J(t, e, i) {\n        return Math.max(e, Math.min(i, t));\n    }\n    function Q(t) {\n        return J(t, -32768, 32767);\n    }\n    function tt(t, e, i, s = 1e-6) {\n        return t >= Math.min(e, i) - s && t <= Math.max(e, i) + s;\n    }\n    function et(t, e, i) {\n        i = i || ((i)=>t[i] < e);\n        let s, n = t.length - 1, o = 0;\n        for(; n - o > 1;)s = o + n >> 1, i(s) ? o = s : n = s;\n        return {\n            lo: o,\n            hi: n\n        };\n    }\n    const it = (t, e, i, s)=>et(t, i, s ? (s)=>{\n            const n = t[s][e];\n            return n < i || n === i && t[s + 1][e] === i;\n        } : (s)=>t[s][e] < i), st = (t, e, i)=>et(t, i, (s)=>t[s][e] >= i);\n    function nt(t, e, i) {\n        let s = 0, n = t.length;\n        for(; s < n && t[s] < e;)s++;\n        for(; n > s && t[n - 1] > i;)n--;\n        return s > 0 || n < t.length ? t.slice(s, n) : t;\n    }\n    const ot = [\n        \"push\",\n        \"pop\",\n        \"shift\",\n        \"splice\",\n        \"unshift\"\n    ];\n    function at(t, e) {\n        t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, \"_chartjs\", {\n            configurable: !0,\n            enumerable: !1,\n            value: {\n                listeners: [\n                    e\n                ]\n            }\n        }), ot.forEach((e)=>{\n            const i = \"_onData\" + w(e), s = t[e];\n            Object.defineProperty(t, e, {\n                configurable: !0,\n                enumerable: !1,\n                value (...e) {\n                    const n = s.apply(this, e);\n                    return t._chartjs.listeners.forEach((t)=>{\n                        \"function\" == typeof t[i] && t[i](...e);\n                    }), n;\n                }\n            });\n        }));\n    }\n    function rt(t, e) {\n        const i = t._chartjs;\n        if (!i) return;\n        const s = i.listeners, n = s.indexOf(e);\n        -1 !== n && s.splice(n, 1), s.length > 0 || (ot.forEach((e)=>{\n            delete t[e];\n        }), delete t._chartjs);\n    }\n    function lt(t) {\n        const e = new Set(t);\n        return e.size === t.length ? t : Array.from(e);\n    }\n    const ht = \"undefined\" == typeof window ? function(t) {\n        return t();\n    } : window.requestAnimationFrame;\n    function ct(t, e) {\n        let i = [], s = !1;\n        return function(...n) {\n            i = n, s || (s = !0, ht.call(window, ()=>{\n                s = !1, t.apply(e, i);\n            }));\n        };\n    }\n    function dt(t, e) {\n        let i;\n        return function(...s) {\n            return e ? (clearTimeout(i), i = setTimeout(t, e, s)) : t.apply(this, s), e;\n        };\n    }\n    const ut = (t)=>\"start\" === t ? \"left\" : \"end\" === t ? \"right\" : \"center\", ft = (t, e, i)=>\"start\" === t ? e : \"end\" === t ? i : (e + i) / 2, gt = (t, e, i, s)=>t === (s ? \"left\" : \"right\") ? i : \"center\" === t ? (e + i) / 2 : e;\n    function pt(t, e, i) {\n        const s = e.length;\n        let n = 0, o = s;\n        if (t._sorted) {\n            const { iScale: a, _parsed: r } = t, l = a.axis, { min: h, max: c, minDefined: d, maxDefined: u } = a.getUserBounds();\n            d && (n = J(Math.min(it(r, l, h).lo, i ? s : it(e, l, a.getPixelForValue(h)).lo), 0, s - 1)), o = u ? J(Math.max(it(r, a.axis, c, !0).hi + 1, i ? 0 : it(e, l, a.getPixelForValue(c), !0).hi + 1), n, s) - n : s - n;\n        }\n        return {\n            start: n,\n            count: o\n        };\n    }\n    function mt(t) {\n        const { xScale: e, yScale: i, _scaleRanges: s } = t, n = {\n            xmin: e.min,\n            xmax: e.max,\n            ymin: i.min,\n            ymax: i.max\n        };\n        if (!s) return t._scaleRanges = n, !0;\n        const o = s.xmin !== e.min || s.xmax !== e.max || s.ymin !== i.min || s.ymax !== i.max;\n        return Object.assign(s, n), o;\n    }\n    class bt {\n        constructor(){\n            this._request = null, this._charts = new Map, this._running = !1, this._lastDate = void 0;\n        }\n        _notify(t, e, i, s) {\n            const n = e.listeners[s], o = e.duration;\n            n.forEach((s)=>s({\n                    chart: t,\n                    initial: e.initial,\n                    numSteps: o,\n                    currentStep: Math.min(i - e.start, o)\n                }));\n        }\n        _refresh() {\n            this._request || (this._running = !0, this._request = ht.call(window, ()=>{\n                this._update(), this._request = null, this._running && this._refresh();\n            }));\n        }\n        _update(t = Date.now()) {\n            let e = 0;\n            this._charts.forEach((i, s)=>{\n                if (!i.running || !i.items.length) return;\n                const n = i.items;\n                let o, a = n.length - 1, r = !1;\n                for(; a >= 0; --a)o = n[a], o._active ? (o._total > i.duration && (i.duration = o._total), o.tick(t), r = !0) : (n[a] = n[n.length - 1], n.pop());\n                r && (s.draw(), this._notify(s, i, t, \"progress\")), n.length || (i.running = !1, this._notify(s, i, t, \"complete\"), i.initial = !1), e += n.length;\n            }), this._lastDate = t, 0 === e && (this._running = !1);\n        }\n        _getAnims(t) {\n            const e = this._charts;\n            let i = e.get(t);\n            return i || (i = {\n                running: !1,\n                initial: !0,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            }, e.set(t, i)), i;\n        }\n        listen(t, e, i) {\n            this._getAnims(t).listeners[e].push(i);\n        }\n        add(t, e) {\n            e && e.length && this._getAnims(t).items.push(...e);\n        }\n        has(t) {\n            return this._getAnims(t).items.length > 0;\n        }\n        start(t) {\n            const e = this._charts.get(t);\n            e && (e.running = !0, e.start = Date.now(), e.duration = e.items.reduce((t, e)=>Math.max(t, e._duration), 0), this._refresh());\n        }\n        running(t) {\n            if (!this._running) return !1;\n            const e = this._charts.get(t);\n            return !!(e && e.running && e.items.length);\n        }\n        stop(t) {\n            const e = this._charts.get(t);\n            if (!e || !e.items.length) return;\n            const i = e.items;\n            let s = i.length - 1;\n            for(; s >= 0; --s)i[s].cancel();\n            e.items = [], this._notify(t, e, Date.now(), \"complete\");\n        }\n        remove(t) {\n            return this._charts.delete(t);\n        }\n    }\n    var xt = new bt;\n    /*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */ function _t(t) {\n        return t + .5 | 0;\n    }\n    const yt = (t, e, i)=>Math.max(Math.min(t, i), e);\n    function vt(t) {\n        return yt(_t(2.55 * t), 0, 255);\n    }\n    function Mt(t) {\n        return yt(_t(255 * t), 0, 255);\n    }\n    function wt(t) {\n        return yt(_t(t / 2.55) / 100, 0, 1);\n    }\n    function kt(t) {\n        return yt(_t(100 * t), 0, 100);\n    }\n    const St = {\n        0: 0,\n        1: 1,\n        2: 2,\n        3: 3,\n        4: 4,\n        5: 5,\n        6: 6,\n        7: 7,\n        8: 8,\n        9: 9,\n        A: 10,\n        B: 11,\n        C: 12,\n        D: 13,\n        E: 14,\n        F: 15,\n        a: 10,\n        b: 11,\n        c: 12,\n        d: 13,\n        e: 14,\n        f: 15\n    }, Pt = [\n        ...\"0123456789ABCDEF\"\n    ], Dt = (t)=>Pt[15 & t], Ct = (t)=>Pt[(240 & t) >> 4] + Pt[15 & t], Ot = (t)=>(240 & t) >> 4 == (15 & t);\n    function At(t) {\n        var e = ((t)=>Ot(t.r) && Ot(t.g) && Ot(t.b) && Ot(t.a))(t) ? Dt : Ct;\n        return t ? \"#\" + e(t.r) + e(t.g) + e(t.b) + ((t, e)=>t < 255 ? e(t) : \"\")(t.a, e) : void 0;\n    }\n    const Tt = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    function Lt(t, e, i) {\n        const s = e * Math.min(i, 1 - i), n = (e, n = (e + t / 30) % 12)=>i - s * Math.max(Math.min(n - 3, 9 - n, 1), -1);\n        return [\n            n(0),\n            n(8),\n            n(4)\n        ];\n    }\n    function Et(t, e, i) {\n        const s = (s, n = (s + t / 60) % 6)=>i - i * e * Math.max(Math.min(n, 4 - n, 1), 0);\n        return [\n            s(5),\n            s(3),\n            s(1)\n        ];\n    }\n    function Rt(t, e, i) {\n        const s = Lt(t, 1, .5);\n        let n;\n        for(e + i > 1 && (n = 1 / (e + i), e *= n, i *= n), n = 0; n < 3; n++)s[n] *= 1 - e - i, s[n] += e;\n        return s;\n    }\n    function It(t) {\n        const e = t.r / 255, i = t.g / 255, s = t.b / 255, n = Math.max(e, i, s), o = Math.min(e, i, s), a = (n + o) / 2;\n        let r, l, h;\n        return n !== o && (h = n - o, l = a > .5 ? h / (2 - n - o) : h / (n + o), r = function(t, e, i, s, n) {\n            return t === n ? (e - i) / s + (e < i ? 6 : 0) : e === n ? (i - t) / s + 2 : (t - e) / s + 4;\n        }(e, i, s, h, n), r = 60 * r + .5), [\n            0 | r,\n            l || 0,\n            a\n        ];\n    }\n    function zt(t, e, i, s) {\n        return (Array.isArray(e) ? t(e[0], e[1], e[2]) : t(e, i, s)).map(Mt);\n    }\n    function Ft(t, e, i) {\n        return zt(Lt, t, e, i);\n    }\n    function Vt(t) {\n        return (t % 360 + 360) % 360;\n    }\n    function Bt(t) {\n        const e = Tt.exec(t);\n        let i, s = 255;\n        if (!e) return;\n        e[5] !== i && (s = e[6] ? vt(+e[5]) : Mt(+e[5]));\n        const n = Vt(+e[2]), o = +e[3] / 100, a = +e[4] / 100;\n        return i = \"hwb\" === e[1] ? function(t, e, i) {\n            return zt(Rt, t, e, i);\n        }(n, o, a) : \"hsv\" === e[1] ? function(t, e, i) {\n            return zt(Et, t, e, i);\n        }(n, o, a) : Ft(n, o, a), {\n            r: i[0],\n            g: i[1],\n            b: i[2],\n            a: s\n        };\n    }\n    const Wt = {\n        x: \"dark\",\n        Z: \"light\",\n        Y: \"re\",\n        X: \"blu\",\n        W: \"gr\",\n        V: \"medium\",\n        U: \"slate\",\n        A: \"ee\",\n        T: \"ol\",\n        S: \"or\",\n        B: \"ra\",\n        C: \"lateg\",\n        D: \"ights\",\n        R: \"in\",\n        Q: \"turquois\",\n        E: \"hi\",\n        P: \"ro\",\n        O: \"al\",\n        N: \"le\",\n        M: \"de\",\n        L: \"yello\",\n        F: \"en\",\n        K: \"ch\",\n        G: \"arks\",\n        H: \"ea\",\n        I: \"ightg\",\n        J: \"wh\"\n    }, Nt = {\n        OiceXe: \"f0f8ff\",\n        antiquewEte: \"faebd7\",\n        aqua: \"ffff\",\n        aquamarRe: \"7fffd4\",\n        azuY: \"f0ffff\",\n        beige: \"f5f5dc\",\n        bisque: \"ffe4c4\",\n        black: \"0\",\n        blanKedOmond: \"ffebcd\",\n        Xe: \"ff\",\n        XeviTet: \"8a2be2\",\n        bPwn: \"a52a2a\",\n        burlywood: \"deb887\",\n        caMtXe: \"5f9ea0\",\n        KartYuse: \"7fff00\",\n        KocTate: \"d2691e\",\n        cSO: \"ff7f50\",\n        cSnflowerXe: \"6495ed\",\n        cSnsilk: \"fff8dc\",\n        crimson: \"dc143c\",\n        cyan: \"ffff\",\n        xXe: \"8b\",\n        xcyan: \"8b8b\",\n        xgTMnPd: \"b8860b\",\n        xWay: \"a9a9a9\",\n        xgYF: \"6400\",\n        xgYy: \"a9a9a9\",\n        xkhaki: \"bdb76b\",\n        xmagFta: \"8b008b\",\n        xTivegYF: \"556b2f\",\n        xSange: \"ff8c00\",\n        xScEd: \"9932cc\",\n        xYd: \"8b0000\",\n        xsOmon: \"e9967a\",\n        xsHgYF: \"8fbc8f\",\n        xUXe: \"483d8b\",\n        xUWay: \"2f4f4f\",\n        xUgYy: \"2f4f4f\",\n        xQe: \"ced1\",\n        xviTet: \"9400d3\",\n        dAppRk: \"ff1493\",\n        dApskyXe: \"bfff\",\n        dimWay: \"696969\",\n        dimgYy: \"696969\",\n        dodgerXe: \"1e90ff\",\n        fiYbrick: \"b22222\",\n        flSOwEte: \"fffaf0\",\n        foYstWAn: \"228b22\",\n        fuKsia: \"ff00ff\",\n        gaRsbSo: \"dcdcdc\",\n        ghostwEte: \"f8f8ff\",\n        gTd: \"ffd700\",\n        gTMnPd: \"daa520\",\n        Way: \"808080\",\n        gYF: \"8000\",\n        gYFLw: \"adff2f\",\n        gYy: \"808080\",\n        honeyMw: \"f0fff0\",\n        hotpRk: \"ff69b4\",\n        RdianYd: \"cd5c5c\",\n        Rdigo: \"4b0082\",\n        ivSy: \"fffff0\",\n        khaki: \"f0e68c\",\n        lavFMr: \"e6e6fa\",\n        lavFMrXsh: \"fff0f5\",\n        lawngYF: \"7cfc00\",\n        NmoncEffon: \"fffacd\",\n        ZXe: \"add8e6\",\n        ZcSO: \"f08080\",\n        Zcyan: \"e0ffff\",\n        ZgTMnPdLw: \"fafad2\",\n        ZWay: \"d3d3d3\",\n        ZgYF: \"90ee90\",\n        ZgYy: \"d3d3d3\",\n        ZpRk: \"ffb6c1\",\n        ZsOmon: \"ffa07a\",\n        ZsHgYF: \"20b2aa\",\n        ZskyXe: \"87cefa\",\n        ZUWay: \"778899\",\n        ZUgYy: \"778899\",\n        ZstAlXe: \"b0c4de\",\n        ZLw: \"ffffe0\",\n        lime: \"ff00\",\n        limegYF: \"32cd32\",\n        lRF: \"faf0e6\",\n        magFta: \"ff00ff\",\n        maPon: \"800000\",\n        VaquamarRe: \"66cdaa\",\n        VXe: \"cd\",\n        VScEd: \"ba55d3\",\n        VpurpN: \"9370db\",\n        VsHgYF: \"3cb371\",\n        VUXe: \"7b68ee\",\n        VsprRggYF: \"fa9a\",\n        VQe: \"48d1cc\",\n        VviTetYd: \"c71585\",\n        midnightXe: \"191970\",\n        mRtcYam: \"f5fffa\",\n        mistyPse: \"ffe4e1\",\n        moccasR: \"ffe4b5\",\n        navajowEte: \"ffdead\",\n        navy: \"80\",\n        Tdlace: \"fdf5e6\",\n        Tive: \"808000\",\n        TivedBb: \"6b8e23\",\n        Sange: \"ffa500\",\n        SangeYd: \"ff4500\",\n        ScEd: \"da70d6\",\n        pOegTMnPd: \"eee8aa\",\n        pOegYF: \"98fb98\",\n        pOeQe: \"afeeee\",\n        pOeviTetYd: \"db7093\",\n        papayawEp: \"ffefd5\",\n        pHKpuff: \"ffdab9\",\n        peru: \"cd853f\",\n        pRk: \"ffc0cb\",\n        plum: \"dda0dd\",\n        powMrXe: \"b0e0e6\",\n        purpN: \"800080\",\n        YbeccapurpN: \"663399\",\n        Yd: \"ff0000\",\n        Psybrown: \"bc8f8f\",\n        PyOXe: \"4169e1\",\n        saddNbPwn: \"8b4513\",\n        sOmon: \"fa8072\",\n        sandybPwn: \"f4a460\",\n        sHgYF: \"2e8b57\",\n        sHshell: \"fff5ee\",\n        siFna: \"a0522d\",\n        silver: \"c0c0c0\",\n        skyXe: \"87ceeb\",\n        UXe: \"6a5acd\",\n        UWay: \"708090\",\n        UgYy: \"708090\",\n        snow: \"fffafa\",\n        sprRggYF: \"ff7f\",\n        stAlXe: \"4682b4\",\n        tan: \"d2b48c\",\n        teO: \"8080\",\n        tEstN: \"d8bfd8\",\n        tomato: \"ff6347\",\n        Qe: \"40e0d0\",\n        viTet: \"ee82ee\",\n        JHt: \"f5deb3\",\n        wEte: \"ffffff\",\n        wEtesmoke: \"f5f5f5\",\n        Lw: \"ffff00\",\n        LwgYF: \"9acd32\"\n    };\n    let Ht;\n    function jt(t) {\n        Ht || (Ht = function() {\n            const t = {}, e = Object.keys(Nt), i = Object.keys(Wt);\n            let s, n, o, a, r;\n            for(s = 0; s < e.length; s++){\n                for(a = r = e[s], n = 0; n < i.length; n++)o = i[n], r = r.replace(o, Wt[o]);\n                o = parseInt(Nt[a], 16), t[r] = [\n                    o >> 16 & 255,\n                    o >> 8 & 255,\n                    255 & o\n                ];\n            }\n            return t;\n        }(), Ht.transparent = [\n            0,\n            0,\n            0,\n            0\n        ]);\n        const e = Ht[t.toLowerCase()];\n        return e && {\n            r: e[0],\n            g: e[1],\n            b: e[2],\n            a: 4 === e.length ? e[3] : 255\n        };\n    }\n    const $t = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\n    const Yt = (t)=>t <= .0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - .055, Ut = (t)=>t <= .04045 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4);\n    function Xt(t, e, i) {\n        if (t) {\n            let s = It(t);\n            s[e] = Math.max(0, Math.min(s[e] + s[e] * i, 0 === e ? 360 : 1)), s = Ft(s), t.r = s[0], t.g = s[1], t.b = s[2];\n        }\n    }\n    function qt(t, e) {\n        return t ? Object.assign(e || {}, t) : t;\n    }\n    function Kt(t) {\n        var e = {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 255\n        };\n        return Array.isArray(t) ? t.length >= 3 && (e = {\n            r: t[0],\n            g: t[1],\n            b: t[2],\n            a: 255\n        }, t.length > 3 && (e.a = Mt(t[3]))) : (e = qt(t, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        })).a = Mt(e.a), e;\n    }\n    function Gt(t) {\n        return \"r\" === t.charAt(0) ? function(t) {\n            const e = $t.exec(t);\n            let i, s, n, o = 255;\n            if (e) {\n                if (e[7] !== i) {\n                    const t = +e[7];\n                    o = e[8] ? vt(t) : yt(255 * t, 0, 255);\n                }\n                return i = +e[1], s = +e[3], n = +e[5], i = 255 & (e[2] ? vt(i) : yt(i, 0, 255)), s = 255 & (e[4] ? vt(s) : yt(s, 0, 255)), n = 255 & (e[6] ? vt(n) : yt(n, 0, 255)), {\n                    r: i,\n                    g: s,\n                    b: n,\n                    a: o\n                };\n            }\n        }(t) : Bt(t);\n    }\n    class Zt {\n        constructor(t){\n            if (t instanceof Zt) return t;\n            const e = typeof t;\n            let i;\n            var s, n, o;\n            \"object\" === e ? i = Kt(t) : \"string\" === e && (o = (s = t).length, \"#\" === s[0] && (4 === o || 5 === o ? n = {\n                r: 255 & 17 * St[s[1]],\n                g: 255 & 17 * St[s[2]],\n                b: 255 & 17 * St[s[3]],\n                a: 5 === o ? 17 * St[s[4]] : 255\n            } : 7 !== o && 9 !== o || (n = {\n                r: St[s[1]] << 4 | St[s[2]],\n                g: St[s[3]] << 4 | St[s[4]],\n                b: St[s[5]] << 4 | St[s[6]],\n                a: 9 === o ? St[s[7]] << 4 | St[s[8]] : 255\n            })), i = n || jt(t) || Gt(t)), this._rgb = i, this._valid = !!i;\n        }\n        get valid() {\n            return this._valid;\n        }\n        get rgb() {\n            var t = qt(this._rgb);\n            return t && (t.a = wt(t.a)), t;\n        }\n        set rgb(t) {\n            this._rgb = Kt(t);\n        }\n        rgbString() {\n            var t;\n            return this._valid ? (t = this._rgb) && (t.a < 255 ? `rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})` : `rgb(${t.r}, ${t.g}, ${t.b})`) : void 0;\n        }\n        hexString() {\n            return this._valid ? At(this._rgb) : void 0;\n        }\n        hslString() {\n            return this._valid ? function(t) {\n                if (!t) return;\n                const e = It(t), i = e[0], s = kt(e[1]), n = kt(e[2]);\n                return t.a < 255 ? `hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})` : `hsl(${i}, ${s}%, ${n}%)`;\n            }(this._rgb) : void 0;\n        }\n        mix(t, e) {\n            if (t) {\n                const i = this.rgb, s = t.rgb;\n                let n;\n                const o = e === n ? .5 : e, a = 2 * o - 1, r = i.a - s.a, l = ((a * r == -1 ? a : (a + r) / (1 + a * r)) + 1) / 2;\n                n = 1 - l, i.r = 255 & l * i.r + n * s.r + .5, i.g = 255 & l * i.g + n * s.g + .5, i.b = 255 & l * i.b + n * s.b + .5, i.a = o * i.a + (1 - o) * s.a, this.rgb = i;\n            }\n            return this;\n        }\n        interpolate(t, e) {\n            return t && (this._rgb = function(t, e, i) {\n                const s = Ut(wt(t.r)), n = Ut(wt(t.g)), o = Ut(wt(t.b));\n                return {\n                    r: Mt(Yt(s + i * (Ut(wt(e.r)) - s))),\n                    g: Mt(Yt(n + i * (Ut(wt(e.g)) - n))),\n                    b: Mt(Yt(o + i * (Ut(wt(e.b)) - o))),\n                    a: t.a + i * (e.a - t.a)\n                };\n            }(this._rgb, t._rgb, e)), this;\n        }\n        clone() {\n            return new Zt(this.rgb);\n        }\n        alpha(t) {\n            return this._rgb.a = Mt(t), this;\n        }\n        clearer(t) {\n            return this._rgb.a *= 1 - t, this;\n        }\n        greyscale() {\n            const t = this._rgb, e = _t(.3 * t.r + .59 * t.g + .11 * t.b);\n            return t.r = t.g = t.b = e, this;\n        }\n        opaquer(t) {\n            return this._rgb.a *= 1 + t, this;\n        }\n        negate() {\n            const t = this._rgb;\n            return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;\n        }\n        lighten(t) {\n            return Xt(this._rgb, 2, t), this;\n        }\n        darken(t) {\n            return Xt(this._rgb, 2, -t), this;\n        }\n        saturate(t) {\n            return Xt(this._rgb, 1, t), this;\n        }\n        desaturate(t) {\n            return Xt(this._rgb, 1, -t), this;\n        }\n        rotate(t) {\n            return function(t, e) {\n                var i = It(t);\n                i[0] = Vt(i[0] + e), i = Ft(i), t.r = i[0], t.g = i[1], t.b = i[2];\n            }(this._rgb, t), this;\n        }\n    }\n    function Jt(t) {\n        if (t && \"object\" == typeof t) {\n            const e = t.toString();\n            return \"[object CanvasPattern]\" === e || \"[object CanvasGradient]\" === e;\n        }\n        return !1;\n    }\n    function Qt(t) {\n        return Jt(t) ? t : new Zt(t);\n    }\n    function te(t) {\n        return Jt(t) ? t : new Zt(t).saturate(.5).darken(.1).hexString();\n    }\n    const ee = [\n        \"x\",\n        \"y\",\n        \"borderWidth\",\n        \"radius\",\n        \"tension\"\n    ], ie = [\n        \"color\",\n        \"borderColor\",\n        \"backgroundColor\"\n    ];\n    const se = new Map;\n    function ne(t, e, i) {\n        return (function(t, e) {\n            e = e || {};\n            const i = t + JSON.stringify(e);\n            let s = se.get(i);\n            return s || (s = new Intl.NumberFormat(t, e), se.set(i, s)), s;\n        })(e, i).format(t);\n    }\n    const oe = {\n        values: (t)=>n(t) ? t : \"\" + t,\n        numeric (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = this.chart.options.locale;\n            let n, o = t;\n            if (i.length > 1) {\n                const e = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));\n                (e < 1e-4 || e > 1e15) && (n = \"scientific\"), o = function(t, e) {\n                    let i = e.length > 3 ? e[2].value - e[1].value : e[1].value - e[0].value;\n                    Math.abs(i) >= 1 && t !== Math.floor(t) && (i = t - Math.floor(t));\n                    return i;\n                }(t, i);\n            }\n            const a = z(Math.abs(o)), r = isNaN(a) ? 1 : Math.max(Math.min(-1 * Math.floor(a), 20), 0), l = {\n                notation: n,\n                minimumFractionDigits: r,\n                maximumFractionDigits: r\n            };\n            return Object.assign(l, this.options.ticks.format), ne(t, s, l);\n        },\n        logarithmic (t, e, i) {\n            if (0 === t) return \"0\";\n            const s = i[e].significand || t / Math.pow(10, Math.floor(z(t)));\n            return [\n                1,\n                2,\n                3,\n                5,\n                10,\n                15\n            ].includes(s) || e > .8 * i.length ? oe.numeric.call(this, t, e, i) : \"\";\n        }\n    };\n    var ae = {\n        formatters: oe\n    };\n    const re = Object.create(null), le = Object.create(null);\n    function he(t, e) {\n        if (!e) return t;\n        const i = e.split(\".\");\n        for(let e = 0, s = i.length; e < s; ++e){\n            const s = i[e];\n            t = t[s] || (t[s] = Object.create(null));\n        }\n        return t;\n    }\n    function ce(t, e, i) {\n        return \"string\" == typeof e ? b(he(t, e), i) : b(he(t, \"\"), e);\n    }\n    class de {\n        constructor(t, e){\n            this.animation = void 0, this.backgroundColor = \"rgba(0,0,0,0.1)\", this.borderColor = \"rgba(0,0,0,0.1)\", this.color = \"#666\", this.datasets = {}, this.devicePixelRatio = (t)=>t.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [\n                \"mousemove\",\n                \"mouseout\",\n                \"click\",\n                \"touchstart\",\n                \"touchmove\"\n            ], this.font = {\n                family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n                size: 12,\n                style: \"normal\",\n                lineHeight: 1.2,\n                weight: null\n            }, this.hover = {}, this.hoverBackgroundColor = (t, e)=>te(e.backgroundColor), this.hoverBorderColor = (t, e)=>te(e.borderColor), this.hoverColor = (t, e)=>te(e.color), this.indexAxis = \"x\", this.interaction = {\n                mode: \"nearest\",\n                intersect: !0,\n                includeInvisible: !1\n            }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(e);\n        }\n        set(t, e) {\n            return ce(this, t, e);\n        }\n        get(t) {\n            return he(this, t);\n        }\n        describe(t, e) {\n            return ce(le, t, e);\n        }\n        override(t, e) {\n            return ce(re, t, e);\n        }\n        route(t, e, i, s) {\n            const n = he(this, t), a = he(this, i), r = \"_\" + e;\n            Object.defineProperties(n, {\n                [r]: {\n                    value: n[e],\n                    writable: !0\n                },\n                [e]: {\n                    enumerable: !0,\n                    get () {\n                        const t = this[r], e = a[s];\n                        return o(t) ? Object.assign({}, e, t) : l(t, e);\n                    },\n                    set (t) {\n                        this[r] = t;\n                    }\n                }\n            });\n        }\n        apply(t) {\n            t.forEach((t)=>t(this));\n        }\n    }\n    var ue = new de({\n        _scriptable: (t)=>!t.startsWith(\"on\"),\n        _indexable: (t)=>\"events\" !== t,\n        hover: {\n            _fallback: \"interaction\"\n        },\n        interaction: {\n            _scriptable: !1,\n            _indexable: !1\n        }\n    }, [\n        function(t) {\n            t.set(\"animation\", {\n                delay: void 0,\n                duration: 1e3,\n                easing: \"easeOutQuart\",\n                fn: void 0,\n                from: void 0,\n                loop: void 0,\n                to: void 0,\n                type: void 0\n            }), t.describe(\"animation\", {\n                _fallback: !1,\n                _indexable: !1,\n                _scriptable: (t)=>\"onProgress\" !== t && \"onComplete\" !== t && \"fn\" !== t\n            }), t.set(\"animations\", {\n                colors: {\n                    type: \"color\",\n                    properties: ie\n                },\n                numbers: {\n                    type: \"number\",\n                    properties: ee\n                }\n            }), t.describe(\"animations\", {\n                _fallback: \"animation\"\n            }), t.set(\"transitions\", {\n                active: {\n                    animation: {\n                        duration: 400\n                    }\n                },\n                resize: {\n                    animation: {\n                        duration: 0\n                    }\n                },\n                show: {\n                    animations: {\n                        colors: {\n                            from: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            duration: 0\n                        }\n                    }\n                },\n                hide: {\n                    animations: {\n                        colors: {\n                            to: \"transparent\"\n                        },\n                        visible: {\n                            type: \"boolean\",\n                            easing: \"linear\",\n                            fn: (t)=>0 | t\n                        }\n                    }\n                }\n            });\n        },\n        function(t) {\n            t.set(\"layout\", {\n                autoPadding: !0,\n                padding: {\n                    top: 0,\n                    right: 0,\n                    bottom: 0,\n                    left: 0\n                }\n            });\n        },\n        function(t) {\n            t.set(\"scale\", {\n                display: !0,\n                offset: !1,\n                reverse: !1,\n                beginAtZero: !1,\n                bounds: \"ticks\",\n                clip: !0,\n                grace: 0,\n                grid: {\n                    display: !0,\n                    lineWidth: 1,\n                    drawOnChartArea: !0,\n                    drawTicks: !0,\n                    tickLength: 8,\n                    tickWidth: (t, e)=>e.lineWidth,\n                    tickColor: (t, e)=>e.color,\n                    offset: !1\n                },\n                border: {\n                    display: !0,\n                    dash: [],\n                    dashOffset: 0,\n                    width: 1\n                },\n                title: {\n                    display: !1,\n                    text: \"\",\n                    padding: {\n                        top: 4,\n                        bottom: 4\n                    }\n                },\n                ticks: {\n                    minRotation: 0,\n                    maxRotation: 50,\n                    mirror: !1,\n                    textStrokeWidth: 0,\n                    textStrokeColor: \"\",\n                    padding: 3,\n                    display: !0,\n                    autoSkip: !0,\n                    autoSkipPadding: 3,\n                    labelOffset: 0,\n                    callback: ae.formatters.values,\n                    minor: {},\n                    major: {},\n                    align: \"center\",\n                    crossAlign: \"near\",\n                    showLabelBackdrop: !1,\n                    backdropColor: \"rgba(255, 255, 255, 0.75)\",\n                    backdropPadding: 2\n                }\n            }), t.route(\"scale.ticks\", \"color\", \"\", \"color\"), t.route(\"scale.grid\", \"color\", \"\", \"borderColor\"), t.route(\"scale.border\", \"color\", \"\", \"borderColor\"), t.route(\"scale.title\", \"color\", \"\", \"color\"), t.describe(\"scale\", {\n                _fallback: !1,\n                _scriptable: (t)=>!t.startsWith(\"before\") && !t.startsWith(\"after\") && \"callback\" !== t && \"parser\" !== t,\n                _indexable: (t)=>\"borderDash\" !== t && \"tickBorderDash\" !== t && \"dash\" !== t\n            }), t.describe(\"scales\", {\n                _fallback: \"scale\"\n            }), t.describe(\"scale.ticks\", {\n                _scriptable: (t)=>\"backdropPadding\" !== t && \"callback\" !== t,\n                _indexable: (t)=>\"backdropPadding\" !== t\n            });\n        }\n    ]);\n    function fe() {\n        return \"undefined\" != typeof window && \"undefined\" != typeof document;\n    }\n    function ge(t) {\n        let e = t.parentNode;\n        return e && \"[object ShadowRoot]\" === e.toString() && (e = e.host), e;\n    }\n    function pe(t, e, i) {\n        let s;\n        return \"string\" == typeof t ? (s = parseInt(t, 10), -1 !== t.indexOf(\"%\") && (s = s / 100 * e.parentNode[i])) : s = t, s;\n    }\n    const me = (t)=>t.ownerDocument.defaultView.getComputedStyle(t, null);\n    function be(t, e) {\n        return me(t).getPropertyValue(e);\n    }\n    const xe = [\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\"\n    ];\n    function _e(t, e, i) {\n        const s = {};\n        i = i ? \"-\" + i : \"\";\n        for(let n = 0; n < 4; n++){\n            const o = xe[n];\n            s[o] = parseFloat(t[e + \"-\" + o + i]) || 0;\n        }\n        return s.width = s.left + s.right, s.height = s.top + s.bottom, s;\n    }\n    const ye = (t, e, i)=>(t > 0 || e > 0) && (!i || !i.shadowRoot);\n    function ve(t, e) {\n        if (\"native\" in t) return t;\n        const { canvas: i, currentDevicePixelRatio: s } = e, n = me(i), o = \"border-box\" === n.boxSizing, a = _e(n, \"padding\"), r = _e(n, \"border\", \"width\"), { x: l, y: h, box: c } = function(t, e) {\n            const i = t.touches, s = i && i.length ? i[0] : t, { offsetX: n, offsetY: o } = s;\n            let a, r, l = !1;\n            if (ye(n, o, t.target)) a = n, r = o;\n            else {\n                const t = e.getBoundingClientRect();\n                a = s.clientX - t.left, r = s.clientY - t.top, l = !0;\n            }\n            return {\n                x: a,\n                y: r,\n                box: l\n            };\n        }(t, i), d = a.left + (c && r.left), u = a.top + (c && r.top);\n        let { width: f, height: g } = e;\n        return o && (f -= a.width + r.width, g -= a.height + r.height), {\n            x: Math.round((l - d) / f * i.width / s),\n            y: Math.round((h - u) / g * i.height / s)\n        };\n    }\n    const Me = (t)=>Math.round(10 * t) / 10;\n    function we(t, e, i, s) {\n        const n = me(t), o = _e(n, \"margin\"), a = pe(n.maxWidth, t, \"clientWidth\") || T, r = pe(n.maxHeight, t, \"clientHeight\") || T, l = function(t, e, i) {\n            let s, n;\n            if (void 0 === e || void 0 === i) {\n                const o = ge(t);\n                if (o) {\n                    const t = o.getBoundingClientRect(), a = me(o), r = _e(a, \"border\", \"width\"), l = _e(a, \"padding\");\n                    e = t.width - l.width - r.width, i = t.height - l.height - r.height, s = pe(a.maxWidth, o, \"clientWidth\"), n = pe(a.maxHeight, o, \"clientHeight\");\n                } else e = t.clientWidth, i = t.clientHeight;\n            }\n            return {\n                width: e,\n                height: i,\n                maxWidth: s || T,\n                maxHeight: n || T\n            };\n        }(t, e, i);\n        let { width: h, height: c } = l;\n        if (\"content-box\" === n.boxSizing) {\n            const t = _e(n, \"border\", \"width\"), e = _e(n, \"padding\");\n            h -= e.width + t.width, c -= e.height + t.height;\n        }\n        h = Math.max(0, h - o.width), c = Math.max(0, s ? h / s : c - o.height), h = Me(Math.min(h, a, l.maxWidth)), c = Me(Math.min(c, r, l.maxHeight)), h && !c && (c = Me(h / 2));\n        return (void 0 !== e || void 0 !== i) && s && l.height && c > l.height && (c = l.height, h = Me(Math.floor(c * s))), {\n            width: h,\n            height: c\n        };\n    }\n    function ke(t, e, i) {\n        const s = e || 1, n = Math.floor(t.height * s), o = Math.floor(t.width * s);\n        t.height = Math.floor(t.height), t.width = Math.floor(t.width);\n        const a = t.canvas;\n        return a.style && (i || !a.style.height && !a.style.width) && (a.style.height = `${t.height}px`, a.style.width = `${t.width}px`), (t.currentDevicePixelRatio !== s || a.height !== n || a.width !== o) && (t.currentDevicePixelRatio = s, a.height = n, a.width = o, t.ctx.setTransform(s, 0, 0, s, 0, 0), !0);\n    }\n    const Se = function() {\n        let t = !1;\n        try {\n            const e = {\n                get passive () {\n                    return t = !0, !1;\n                }\n            };\n            fe() && (window.addEventListener(\"test\", null, e), window.removeEventListener(\"test\", null, e));\n        } catch (t) {}\n        return t;\n    }();\n    function Pe(t, e) {\n        const i = be(t, e), s = i && i.match(/^(\\d+)(\\.\\d+)?px$/);\n        return s ? +s[1] : void 0;\n    }\n    function De(t) {\n        return !t || s(t.size) || s(t.family) ? null : (t.style ? t.style + \" \" : \"\") + (t.weight ? t.weight + \" \" : \"\") + t.size + \"px \" + t.family;\n    }\n    function Ce(t, e, i, s, n) {\n        let o = e[n];\n        return o || (o = e[n] = t.measureText(n).width, i.push(n)), o > s && (s = o), s;\n    }\n    function Oe(t, e, i, s) {\n        let o = (s = s || {}).data = s.data || {}, a = s.garbageCollect = s.garbageCollect || [];\n        s.font !== e && (o = s.data = {}, a = s.garbageCollect = [], s.font = e), t.save(), t.font = e;\n        let r = 0;\n        const l = i.length;\n        let h, c, d, u, f;\n        for(h = 0; h < l; h++)if (u = i[h], null == u || n(u)) {\n            if (n(u)) for(c = 0, d = u.length; c < d; c++)f = u[c], null == f || n(f) || (r = Ce(t, o, a, r, f));\n        } else r = Ce(t, o, a, r, u);\n        t.restore();\n        const g = a.length / 2;\n        if (g > i.length) {\n            for(h = 0; h < g; h++)delete o[a[h]];\n            a.splice(0, g);\n        }\n        return r;\n    }\n    function Ae(t, e, i) {\n        const s = t.currentDevicePixelRatio, n = 0 !== i ? Math.max(i / 2, .5) : 0;\n        return Math.round((e - n) * s) / s + n;\n    }\n    function Te(t, e) {\n        (e = e || t.getContext(\"2d\")).save(), e.resetTransform(), e.clearRect(0, 0, t.width, t.height), e.restore();\n    }\n    function Le(t, e, i, s) {\n        Ee(t, e, i, s, null);\n    }\n    function Ee(t, e, i, s, n) {\n        let o, a, r, l, h, c, d, u;\n        const f = e.pointStyle, g = e.rotation, p = e.radius;\n        let m = (g || 0) * L;\n        if (f && \"object\" == typeof f && (o = f.toString(), \"[object HTMLImageElement]\" === o || \"[object HTMLCanvasElement]\" === o)) return t.save(), t.translate(i, s), t.rotate(m), t.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), void t.restore();\n        if (!(isNaN(p) || p <= 0)) {\n            switch(t.beginPath(), f){\n                default:\n                    n ? t.ellipse(i, s, n / 2, p, 0, 0, O) : t.arc(i, s, p, 0, O), t.closePath();\n                    break;\n                case \"triangle\":\n                    c = n ? n / 2 : p, t.moveTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), m += I, t.lineTo(i + Math.sin(m) * c, s - Math.cos(m) * p), t.closePath();\n                    break;\n                case \"rectRounded\":\n                    h = .516 * p, l = p - h, a = Math.cos(m + R) * l, d = Math.cos(m + R) * (n ? n / 2 - h : l), r = Math.sin(m + R) * l, u = Math.sin(m + R) * (n ? n / 2 - h : l), t.arc(i - d, s - r, h, m - C, m - E), t.arc(i + u, s - a, h, m - E, m), t.arc(i + d, s + r, h, m, m + E), t.arc(i - u, s + a, h, m + E, m + C), t.closePath();\n                    break;\n                case \"rect\":\n                    if (!g) {\n                        l = Math.SQRT1_2 * p, c = n ? n / 2 : l, t.rect(i - c, s - l, 2 * c, 2 * l);\n                        break;\n                    }\n                    m += R;\n                case \"rectRot\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + u, s - a), t.lineTo(i + d, s + r), t.lineTo(i - u, s + a), t.closePath();\n                    break;\n                case \"crossRot\":\n                    m += R;\n                case \"cross\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"star\":\n                    d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a), m += R, d = Math.cos(m) * (n ? n / 2 : p), a = Math.cos(m) * p, r = Math.sin(m) * p, u = Math.sin(m) * (n ? n / 2 : p), t.moveTo(i - d, s - r), t.lineTo(i + d, s + r), t.moveTo(i + u, s - a), t.lineTo(i - u, s + a);\n                    break;\n                case \"line\":\n                    a = n ? n / 2 : Math.cos(m) * p, r = Math.sin(m) * p, t.moveTo(i - a, s - r), t.lineTo(i + a, s + r);\n                    break;\n                case \"dash\":\n                    t.moveTo(i, s), t.lineTo(i + Math.cos(m) * (n ? n / 2 : p), s + Math.sin(m) * p);\n                    break;\n                case !1:\n                    t.closePath();\n            }\n            t.fill(), e.borderWidth > 0 && t.stroke();\n        }\n    }\n    function Re(t, e, i) {\n        return i = i || .5, !e || t && t.x > e.left - i && t.x < e.right + i && t.y > e.top - i && t.y < e.bottom + i;\n    }\n    function Ie(t, e) {\n        t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip();\n    }\n    function ze(t) {\n        t.restore();\n    }\n    function Fe(t, e, i, s, n) {\n        if (!e) return t.lineTo(i.x, i.y);\n        if (\"middle\" === n) {\n            const s = (e.x + i.x) / 2;\n            t.lineTo(s, e.y), t.lineTo(s, i.y);\n        } else \"after\" === n != !!s ? t.lineTo(e.x, i.y) : t.lineTo(i.x, e.y);\n        t.lineTo(i.x, i.y);\n    }\n    function Ve(t, e, i, s) {\n        if (!e) return t.lineTo(i.x, i.y);\n        t.bezierCurveTo(s ? e.cp1x : e.cp2x, s ? e.cp1y : e.cp2y, s ? i.cp2x : i.cp1x, s ? i.cp2y : i.cp1y, i.x, i.y);\n    }\n    function Be(t, e, i, s, n) {\n        if (n.strikethrough || n.underline) {\n            const o = t.measureText(s), a = e - o.actualBoundingBoxLeft, r = e + o.actualBoundingBoxRight, l = i - o.actualBoundingBoxAscent, h = i + o.actualBoundingBoxDescent, c = n.strikethrough ? (l + h) / 2 : h;\n            t.strokeStyle = t.fillStyle, t.beginPath(), t.lineWidth = n.decorationWidth || 2, t.moveTo(a, c), t.lineTo(r, c), t.stroke();\n        }\n    }\n    function We(t, e) {\n        const i = t.fillStyle;\n        t.fillStyle = e.color, t.fillRect(e.left, e.top, e.width, e.height), t.fillStyle = i;\n    }\n    function Ne(t, e, i, o, a, r = {}) {\n        const l = n(e) ? e : [\n            e\n        ], h = r.strokeWidth > 0 && \"\" !== r.strokeColor;\n        let c, d;\n        for(t.save(), t.font = a.string, function(t, e) {\n            e.translation && t.translate(e.translation[0], e.translation[1]), s(e.rotation) || t.rotate(e.rotation), e.color && (t.fillStyle = e.color), e.textAlign && (t.textAlign = e.textAlign), e.textBaseline && (t.textBaseline = e.textBaseline);\n        }(t, r), c = 0; c < l.length; ++c)d = l[c], r.backdrop && We(t, r.backdrop), h && (r.strokeColor && (t.strokeStyle = r.strokeColor), s(r.strokeWidth) || (t.lineWidth = r.strokeWidth), t.strokeText(d, i, o, r.maxWidth)), t.fillText(d, i, o, r.maxWidth), Be(t, i, o, d, r), o += Number(a.lineHeight);\n        t.restore();\n    }\n    function He(t, e) {\n        const { x: i, y: s, w: n, h: o, radius: a } = e;\n        t.arc(i + a.topLeft, s + a.topLeft, a.topLeft, 1.5 * C, C, !0), t.lineTo(i, s + o - a.bottomLeft), t.arc(i + a.bottomLeft, s + o - a.bottomLeft, a.bottomLeft, C, E, !0), t.lineTo(i + n - a.bottomRight, s + o), t.arc(i + n - a.bottomRight, s + o - a.bottomRight, a.bottomRight, E, 0, !0), t.lineTo(i + n, s + a.topRight), t.arc(i + n - a.topRight, s + a.topRight, a.topRight, 0, -E, !0), t.lineTo(i + a.topLeft, s);\n    }\n    function je(t, e = [\n        \"\"\n    ], i, s, n = ()=>t[0]) {\n        const o = i || t;\n        void 0 === s && (s = ti(\"_fallback\", t));\n        const a = {\n            [Symbol.toStringTag]: \"Object\",\n            _cacheable: !0,\n            _scopes: t,\n            _rootScopes: o,\n            _fallback: s,\n            _getTarget: n,\n            override: (i)=>je([\n                    i,\n                    ...t\n                ], e, o, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete e._keys, delete t[0][i], !0),\n            get: (i, s)=>qe(i, s, ()=>(function(t, e, i, s) {\n                        let n;\n                        for (const o of e)if (n = ti(Ue(o, t), i), void 0 !== n) return Xe(t, n) ? Je(i, s, t, n) : n;\n                    })(s, e, t, i)),\n            getOwnPropertyDescriptor: (t, e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0], e),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t[0]),\n            has: (t, e)=>ei(t).includes(e),\n            ownKeys: (t)=>ei(t),\n            set (t, e, i) {\n                const s = t._storage || (t._storage = n());\n                return t[e] = s[e] = i, delete t._keys, !0;\n            }\n        });\n    }\n    function $e(t, e, i, s) {\n        const a = {\n            _cacheable: !1,\n            _proxy: t,\n            _context: e,\n            _subProxy: i,\n            _stack: new Set,\n            _descriptors: Ye(t, s),\n            setContext: (e)=>$e(t, e, i, s),\n            override: (n)=>$e(t.override(n), e, i, s)\n        };\n        return new Proxy(a, {\n            deleteProperty: (e, i)=>(delete e[i], delete t[i], !0),\n            get: (t, e, i)=>qe(t, e, ()=>(function(t, e, i) {\n                        const { _proxy: s, _context: a, _subProxy: r, _descriptors: l } = t;\n                        let h = s[e];\n                        S(h) && l.isScriptable(e) && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: o, _subProxy: a, _stack: r } = i;\n                            if (r.has(t)) throw new Error(\"Recursion detected: \" + Array.from(r).join(\"->\") + \"->\" + t);\n                            r.add(t);\n                            let l = e(o, a || s);\n                            r.delete(t), Xe(t, l) && (l = Je(n._scopes, n, t, l));\n                            return l;\n                        }(e, h, t, i));\n                        n(h) && h.length && (h = function(t, e, i, s) {\n                            const { _proxy: n, _context: a, _subProxy: r, _descriptors: l } = i;\n                            if (void 0 !== a.index && s(t)) return e[a.index % e.length];\n                            if (o(e[0])) {\n                                const i = e, s = n._scopes.filter((t)=>t !== i);\n                                e = [];\n                                for (const o of i){\n                                    const i = Je(s, n, t, o);\n                                    e.push($e(i, a, r && r[t], l));\n                                }\n                            }\n                            return e;\n                        }(e, h, t, l.isIndexable));\n                        Xe(e, h) && (h = $e(h, a, r && r[e], l));\n                        return h;\n                    })(t, e, i)),\n            getOwnPropertyDescriptor: (e, i)=>e._descriptors.allKeys ? Reflect.has(t, i) ? {\n                    enumerable: !0,\n                    configurable: !0\n                } : void 0 : Reflect.getOwnPropertyDescriptor(t, i),\n            getPrototypeOf: ()=>Reflect.getPrototypeOf(t),\n            has: (e, i)=>Reflect.has(t, i),\n            ownKeys: ()=>Reflect.ownKeys(t),\n            set: (e, i, s)=>(t[i] = s, delete e[i], !0)\n        });\n    }\n    function Ye(t, e = {\n        scriptable: !0,\n        indexable: !0\n    }) {\n        const { _scriptable: i = e.scriptable, _indexable: s = e.indexable, _allKeys: n = e.allKeys } = t;\n        return {\n            allKeys: n,\n            scriptable: i,\n            indexable: s,\n            isScriptable: S(i) ? i : ()=>i,\n            isIndexable: S(s) ? s : ()=>s\n        };\n    }\n    const Ue = (t, e)=>t ? t + w(e) : e, Xe = (t, e)=>o(e) && \"adapters\" !== t && (null === Object.getPrototypeOf(e) || e.constructor === Object);\n    function qe(t, e, i) {\n        if (Object.prototype.hasOwnProperty.call(t, e)) return t[e];\n        const s = i();\n        return t[e] = s, s;\n    }\n    function Ke(t, e, i) {\n        return S(t) ? t(e, i) : t;\n    }\n    const Ge = (t, e)=>!0 === t ? e : \"string\" == typeof t ? M(e, t) : void 0;\n    function Ze(t, e, i, s, n) {\n        for (const o of e){\n            const e = Ge(i, o);\n            if (e) {\n                t.add(e);\n                const o = Ke(e._fallback, i, n);\n                if (void 0 !== o && o !== i && o !== s) return o;\n            } else if (!1 === e && void 0 !== s && i !== s) return null;\n        }\n        return !1;\n    }\n    function Je(t, e, i, s) {\n        const a = e._rootScopes, r = Ke(e._fallback, i, s), l = [\n            ...t,\n            ...a\n        ], h = new Set;\n        h.add(s);\n        let c = Qe(h, l, i, r || i, s);\n        return null !== c && (void 0 === r || r === i || (c = Qe(h, l, r, c, s), null !== c)) && je(Array.from(h), [\n            \"\"\n        ], a, r, ()=>(function(t, e, i) {\n                const s = t._getTarget();\n                e in s || (s[e] = {});\n                const a = s[e];\n                if (n(a) && o(i)) return i;\n                return a || {};\n            })(e, i, s));\n    }\n    function Qe(t, e, i, s, n) {\n        for(; i;)i = Ze(t, e, i, s, n);\n        return i;\n    }\n    function ti(t, e) {\n        for (const i of e){\n            if (!i) continue;\n            const e = i[t];\n            if (void 0 !== e) return e;\n        }\n    }\n    function ei(t) {\n        let e = t._keys;\n        return e || (e = t._keys = function(t) {\n            const e = new Set;\n            for (const i of t)for (const t of Object.keys(i).filter((t)=>!t.startsWith(\"_\")))e.add(t);\n            return Array.from(e);\n        }(t._scopes)), e;\n    }\n    function ii(t, e, i, s) {\n        const { iScale: n } = t, { key: o = \"r\" } = this._parsing, a = new Array(s);\n        let r, l, h, c;\n        for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n            r: n.parse(M(c, o), h)\n        };\n        return a;\n    }\n    const si = Number.EPSILON || 1e-14, ni = (t, e)=>e < t.length && !t[e].skip && t[e], oi = (t)=>\"x\" === t ? \"y\" : \"x\";\n    function ai(t, e, i, s) {\n        const n = t.skip ? e : t, o = e, a = i.skip ? e : i, r = q(o, n), l = q(a, o);\n        let h = r / (r + l), c = l / (r + l);\n        h = isNaN(h) ? 0 : h, c = isNaN(c) ? 0 : c;\n        const d = s * h, u = s * c;\n        return {\n            previous: {\n                x: o.x - d * (a.x - n.x),\n                y: o.y - d * (a.y - n.y)\n            },\n            next: {\n                x: o.x + u * (a.x - n.x),\n                y: o.y + u * (a.y - n.y)\n            }\n        };\n    }\n    function ri(t, e = \"x\") {\n        const i = oi(e), s = t.length, n = Array(s).fill(0), o = Array(s);\n        let a, r, l, h = ni(t, 0);\n        for(a = 0; a < s; ++a)if (r = l, l = h, h = ni(t, a + 1), l) {\n            if (h) {\n                const t = h[e] - l[e];\n                n[a] = 0 !== t ? (h[i] - l[i]) / t : 0;\n            }\n            o[a] = r ? h ? F(n[a - 1]) !== F(n[a]) ? 0 : (n[a - 1] + n[a]) / 2 : n[a - 1] : n[a];\n        }\n        !function(t, e, i) {\n            const s = t.length;\n            let n, o, a, r, l, h = ni(t, 0);\n            for(let c = 0; c < s - 1; ++c)l = h, h = ni(t, c + 1), l && h && (V(e[c], 0, si) ? i[c] = i[c + 1] = 0 : (n = i[c] / e[c], o = i[c + 1] / e[c], r = Math.pow(n, 2) + Math.pow(o, 2), r <= 9 || (a = 3 / Math.sqrt(r), i[c] = n * a * e[c], i[c + 1] = o * a * e[c])));\n        }(t, n, o), function(t, e, i = \"x\") {\n            const s = oi(i), n = t.length;\n            let o, a, r, l = ni(t, 0);\n            for(let h = 0; h < n; ++h){\n                if (a = r, r = l, l = ni(t, h + 1), !r) continue;\n                const n = r[i], c = r[s];\n                a && (o = (n - a[i]) / 3, r[`cp1${i}`] = n - o, r[`cp1${s}`] = c - o * e[h]), l && (o = (l[i] - n) / 3, r[`cp2${i}`] = n + o, r[`cp2${s}`] = c + o * e[h]);\n            }\n        }(t, o, e);\n    }\n    function li(t, e, i) {\n        return Math.max(Math.min(t, i), e);\n    }\n    function hi(t, e, i, s, n) {\n        let o, a, r, l;\n        if (e.spanGaps && (t = t.filter((t)=>!t.skip)), \"monotone\" === e.cubicInterpolationMode) ri(t, n);\n        else {\n            let i = s ? t[t.length - 1] : t[0];\n            for(o = 0, a = t.length; o < a; ++o)r = t[o], l = ai(i, r, t[Math.min(o + 1, a - (s ? 0 : 1)) % a], e.tension), r.cp1x = l.previous.x, r.cp1y = l.previous.y, r.cp2x = l.next.x, r.cp2y = l.next.y, i = r;\n        }\n        e.capBezierPoints && function(t, e) {\n            let i, s, n, o, a, r = Re(t[0], e);\n            for(i = 0, s = t.length; i < s; ++i)a = o, o = r, r = i < s - 1 && Re(t[i + 1], e), o && (n = t[i], a && (n.cp1x = li(n.cp1x, e.left, e.right), n.cp1y = li(n.cp1y, e.top, e.bottom)), r && (n.cp2x = li(n.cp2x, e.left, e.right), n.cp2y = li(n.cp2y, e.top, e.bottom)));\n        }(t, i);\n    }\n    const ci = (t)=>0 === t || 1 === t, di = (t, e, i)=>-Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * O / i), ui = (t, e, i)=>Math.pow(2, -10 * t) * Math.sin((t - e) * O / i) + 1, fi = {\n        linear: (t)=>t,\n        easeInQuad: (t)=>t * t,\n        easeOutQuad: (t)=>-t * (t - 2),\n        easeInOutQuad: (t)=>(t /= .5) < 1 ? .5 * t * t : -0.5 * (--t * (t - 2) - 1),\n        easeInCubic: (t)=>t * t * t,\n        easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n        easeInOutCubic: (t)=>(t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),\n        easeInQuart: (t)=>t * t * t * t,\n        easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n        easeInOutQuart: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n        easeInQuint: (t)=>t * t * t * t * t,\n        easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n        easeInOutQuint: (t)=>(t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),\n        easeInSine: (t)=>1 - Math.cos(t * E),\n        easeOutSine: (t)=>Math.sin(t * E),\n        easeInOutSine: (t)=>-0.5 * (Math.cos(C * t) - 1),\n        easeInExpo: (t)=>0 === t ? 0 : Math.pow(2, 10 * (t - 1)),\n        easeOutExpo: (t)=>1 === t ? 1 : 1 - Math.pow(2, -10 * t),\n        easeInOutExpo: (t)=>ci(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (2 * t - 1)) : .5 * (2 - Math.pow(2, -10 * (2 * t - 1))),\n        easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n        easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n        easeInOutCirc: (t)=>(t /= .5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n        easeInElastic: (t)=>ci(t) ? t : di(t, .075, .3),\n        easeOutElastic: (t)=>ci(t) ? t : ui(t, .075, .3),\n        easeInOutElastic (t) {\n            const e = .1125;\n            return ci(t) ? t : t < .5 ? .5 * di(2 * t, e, .45) : .5 + .5 * ui(2 * t - 1, e, .45);\n        },\n        easeInBack (t) {\n            const e = 1.70158;\n            return t * t * ((e + 1) * t - e);\n        },\n        easeOutBack (t) {\n            const e = 1.70158;\n            return (t -= 1) * t * ((e + 1) * t + e) + 1;\n        },\n        easeInOutBack (t) {\n            let e = 1.70158;\n            return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2);\n        },\n        easeInBounce: (t)=>1 - fi.easeOutBounce(1 - t),\n        easeOutBounce (t) {\n            const e = 7.5625, i = 2.75;\n            return t < 1 / i ? e * t * t : t < 2 / i ? e * (t -= 1.5 / i) * t + .75 : t < 2.5 / i ? e * (t -= 2.25 / i) * t + .9375 : e * (t -= 2.625 / i) * t + .984375;\n        },\n        easeInOutBounce: (t)=>t < .5 ? .5 * fi.easeInBounce(2 * t) : .5 * fi.easeOutBounce(2 * t - 1) + .5\n    };\n    function gi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: t.y + i * (e.y - t.y)\n        };\n    }\n    function pi(t, e, i, s) {\n        return {\n            x: t.x + i * (e.x - t.x),\n            y: \"middle\" === s ? i < .5 ? t.y : e.y : \"after\" === s ? i < 1 ? t.y : e.y : i > 0 ? e.y : t.y\n        };\n    }\n    function mi(t, e, i, s) {\n        const n = {\n            x: t.cp2x,\n            y: t.cp2y\n        }, o = {\n            x: e.cp1x,\n            y: e.cp1y\n        }, a = gi(t, n, i), r = gi(n, o, i), l = gi(o, e, i), h = gi(a, r, i), c = gi(r, l, i);\n        return gi(h, c, i);\n    }\n    const bi = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/, xi = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n    function _i(t, e) {\n        const i = (\"\" + t).match(bi);\n        if (!i || \"normal\" === i[1]) return 1.2 * e;\n        switch(t = +i[2], i[3]){\n            case \"px\":\n                return t;\n            case \"%\":\n                t /= 100;\n        }\n        return e * t;\n    }\n    const yi = (t)=>+t || 0;\n    function vi(t, e) {\n        const i = {}, s = o(e), n = s ? Object.keys(e) : e, a = o(t) ? s ? (i)=>l(t[i], t[e[i]]) : (e)=>t[e] : ()=>t;\n        for (const t of n)i[t] = yi(a(t));\n        return i;\n    }\n    function Mi(t) {\n        return vi(t, {\n            top: \"y\",\n            right: \"x\",\n            bottom: \"y\",\n            left: \"x\"\n        });\n    }\n    function wi(t) {\n        return vi(t, [\n            \"topLeft\",\n            \"topRight\",\n            \"bottomLeft\",\n            \"bottomRight\"\n        ]);\n    }\n    function ki(t) {\n        const e = Mi(t);\n        return e.width = e.left + e.right, e.height = e.top + e.bottom, e;\n    }\n    function Si(t, e) {\n        t = t || {}, e = e || ue.font;\n        let i = l(t.size, e.size);\n        \"string\" == typeof i && (i = parseInt(i, 10));\n        let s = l(t.style, e.style);\n        s && !(\"\" + s).match(xi) && (console.warn('Invalid font style specified: \"' + s + '\"'), s = void 0);\n        const n = {\n            family: l(t.family, e.family),\n            lineHeight: _i(l(t.lineHeight, e.lineHeight), i),\n            size: i,\n            style: s,\n            weight: l(t.weight, e.weight),\n            string: \"\"\n        };\n        return n.string = De(n), n;\n    }\n    function Pi(t, e, i, s) {\n        let o, a, r, l = !0;\n        for(o = 0, a = t.length; o < a; ++o)if (r = t[o], void 0 !== r && (void 0 !== e && \"function\" == typeof r && (r = r(e), l = !1), void 0 !== i && n(r) && (r = r[i % r.length], l = !1), void 0 !== r)) return s && !l && (s.cacheable = !1), r;\n    }\n    function Di(t, e, i) {\n        const { min: s, max: n } = t, o = c(e, (n - s) / 2), a = (t, e)=>i && 0 === t ? 0 : t + e;\n        return {\n            min: a(s, -Math.abs(o)),\n            max: a(n, o)\n        };\n    }\n    function Ci(t, e) {\n        return Object.assign(Object.create(t), e);\n    }\n    function Oi(t, e, i) {\n        return t ? function(t, e) {\n            return {\n                x: (i)=>t + t + e - i,\n                setWidth (t) {\n                    e = t;\n                },\n                textAlign: (t)=>\"center\" === t ? t : \"right\" === t ? \"left\" : \"right\",\n                xPlus: (t, e)=>t - e,\n                leftForLtr: (t, e)=>t - e\n            };\n        }(e, i) : {\n            x: (t)=>t,\n            setWidth (t) {},\n            textAlign: (t)=>t,\n            xPlus: (t, e)=>t + e,\n            leftForLtr: (t, e)=>t\n        };\n    }\n    function Ai(t, e) {\n        let i, s;\n        \"ltr\" !== e && \"rtl\" !== e || (i = t.canvas.style, s = [\n            i.getPropertyValue(\"direction\"),\n            i.getPropertyPriority(\"direction\")\n        ], i.setProperty(\"direction\", e, \"important\"), t.prevTextDirection = s);\n    }\n    function Ti(t, e) {\n        void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty(\"direction\", e[0], e[1]));\n    }\n    function Li(t) {\n        return \"angle\" === t ? {\n            between: Z,\n            compare: K,\n            normalize: G\n        } : {\n            between: tt,\n            compare: (t, e)=>t - e,\n            normalize: (t)=>t\n        };\n    }\n    function Ei({ start: t, end: e, count: i, loop: s, style: n }) {\n        return {\n            start: t % i,\n            end: e % i,\n            loop: s && (e - t + 1) % i == 0,\n            style: n\n        };\n    }\n    function Ri(t, e, i) {\n        if (!i) return [\n            t\n        ];\n        const { property: s, start: n, end: o } = i, a = e.length, { compare: r, between: l, normalize: h } = Li(s), { start: c, end: d, loop: u, style: f } = function(t, e, i) {\n            const { property: s, start: n, end: o } = i, { between: a, normalize: r } = Li(s), l = e.length;\n            let h, c, { start: d, end: u, loop: f } = t;\n            if (f) {\n                for(d += l, u += l, h = 0, c = l; h < c && a(r(e[d % l][s]), n, o); ++h)d--, u--;\n                d %= l, u %= l;\n            }\n            return u < d && (u += l), {\n                start: d,\n                end: u,\n                loop: f,\n                style: t.style\n            };\n        }(t, e, i), g = [];\n        let p, m, b, x = !1, _ = null;\n        const y = ()=>x || l(n, b, p) && 0 !== r(n, b), v = ()=>!x || 0 === r(o, p) || l(o, b, p);\n        for(let t = c, i = c; t <= d; ++t)m = e[t % a], m.skip || (p = h(m[s]), p !== b && (x = l(p, n, o), null === _ && y() && (_ = 0 === r(p, n) ? t : i), null !== _ && v() && (g.push(Ei({\n            start: _,\n            end: t,\n            loop: u,\n            count: a,\n            style: f\n        })), _ = null), i = t, b = p));\n        return null !== _ && g.push(Ei({\n            start: _,\n            end: d,\n            loop: u,\n            count: a,\n            style: f\n        })), g;\n    }\n    function Ii(t, e) {\n        const i = [], s = t.segments;\n        for(let n = 0; n < s.length; n++){\n            const o = Ri(s[n], t.points, e);\n            o.length && i.push(...o);\n        }\n        return i;\n    }\n    function zi(t, e) {\n        const i = t.points, s = t.options.spanGaps, n = i.length;\n        if (!n) return [];\n        const o = !!t._loop, { start: a, end: r } = function(t, e, i, s) {\n            let n = 0, o = e - 1;\n            if (i && !s) for(; n < e && !t[n].skip;)n++;\n            for(; n < e && t[n].skip;)n++;\n            for(n %= e, i && (o += n); o > n && t[o % e].skip;)o--;\n            return o %= e, {\n                start: n,\n                end: o\n            };\n        }(i, n, o, s);\n        if (!0 === s) return Fi(t, [\n            {\n                start: a,\n                end: r,\n                loop: o\n            }\n        ], i, e);\n        return Fi(t, function(t, e, i, s) {\n            const n = t.length, o = [];\n            let a, r = e, l = t[e];\n            for(a = e + 1; a <= i; ++a){\n                const i = t[a % n];\n                i.skip || i.stop ? l.skip || (s = !1, o.push({\n                    start: e % n,\n                    end: (a - 1) % n,\n                    loop: s\n                }), e = r = i.stop ? a : null) : (r = a, l.skip && (e = a)), l = i;\n            }\n            return null !== r && o.push({\n                start: e % n,\n                end: r % n,\n                loop: s\n            }), o;\n        }(i, a, r < a ? r + n : r, !!t._fullLoop && 0 === a && r === n - 1), i, e);\n    }\n    function Fi(t, e, i, s) {\n        return s && s.setContext && i ? function(t, e, i, s) {\n            const n = t._chart.getContext(), o = Vi(t.options), { _datasetIndex: a, options: { spanGaps: r } } = t, l = i.length, h = [];\n            let c = o, d = e[0].start, u = d;\n            function f(t, e, s, n) {\n                const o = r ? -1 : 1;\n                if (t !== e) {\n                    for(t += l; i[t % l].skip;)t -= o;\n                    for(; i[e % l].skip;)e += o;\n                    t % l != e % l && (h.push({\n                        start: t % l,\n                        end: e % l,\n                        loop: s,\n                        style: n\n                    }), c = n, d = e % l);\n                }\n            }\n            for (const t of e){\n                d = r ? d : t.start;\n                let e, o = i[d % l];\n                for(u = d + 1; u <= t.end; u++){\n                    const r = i[u % l];\n                    e = Vi(s.setContext(Ci(n, {\n                        type: \"segment\",\n                        p0: o,\n                        p1: r,\n                        p0DataIndex: (u - 1) % l,\n                        p1DataIndex: u % l,\n                        datasetIndex: a\n                    }))), Bi(e, c) && f(d, u - 1, t.loop, c), o = r, c = e;\n                }\n                d < u - 1 && f(d, u - 1, t.loop, c);\n            }\n            return h;\n        }(t, e, i, s) : e;\n    }\n    function Vi(t) {\n        return {\n            backgroundColor: t.backgroundColor,\n            borderCapStyle: t.borderCapStyle,\n            borderDash: t.borderDash,\n            borderDashOffset: t.borderDashOffset,\n            borderJoinStyle: t.borderJoinStyle,\n            borderWidth: t.borderWidth,\n            borderColor: t.borderColor\n        };\n    }\n    function Bi(t, e) {\n        if (!e) return !1;\n        const i = [], s = function(t, e) {\n            return Jt(e) ? (i.includes(e) || i.push(e), i.indexOf(e)) : e;\n        };\n        return JSON.stringify(t, s) !== JSON.stringify(e, s);\n    }\n    var Wi = Object.freeze({\n        __proto__: null,\n        HALF_PI: E,\n        INFINITY: T,\n        PI: C,\n        PITAU: A,\n        QUARTER_PI: R,\n        RAD_PER_DEG: L,\n        TAU: O,\n        TWO_THIRDS_PI: I,\n        _addGrace: Di,\n        _alignPixel: Ae,\n        _alignStartEnd: ft,\n        _angleBetween: Z,\n        _angleDiff: K,\n        _arrayUnique: lt,\n        _attachContext: $e,\n        _bezierCurveTo: Ve,\n        _bezierInterpolation: mi,\n        _boundSegment: Ri,\n        _boundSegments: Ii,\n        _capitalize: w,\n        _computeSegments: zi,\n        _createResolver: je,\n        _decimalPlaces: U,\n        _deprecated: function(t, e, i, s) {\n            void 0 !== e && console.warn(t + ': \"' + i + '\" is deprecated. Please use \"' + s + '\" instead');\n        },\n        _descriptors: Ye,\n        _elementsEqual: f,\n        _factorize: W,\n        _filterBetween: nt,\n        _getParentNode: ge,\n        _getStartAndCountOfVisiblePoints: pt,\n        _int16Range: Q,\n        _isBetween: tt,\n        _isClickEvent: D,\n        _isDomSupported: fe,\n        _isPointInArea: Re,\n        _limitValue: J,\n        _longestText: Oe,\n        _lookup: et,\n        _lookupByKey: it,\n        _measureText: Ce,\n        _merger: m,\n        _mergerIf: _,\n        _normalizeAngle: G,\n        _parseObjectDataRadialScale: ii,\n        _pointInLine: gi,\n        _readValueToProps: vi,\n        _rlookupByKey: st,\n        _scaleRangesChanged: mt,\n        _setMinAndMaxByKey: j,\n        _splitKey: v,\n        _steppedInterpolation: pi,\n        _steppedLineTo: Fe,\n        _textX: gt,\n        _toLeftRightCenter: ut,\n        _updateBezierControlPoints: hi,\n        addRoundedRectPath: He,\n        almostEquals: V,\n        almostWhole: H,\n        callback: d,\n        clearCanvas: Te,\n        clipArea: Ie,\n        clone: g,\n        color: Qt,\n        createContext: Ci,\n        debounce: dt,\n        defined: k,\n        distanceBetweenPoints: q,\n        drawPoint: Le,\n        drawPointLegend: Ee,\n        each: u,\n        easingEffects: fi,\n        finiteOrDefault: r,\n        fontString: function(t, e, i) {\n            return e + \" \" + t + \"px \" + i;\n        },\n        formatNumber: ne,\n        getAngleFromPoint: X,\n        getHoverColor: te,\n        getMaximumSize: we,\n        getRelativePosition: ve,\n        getRtlAdapter: Oi,\n        getStyle: be,\n        isArray: n,\n        isFinite: a,\n        isFunction: S,\n        isNullOrUndef: s,\n        isNumber: N,\n        isObject: o,\n        isPatternOrGradient: Jt,\n        listenArrayEvents: at,\n        log10: z,\n        merge: b,\n        mergeIf: x,\n        niceNum: B,\n        noop: e,\n        overrideTextDirection: Ai,\n        readUsedSize: Pe,\n        renderText: Ne,\n        requestAnimFrame: ht,\n        resolve: Pi,\n        resolveObjectKey: M,\n        restoreTextDirection: Ti,\n        retinaScale: ke,\n        setsEqual: P,\n        sign: F,\n        splineCurve: ai,\n        splineCurveMonotone: ri,\n        supportsEventListenerOptions: Se,\n        throttled: ct,\n        toDegrees: Y,\n        toDimension: c,\n        toFont: Si,\n        toFontString: De,\n        toLineHeight: _i,\n        toPadding: ki,\n        toPercentage: h,\n        toRadians: $,\n        toTRBL: Mi,\n        toTRBLCorners: wi,\n        uid: i,\n        unclipArea: ze,\n        unlistenArrayEvents: rt,\n        valueOrDefault: l\n    });\n    function Ni(t, e, i, s) {\n        const { controller: n, data: o, _sorted: a } = t, r = n._cachedMeta.iScale;\n        if (r && e === r.axis && \"r\" !== e && a && o.length) {\n            const t = r._reversePixels ? st : it;\n            if (!s) return t(o, e, i);\n            if (n._sharedOptions) {\n                const s = o[0], n = \"function\" == typeof s.getRange && s.getRange(e);\n                if (n) {\n                    const s = t(o, e, i - n), a = t(o, e, i + n);\n                    return {\n                        lo: s.lo,\n                        hi: a.hi\n                    };\n                }\n            }\n        }\n        return {\n            lo: 0,\n            hi: o.length - 1\n        };\n    }\n    function Hi(t, e, i, s, n) {\n        const o = t.getSortedVisibleDatasetMetas(), a = i[e];\n        for(let t = 0, i = o.length; t < i; ++t){\n            const { index: i, data: r } = o[t], { lo: l, hi: h } = Ni(o[t], e, a, n);\n            for(let t = l; t <= h; ++t){\n                const e = r[t];\n                e.skip || s(e, i, t);\n            }\n        }\n    }\n    function ji(t, e, i, s, n) {\n        const o = [];\n        if (!n && !t.isPointInArea(e)) return o;\n        return Hi(t, i, e, function(i, a, r) {\n            (n || Re(i, t.chartArea, 0)) && i.inRange(e.x, e.y, s) && o.push({\n                element: i,\n                datasetIndex: a,\n                index: r\n            });\n        }, !0), o;\n    }\n    function $i(t, e, i, s, n, o) {\n        let a = [];\n        const r = function(t) {\n            const e = -1 !== t.indexOf(\"x\"), i = -1 !== t.indexOf(\"y\");\n            return function(t, s) {\n                const n = e ? Math.abs(t.x - s.x) : 0, o = i ? Math.abs(t.y - s.y) : 0;\n                return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));\n            };\n        }(i);\n        let l = Number.POSITIVE_INFINITY;\n        return Hi(t, i, e, function(i, h, c) {\n            const d = i.inRange(e.x, e.y, n);\n            if (s && !d) return;\n            const u = i.getCenterPoint(n);\n            if (!(!!o || t.isPointInArea(u)) && !d) return;\n            const f = r(e, u);\n            f < l ? (a = [\n                {\n                    element: i,\n                    datasetIndex: h,\n                    index: c\n                }\n            ], l = f) : f === l && a.push({\n                element: i,\n                datasetIndex: h,\n                index: c\n            });\n        }), a;\n    }\n    function Yi(t, e, i, s, n, o) {\n        return o || t.isPointInArea(e) ? \"r\" !== i || s ? $i(t, e, i, s, n, o) : function(t, e, i, s) {\n            let n = [];\n            return Hi(t, i, e, function(t, i, o) {\n                const { startAngle: a, endAngle: r } = t.getProps([\n                    \"startAngle\",\n                    \"endAngle\"\n                ], s), { angle: l } = X(t, {\n                    x: e.x,\n                    y: e.y\n                });\n                Z(l, a, r) && n.push({\n                    element: t,\n                    datasetIndex: i,\n                    index: o\n                });\n            }), n;\n        }(t, e, i, n) : [];\n    }\n    function Ui(t, e, i, s, n) {\n        const o = [], a = \"x\" === i ? \"inXRange\" : \"inYRange\";\n        let r = !1;\n        return Hi(t, i, e, (t, s, l)=>{\n            t[a](e[i], n) && (o.push({\n                element: t,\n                datasetIndex: s,\n                index: l\n            }), r = r || t.inRange(e.x, e.y, n));\n        }), s && !r ? [] : o;\n    }\n    var Xi = {\n        evaluateInteractionItems: Hi,\n        modes: {\n            index (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"x\", a = i.includeInvisible || !1, r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a), l = [];\n                return r.length ? (t.getSortedVisibleDatasetMetas().forEach((t)=>{\n                    const e = r[0].index, i = t.data[e];\n                    i && !i.skip && l.push({\n                        element: i,\n                        datasetIndex: t.index,\n                        index: e\n                    });\n                }), l) : [];\n            },\n            dataset (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                let r = i.intersect ? ji(t, n, o, s, a) : Yi(t, n, o, !1, s, a);\n                if (r.length > 0) {\n                    const e = r[0].datasetIndex, i = t.getDatasetMeta(e).data;\n                    r = [];\n                    for(let t = 0; t < i.length; ++t)r.push({\n                        element: i[t],\n                        datasetIndex: e,\n                        index: t\n                    });\n                }\n                return r;\n            },\n            point: (t, e, i, s)=>ji(t, ve(e, t), i.axis || \"xy\", s, i.includeInvisible || !1),\n            nearest (t, e, i, s) {\n                const n = ve(e, t), o = i.axis || \"xy\", a = i.includeInvisible || !1;\n                return Yi(t, n, o, i.intersect, s, a);\n            },\n            x: (t, e, i, s)=>Ui(t, ve(e, t), \"x\", i.intersect, s),\n            y: (t, e, i, s)=>Ui(t, ve(e, t), \"y\", i.intersect, s)\n        }\n    };\n    const qi = [\n        \"left\",\n        \"top\",\n        \"right\",\n        \"bottom\"\n    ];\n    function Ki(t, e) {\n        return t.filter((t)=>t.pos === e);\n    }\n    function Gi(t, e) {\n        return t.filter((t)=>-1 === qi.indexOf(t.pos) && t.box.axis === e);\n    }\n    function Zi(t, e) {\n        return t.sort((t, i)=>{\n            const s = e ? i : t, n = e ? t : i;\n            return s.weight === n.weight ? s.index - n.index : s.weight - n.weight;\n        });\n    }\n    function Ji(t, e) {\n        const i = function(t) {\n            const e = {};\n            for (const i of t){\n                const { stack: t, pos: s, stackWeight: n } = i;\n                if (!t || !qi.includes(s)) continue;\n                const o = e[t] || (e[t] = {\n                    count: 0,\n                    placed: 0,\n                    weight: 0,\n                    size: 0\n                });\n                o.count++, o.weight += n;\n            }\n            return e;\n        }(t), { vBoxMaxWidth: s, hBoxMaxHeight: n } = e;\n        let o, a, r;\n        for(o = 0, a = t.length; o < a; ++o){\n            r = t[o];\n            const { fullSize: a } = r.box, l = i[r.stack], h = l && r.stackWeight / l.weight;\n            r.horizontal ? (r.width = h ? h * s : a && e.availableWidth, r.height = n) : (r.width = s, r.height = h ? h * n : a && e.availableHeight);\n        }\n        return i;\n    }\n    function Qi(t, e, i, s) {\n        return Math.max(t[i], e[i]) + Math.max(t[s], e[s]);\n    }\n    function ts(t, e) {\n        t.top = Math.max(t.top, e.top), t.left = Math.max(t.left, e.left), t.bottom = Math.max(t.bottom, e.bottom), t.right = Math.max(t.right, e.right);\n    }\n    function es(t, e, i, s) {\n        const { pos: n, box: a } = i, r = t.maxPadding;\n        if (!o(n)) {\n            i.size && (t[n] -= i.size);\n            const e = s[i.stack] || {\n                size: 0,\n                count: 1\n            };\n            e.size = Math.max(e.size, i.horizontal ? a.height : a.width), i.size = e.size / e.count, t[n] += i.size;\n        }\n        a.getPadding && ts(r, a.getPadding());\n        const l = Math.max(0, e.outerWidth - Qi(r, t, \"left\", \"right\")), h = Math.max(0, e.outerHeight - Qi(r, t, \"top\", \"bottom\")), c = l !== t.w, d = h !== t.h;\n        return t.w = l, t.h = h, i.horizontal ? {\n            same: c,\n            other: d\n        } : {\n            same: d,\n            other: c\n        };\n    }\n    function is(t, e) {\n        const i = e.maxPadding;\n        function s(t) {\n            const s = {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            };\n            return t.forEach((t)=>{\n                s[t] = Math.max(e[t], i[t]);\n            }), s;\n        }\n        return s(t ? [\n            \"left\",\n            \"right\"\n        ] : [\n            \"top\",\n            \"bottom\"\n        ]);\n    }\n    function ss(t, e, i, s) {\n        const n = [];\n        let o, a, r, l, h, c;\n        for(o = 0, a = t.length, h = 0; o < a; ++o){\n            r = t[o], l = r.box, l.update(r.width || e.w, r.height || e.h, is(r.horizontal, e));\n            const { same: a, other: d } = es(e, i, r, s);\n            h |= a && n.length, c = c || d, l.fullSize || n.push(r);\n        }\n        return h && ss(n, e, i, s) || c;\n    }\n    function ns(t, e, i, s, n) {\n        t.top = i, t.left = e, t.right = e + s, t.bottom = i + n, t.width = s, t.height = n;\n    }\n    function os(t, e, i, s) {\n        const n = i.padding;\n        let { x: o, y: a } = e;\n        for (const r of t){\n            const t = r.box, l = s[r.stack] || {\n                count: 1,\n                placed: 0,\n                weight: 1\n            }, h = r.stackWeight / l.weight || 1;\n            if (r.horizontal) {\n                const s = e.w * h, o = l.size || t.height;\n                k(l.start) && (a = l.start), t.fullSize ? ns(t, n.left, a, i.outerWidth - n.right - n.left, o) : ns(t, e.left + l.placed, a, s, o), l.start = a, l.placed += s, a = t.bottom;\n            } else {\n                const s = e.h * h, a = l.size || t.width;\n                k(l.start) && (o = l.start), t.fullSize ? ns(t, o, n.top, a, i.outerHeight - n.bottom - n.top) : ns(t, o, e.top + l.placed, a, s), l.start = o, l.placed += s, o = t.right;\n            }\n        }\n        e.x = o, e.y = a;\n    }\n    var as = {\n        addBox (t, e) {\n            t.boxes || (t.boxes = []), e.fullSize = e.fullSize || !1, e.position = e.position || \"top\", e.weight = e.weight || 0, e._layers = e._layers || function() {\n                return [\n                    {\n                        z: 0,\n                        draw (t) {\n                            e.draw(t);\n                        }\n                    }\n                ];\n            }, t.boxes.push(e);\n        },\n        removeBox (t, e) {\n            const i = t.boxes ? t.boxes.indexOf(e) : -1;\n            -1 !== i && t.boxes.splice(i, 1);\n        },\n        configure (t, e, i) {\n            e.fullSize = i.fullSize, e.position = i.position, e.weight = i.weight;\n        },\n        update (t, e, i, s) {\n            if (!t) return;\n            const n = ki(t.options.layout.padding), o = Math.max(e - n.width, 0), a = Math.max(i - n.height, 0), r = function(t) {\n                const e = function(t) {\n                    const e = [];\n                    let i, s, n, o, a, r;\n                    for(i = 0, s = (t || []).length; i < s; ++i)n = t[i], ({ position: o, options: { stack: a, stackWeight: r = 1 } } = n), e.push({\n                        index: i,\n                        box: n,\n                        pos: o,\n                        horizontal: n.isHorizontal(),\n                        weight: n.weight,\n                        stack: a && o + a,\n                        stackWeight: r\n                    });\n                    return e;\n                }(t), i = Zi(e.filter((t)=>t.box.fullSize), !0), s = Zi(Ki(e, \"left\"), !0), n = Zi(Ki(e, \"right\")), o = Zi(Ki(e, \"top\"), !0), a = Zi(Ki(e, \"bottom\")), r = Gi(e, \"x\"), l = Gi(e, \"y\");\n                return {\n                    fullSize: i,\n                    leftAndTop: s.concat(o),\n                    rightAndBottom: n.concat(l).concat(a).concat(r),\n                    chartArea: Ki(e, \"chartArea\"),\n                    vertical: s.concat(n).concat(l),\n                    horizontal: o.concat(a).concat(r)\n                };\n            }(t.boxes), l = r.vertical, h = r.horizontal;\n            u(t.boxes, (t)=>{\n                \"function\" == typeof t.beforeLayout && t.beforeLayout();\n            });\n            const c = l.reduce((t, e)=>e.box.options && !1 === e.box.options.display ? t : t + 1, 0) || 1, d = Object.freeze({\n                outerWidth: e,\n                outerHeight: i,\n                padding: n,\n                availableWidth: o,\n                availableHeight: a,\n                vBoxMaxWidth: o / 2 / c,\n                hBoxMaxHeight: a / 2\n            }), f = Object.assign({}, n);\n            ts(f, ki(s));\n            const g = Object.assign({\n                maxPadding: f,\n                w: o,\n                h: a,\n                x: n.left,\n                y: n.top\n            }, n), p = Ji(l.concat(h), d);\n            ss(r.fullSize, g, d, p), ss(l, g, d, p), ss(h, g, d, p) && ss(l, g, d, p), function(t) {\n                const e = t.maxPadding;\n                function i(i) {\n                    const s = Math.max(e[i] - t[i], 0);\n                    return t[i] += s, s;\n                }\n                t.y += i(\"top\"), t.x += i(\"left\"), i(\"right\"), i(\"bottom\");\n            }(g), os(r.leftAndTop, g, d, p), g.x += g.w, g.y += g.h, os(r.rightAndBottom, g, d, p), t.chartArea = {\n                left: g.left,\n                top: g.top,\n                right: g.left + g.w,\n                bottom: g.top + g.h,\n                height: g.h,\n                width: g.w\n            }, u(r.chartArea, (e)=>{\n                const i = e.box;\n                Object.assign(i, t.chartArea), i.update(g.w, g.h, {\n                    left: 0,\n                    top: 0,\n                    right: 0,\n                    bottom: 0\n                });\n            });\n        }\n    };\n    class rs {\n        acquireContext(t, e) {}\n        releaseContext(t) {\n            return !1;\n        }\n        addEventListener(t, e, i) {}\n        removeEventListener(t, e, i) {}\n        getDevicePixelRatio() {\n            return 1;\n        }\n        getMaximumSize(t, e, i, s) {\n            return e = Math.max(0, e || t.width), i = i || t.height, {\n                width: e,\n                height: Math.max(0, s ? Math.floor(e / s) : i)\n            };\n        }\n        isAttached(t) {\n            return !0;\n        }\n        updateConfig(t) {}\n    }\n    class ls extends rs {\n        acquireContext(t) {\n            return t && t.getContext && t.getContext(\"2d\") || null;\n        }\n        updateConfig(t) {\n            t.options.animation = !1;\n        }\n    }\n    const hs = \"$chartjs\", cs = {\n        touchstart: \"mousedown\",\n        touchmove: \"mousemove\",\n        touchend: \"mouseup\",\n        pointerenter: \"mouseenter\",\n        pointerdown: \"mousedown\",\n        pointermove: \"mousemove\",\n        pointerup: \"mouseup\",\n        pointerleave: \"mouseout\",\n        pointerout: \"mouseout\"\n    }, ds = (t)=>null === t || \"\" === t;\n    const us = !!Se && {\n        passive: !0\n    };\n    function fs(t, e, i) {\n        t.canvas.removeEventListener(e, i, us);\n    }\n    function gs(t, e) {\n        for (const i of t)if (i === e || i.contains(e)) return !0;\n    }\n    function ps(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.addedNodes, s), e = e && !gs(i.removedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    function ms(t, e, i) {\n        const s = t.canvas, n = new MutationObserver((t)=>{\n            let e = !1;\n            for (const i of t)e = e || gs(i.removedNodes, s), e = e && !gs(i.addedNodes, s);\n            e && i();\n        });\n        return n.observe(document, {\n            childList: !0,\n            subtree: !0\n        }), n;\n    }\n    const bs = new Map;\n    let xs = 0;\n    function _s() {\n        const t = window.devicePixelRatio;\n        t !== xs && (xs = t, bs.forEach((e, i)=>{\n            i.currentDevicePixelRatio !== t && e();\n        }));\n    }\n    function ys(t, e, i) {\n        const s = t.canvas, n = s && ge(s);\n        if (!n) return;\n        const o = ct((t, e)=>{\n            const s = n.clientWidth;\n            i(t, e), s < n.clientWidth && i();\n        }, window), a = new ResizeObserver((t)=>{\n            const e = t[0], i = e.contentRect.width, s = e.contentRect.height;\n            0 === i && 0 === s || o(i, s);\n        });\n        return a.observe(n), function(t, e) {\n            bs.size || window.addEventListener(\"resize\", _s), bs.set(t, e);\n        }(t, o), a;\n    }\n    function vs(t, e, i) {\n        i && i.disconnect(), \"resize\" === e && function(t) {\n            bs.delete(t), bs.size || window.removeEventListener(\"resize\", _s);\n        }(t);\n    }\n    function Ms(t, e, i) {\n        const s = t.canvas, n = ct((e)=>{\n            null !== t.ctx && i(function(t, e) {\n                const i = cs[t.type] || t.type, { x: s, y: n } = ve(t, e);\n                return {\n                    type: i,\n                    chart: e,\n                    native: t,\n                    x: void 0 !== s ? s : null,\n                    y: void 0 !== n ? n : null\n                };\n            }(e, t));\n        }, t);\n        return function(t, e, i) {\n            t.addEventListener(e, i, us);\n        }(s, e, n), n;\n    }\n    class ws extends rs {\n        acquireContext(t, e) {\n            const i = t && t.getContext && t.getContext(\"2d\");\n            return i && i.canvas === t ? (function(t, e) {\n                const i = t.style, s = t.getAttribute(\"height\"), n = t.getAttribute(\"width\");\n                if (t[hs] = {\n                    initial: {\n                        height: s,\n                        width: n,\n                        style: {\n                            display: i.display,\n                            height: i.height,\n                            width: i.width\n                        }\n                    }\n                }, i.display = i.display || \"block\", i.boxSizing = i.boxSizing || \"border-box\", ds(n)) {\n                    const e = Pe(t, \"width\");\n                    void 0 !== e && (t.width = e);\n                }\n                if (ds(s)) {\n                    if (\"\" === t.style.height) t.height = t.width / (e || 2);\n                    else {\n                        const e = Pe(t, \"height\");\n                        void 0 !== e && (t.height = e);\n                    }\n                }\n            }(t, e), i) : null;\n        }\n        releaseContext(t) {\n            const e = t.canvas;\n            if (!e[hs]) return !1;\n            const i = e[hs].initial;\n            [\n                \"height\",\n                \"width\"\n            ].forEach((t)=>{\n                const n = i[t];\n                s(n) ? e.removeAttribute(t) : e.setAttribute(t, n);\n            });\n            const n = i.style || {};\n            return Object.keys(n).forEach((t)=>{\n                e.style[t] = n[t];\n            }), e.width = e.width, delete e[hs], !0;\n        }\n        addEventListener(t, e, i) {\n            this.removeEventListener(t, e);\n            const s = t.$proxies || (t.$proxies = {}), n = {\n                attach: ps,\n                detach: ms,\n                resize: ys\n            }[e] || Ms;\n            s[e] = n(t, e, i);\n        }\n        removeEventListener(t, e) {\n            const i = t.$proxies || (t.$proxies = {}), s = i[e];\n            if (!s) return;\n            (({\n                attach: vs,\n                detach: vs,\n                resize: vs\n            })[e] || fs)(t, e, s), i[e] = void 0;\n        }\n        getDevicePixelRatio() {\n            return window.devicePixelRatio;\n        }\n        getMaximumSize(t, e, i, s) {\n            return we(t, e, i, s);\n        }\n        isAttached(t) {\n            const e = ge(t);\n            return !(!e || !e.isConnected);\n        }\n    }\n    function ks(t) {\n        return !fe() || \"undefined\" != typeof OffscreenCanvas && t instanceof OffscreenCanvas ? ls : ws;\n    }\n    var Ss = Object.freeze({\n        __proto__: null,\n        BasePlatform: rs,\n        BasicPlatform: ls,\n        DomPlatform: ws,\n        _detectPlatform: ks\n    });\n    const Ps = \"transparent\", Ds = {\n        boolean: (t, e, i)=>i > .5 ? e : t,\n        color (t, e, i) {\n            const s = Qt(t || Ps), n = s.valid && Qt(e || Ps);\n            return n && n.valid ? n.mix(s, i).hexString() : e;\n        },\n        number: (t, e, i)=>t + (e - t) * i\n    };\n    class Cs {\n        constructor(t, e, i, s){\n            const n = e[i];\n            s = Pi([\n                t.to,\n                s,\n                n,\n                t.from\n            ]);\n            const o = Pi([\n                t.from,\n                n,\n                s\n            ]);\n            this._active = !0, this._fn = t.fn || Ds[t.type || typeof o], this._easing = fi[t.easing] || fi.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = e, this._prop = i, this._from = o, this._to = s, this._promises = void 0;\n        }\n        active() {\n            return this._active;\n        }\n        update(t, e, i) {\n            if (this._active) {\n                this._notify(!1);\n                const s = this._target[this._prop], n = i - this._start, o = this._duration - n;\n                this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += n, this._loop = !!t.loop, this._to = Pi([\n                    t.to,\n                    e,\n                    s,\n                    t.from\n                ]), this._from = Pi([\n                    t.from,\n                    s,\n                    e\n                ]);\n            }\n        }\n        cancel() {\n            this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));\n        }\n        tick(t) {\n            const e = t - this._start, i = this._duration, s = this._prop, n = this._from, o = this._loop, a = this._to;\n            let r;\n            if (this._active = n !== a && (o || e < i), !this._active) return this._target[s] = a, void this._notify(!0);\n            e < 0 ? this._target[s] = n : (r = e / i % 2, r = o && r > 1 ? 2 - r : r, r = this._easing(Math.min(1, Math.max(0, r))), this._target[s] = this._fn(n, a, r));\n        }\n        wait() {\n            const t = this._promises || (this._promises = []);\n            return new Promise((e, i)=>{\n                t.push({\n                    res: e,\n                    rej: i\n                });\n            });\n        }\n        _notify(t) {\n            const e = t ? \"res\" : \"rej\", i = this._promises || [];\n            for(let t = 0; t < i.length; t++)i[t][e]();\n        }\n    }\n    class Os {\n        constructor(t, e){\n            this._chart = t, this._properties = new Map, this.configure(e);\n        }\n        configure(t) {\n            if (!o(t)) return;\n            const e = Object.keys(ue.animation), i = this._properties;\n            Object.getOwnPropertyNames(t).forEach((s)=>{\n                const a = t[s];\n                if (!o(a)) return;\n                const r = {};\n                for (const t of e)r[t] = a[t];\n                (n(a.properties) && a.properties || [\n                    s\n                ]).forEach((t)=>{\n                    t !== s && i.has(t) || i.set(t, r);\n                });\n            });\n        }\n        _animateOptions(t, e) {\n            const i = e.options, s = function(t, e) {\n                if (!e) return;\n                let i = t.options;\n                if (!i) return void (t.options = e);\n                i.$shared && (t.options = i = Object.assign({}, i, {\n                    $shared: !1,\n                    $animations: {}\n                }));\n                return i;\n            }(t, i);\n            if (!s) return [];\n            const n = this._createAnimations(s, i);\n            return i.$shared && (function(t, e) {\n                const i = [], s = Object.keys(e);\n                for(let e = 0; e < s.length; e++){\n                    const n = t[s[e]];\n                    n && n.active() && i.push(n.wait());\n                }\n                return Promise.all(i);\n            })(t.options.$animations, i).then(()=>{\n                t.options = i;\n            }, ()=>{}), n;\n        }\n        _createAnimations(t, e) {\n            const i = this._properties, s = [], n = t.$animations || (t.$animations = {}), o = Object.keys(e), a = Date.now();\n            let r;\n            for(r = o.length - 1; r >= 0; --r){\n                const l = o[r];\n                if (\"$\" === l.charAt(0)) continue;\n                if (\"options\" === l) {\n                    s.push(...this._animateOptions(t, e));\n                    continue;\n                }\n                const h = e[l];\n                let c = n[l];\n                const d = i.get(l);\n                if (c) {\n                    if (d && c.active()) {\n                        c.update(d, h, a);\n                        continue;\n                    }\n                    c.cancel();\n                }\n                d && d.duration ? (n[l] = c = new Cs(d, t, l, h), s.push(c)) : t[l] = h;\n            }\n            return s;\n        }\n        update(t, e) {\n            if (0 === this._properties.size) return void Object.assign(t, e);\n            const i = this._createAnimations(t, e);\n            return i.length ? (xt.add(this._chart, i), !0) : void 0;\n        }\n    }\n    function As(t, e) {\n        const i = t && t.options || {}, s = i.reverse, n = void 0 === i.min ? e : 0, o = void 0 === i.max ? e : 0;\n        return {\n            start: s ? o : n,\n            end: s ? n : o\n        };\n    }\n    function Ts(t, e) {\n        const i = [], s = t._getSortedDatasetMetas(e);\n        let n, o;\n        for(n = 0, o = s.length; n < o; ++n)i.push(s[n].index);\n        return i;\n    }\n    function Ls(t, e, i, s = {}) {\n        const n = t.keys, o = \"single\" === s.mode;\n        let r, l, h, c;\n        if (null !== e) {\n            for(r = 0, l = n.length; r < l; ++r){\n                if (h = +n[r], h === i) {\n                    if (s.all) continue;\n                    break;\n                }\n                c = t.values[h], a(c) && (o || 0 === e || F(e) === F(c)) && (e += c);\n            }\n            return e;\n        }\n    }\n    function Es(t, e) {\n        const i = t && t.options.stacked;\n        return i || void 0 === i && void 0 !== e.stack;\n    }\n    function Rs(t, e, i) {\n        const s = t[e] || (t[e] = {});\n        return s[i] || (s[i] = {});\n    }\n    function Is(t, e, i, s) {\n        for (const n of e.getMatchingVisibleMetas(s).reverse()){\n            const e = t[n.index];\n            if (i && e > 0 || !i && e < 0) return n.index;\n        }\n        return null;\n    }\n    function zs(t, e) {\n        const { chart: i, _cachedMeta: s } = t, n = i._stacks || (i._stacks = {}), { iScale: o, vScale: a, index: r } = s, l = o.axis, h = a.axis, c = function(t, e, i) {\n            return `${t.id}.${e.id}.${i.stack || i.type}`;\n        }(o, a, s), d = e.length;\n        let u;\n        for(let t = 0; t < d; ++t){\n            const i = e[t], { [l]: o, [h]: d } = i;\n            u = (i._stacks || (i._stacks = {}))[h] = Rs(n, c, o), u[r] = d, u._top = Is(u, a, !0, s.type), u._bottom = Is(u, a, !1, s.type);\n            (u._visualValues || (u._visualValues = {}))[r] = d;\n        }\n    }\n    function Fs(t, e) {\n        const i = t.scales;\n        return Object.keys(i).filter((t)=>i[t].axis === e).shift();\n    }\n    function Vs(t, e) {\n        const i = t.controller.index, s = t.vScale && t.vScale.axis;\n        if (s) {\n            e = e || t._parsed;\n            for (const t of e){\n                const e = t._stacks;\n                if (!e || void 0 === e[s] || void 0 === e[s][i]) return;\n                delete e[s][i], void 0 !== e[s]._visualValues && void 0 !== e[s]._visualValues[i] && delete e[s]._visualValues[i];\n            }\n        }\n    }\n    const Bs = (t)=>\"reset\" === t || \"none\" === t, Ws = (t, e)=>e ? t : Object.assign({}, t);\n    class Ns {\n        static defaults = {};\n        static datasetElementType = null;\n        static dataElementType = null;\n        constructor(t, e){\n            this.chart = t, this._ctx = t.ctx, this.index = e, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();\n        }\n        initialize() {\n            const t = this._cachedMeta;\n            this.configure(), this.linkScales(), t._stacked = Es(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled(\"filler\") && console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n        updateIndex(t) {\n            this.index !== t && Vs(this._cachedMeta), this.index = t;\n        }\n        linkScales() {\n            const t = this.chart, e = this._cachedMeta, i = this.getDataset(), s = (t, e, i, s)=>\"x\" === t ? e : \"r\" === t ? s : i, n = e.xAxisID = l(i.xAxisID, Fs(t, \"x\")), o = e.yAxisID = l(i.yAxisID, Fs(t, \"y\")), a = e.rAxisID = l(i.rAxisID, Fs(t, \"r\")), r = e.indexAxis, h = e.iAxisID = s(r, n, o, a), c = e.vAxisID = s(r, o, n, a);\n            e.xScale = this.getScaleForId(n), e.yScale = this.getScaleForId(o), e.rScale = this.getScaleForId(a), e.iScale = this.getScaleForId(h), e.vScale = this.getScaleForId(c);\n        }\n        getDataset() {\n            return this.chart.data.datasets[this.index];\n        }\n        getMeta() {\n            return this.chart.getDatasetMeta(this.index);\n        }\n        getScaleForId(t) {\n            return this.chart.scales[t];\n        }\n        _getOtherScale(t) {\n            const e = this._cachedMeta;\n            return t === e.iScale ? e.vScale : e.iScale;\n        }\n        reset() {\n            this._update(\"reset\");\n        }\n        _destroy() {\n            const t = this._cachedMeta;\n            this._data && rt(this._data, this), t._stacked && Vs(t);\n        }\n        _dataCheck() {\n            const t = this.getDataset(), e = t.data || (t.data = []), i = this._data;\n            if (o(e)) this._data = function(t) {\n                const e = Object.keys(t), i = new Array(e.length);\n                let s, n, o;\n                for(s = 0, n = e.length; s < n; ++s)o = e[s], i[s] = {\n                    x: o,\n                    y: t[o]\n                };\n                return i;\n            }(e);\n            else if (i !== e) {\n                if (i) {\n                    rt(i, this);\n                    const t = this._cachedMeta;\n                    Vs(t), t._parsed = [];\n                }\n                e && Object.isExtensible(e) && at(e, this), this._syncList = [], this._data = e;\n            }\n        }\n        addElements() {\n            const t = this._cachedMeta;\n            this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType);\n        }\n        buildOrUpdateElements(t) {\n            const e = this._cachedMeta, i = this.getDataset();\n            let s = !1;\n            this._dataCheck();\n            const n = e._stacked;\n            e._stacked = Es(e.vScale, e), e.stack !== i.stack && (s = !0, Vs(e), e.stack = i.stack), this._resyncElements(t), (s || n !== e._stacked) && zs(this, e._parsed);\n        }\n        configure() {\n            const t = this.chart.config, e = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), e, !0);\n            this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};\n        }\n        parse(t, e) {\n            const { _cachedMeta: i, _data: s } = this, { iScale: a, _stacked: r } = i, l = a.axis;\n            let h, c, d, u = 0 === t && e === s.length || i._sorted, f = t > 0 && i._parsed[t - 1];\n            if (!1 === this._parsing) i._parsed = s, i._sorted = !0, d = s;\n            else {\n                d = n(s[t]) ? this.parseArrayData(i, s, t, e) : o(s[t]) ? this.parseObjectData(i, s, t, e) : this.parsePrimitiveData(i, s, t, e);\n                const a = ()=>null === c[l] || f && c[l] < f[l];\n                for(h = 0; h < e; ++h)i._parsed[h + t] = c = d[h], u && (a() && (u = !1), f = c);\n                i._sorted = u;\n            }\n            r && zs(this, d);\n        }\n        parsePrimitiveData(t, e, i, s) {\n            const { iScale: n, vScale: o } = t, a = n.axis, r = o.axis, l = n.getLabels(), h = n === o, c = new Array(s);\n            let d, u, f;\n            for(d = 0, u = s; d < u; ++d)f = d + i, c[d] = {\n                [a]: h || n.parse(l[f], f),\n                [r]: o.parse(e[f], f)\n            };\n            return c;\n        }\n        parseArrayData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, a = new Array(s);\n            let r, l, h, c;\n            for(r = 0, l = s; r < l; ++r)h = r + i, c = e[h], a[r] = {\n                x: n.parse(c[0], h),\n                y: o.parse(c[1], h)\n            };\n            return a;\n        }\n        parseObjectData(t, e, i, s) {\n            const { xScale: n, yScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = new Array(s);\n            let h, c, d, u;\n            for(h = 0, c = s; h < c; ++h)d = h + i, u = e[d], l[h] = {\n                x: n.parse(M(u, a), d),\n                y: o.parse(M(u, r), d)\n            };\n            return l;\n        }\n        getParsed(t) {\n            return this._cachedMeta._parsed[t];\n        }\n        getDataElement(t) {\n            return this._cachedMeta.data[t];\n        }\n        applyStack(t, e, i) {\n            const s = this.chart, n = this._cachedMeta, o = e[t.axis];\n            return Ls({\n                keys: Ts(s, !0),\n                values: e._stacks[t.axis]._visualValues\n            }, o, n.index, {\n                mode: i\n            });\n        }\n        updateRangeFromParsed(t, e, i, s) {\n            const n = i[e.axis];\n            let o = null === n ? NaN : n;\n            const a = s && i._stacks[e.axis];\n            s && a && (s.values = a, o = Ls(s, n, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);\n        }\n        getMinMax(t, e) {\n            const i = this._cachedMeta, s = i._parsed, n = i._sorted && t === i.iScale, o = s.length, r = this._getOtherScale(t), l = ((t, e, i)=>t && !e.hidden && e._stacked && {\n                    keys: Ts(i, !0),\n                    values: null\n                })(e, i, this.chart), h = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            }, { min: c, max: d } = function(t) {\n                const { min: e, max: i, minDefined: s, maxDefined: n } = t.getUserBounds();\n                return {\n                    min: s ? e : Number.NEGATIVE_INFINITY,\n                    max: n ? i : Number.POSITIVE_INFINITY\n                };\n            }(r);\n            let u, f;\n            function g() {\n                f = s[u];\n                const e = f[r.axis];\n                return !a(f[t.axis]) || c > e || d < e;\n            }\n            for(u = 0; u < o && (g() || (this.updateRangeFromParsed(h, t, f, l), !n)); ++u);\n            if (n) {\n                for(u = o - 1; u >= 0; --u)if (!g()) {\n                    this.updateRangeFromParsed(h, t, f, l);\n                    break;\n                }\n            }\n            return h;\n        }\n        getAllParsedValues(t) {\n            const e = this._cachedMeta._parsed, i = [];\n            let s, n, o;\n            for(s = 0, n = e.length; s < n; ++s)o = e[s][t.axis], a(o) && i.push(o);\n            return i;\n        }\n        getMaxOverflow() {\n            return !1;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = e.iScale, s = e.vScale, n = this.getParsed(t);\n            return {\n                label: i ? \"\" + i.getLabelForValue(n[i.axis]) : \"\",\n                value: s ? \"\" + s.getLabelForValue(n[s.axis]) : \"\"\n            };\n        }\n        _update(t) {\n            const e = this._cachedMeta;\n            this.update(t || \"default\"), e._clip = function(t) {\n                let e, i, s, n;\n                return o(t) ? (e = t.top, i = t.right, s = t.bottom, n = t.left) : e = i = s = n = t, {\n                    top: e,\n                    right: i,\n                    bottom: s,\n                    left: n,\n                    disabled: !1 === t\n                };\n            }(l(this.options.clip, function(t, e, i) {\n                if (!1 === i) return !1;\n                const s = As(t, i), n = As(e, i);\n                return {\n                    top: n.end,\n                    right: s.end,\n                    bottom: n.start,\n                    left: s.start\n                };\n            }(e.xScale, e.yScale, this.getMaxOverflow())));\n        }\n        update(t) {}\n        draw() {\n            const t = this._ctx, e = this.chart, i = this._cachedMeta, s = i.data || [], n = e.chartArea, o = [], a = this._drawStart || 0, r = this._drawCount || s.length - a, l = this.options.drawActiveElementsOnTop;\n            let h;\n            for(i.dataset && i.dataset.draw(t, n, a, r), h = a; h < a + r; ++h){\n                const e = s[h];\n                e.hidden || (e.active && l ? o.push(e) : e.draw(t, n));\n            }\n            for(h = 0; h < o.length; ++h)o[h].draw(t, n);\n        }\n        getStyle(t, e) {\n            const i = e ? \"active\" : \"default\";\n            return void 0 === t && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);\n        }\n        getContext(t, e, i) {\n            const s = this.getDataset();\n            let n;\n            if (t >= 0 && t < this._cachedMeta.data.length) {\n                const e = this._cachedMeta.data[t];\n                n = e.$context || (e.$context = function(t, e, i) {\n                    return Ci(t, {\n                        active: !1,\n                        dataIndex: e,\n                        parsed: void 0,\n                        raw: void 0,\n                        element: i,\n                        index: e,\n                        mode: \"default\",\n                        type: \"data\"\n                    });\n                }(this.getContext(), t, e)), n.parsed = this.getParsed(t), n.raw = s.data[t], n.index = n.dataIndex = t;\n            } else n = this.$context || (this.$context = function(t, e) {\n                return Ci(t, {\n                    active: !1,\n                    dataset: void 0,\n                    datasetIndex: e,\n                    index: e,\n                    mode: \"default\",\n                    type: \"dataset\"\n                });\n            }(this.chart.getContext(), this.index)), n.dataset = s, n.index = n.datasetIndex = this.index;\n            return n.active = !!e, n.mode = i, n;\n        }\n        resolveDatasetElementOptions(t) {\n            return this._resolveElementOptions(this.datasetElementType.id, t);\n        }\n        resolveDataElementOptions(t, e) {\n            return this._resolveElementOptions(this.dataElementType.id, e, t);\n        }\n        _resolveElementOptions(t, e = \"default\", i) {\n            const s = \"active\" === e, n = this._cachedDataOpts, o = t + \"-\" + e, a = n[o], r = this.enableOptionSharing && k(i);\n            if (a) return Ws(a, r);\n            const l = this.chart.config, h = l.datasetElementScopeKeys(this._type, t), c = s ? [\n                `${t}Hover`,\n                \"hover\",\n                t,\n                \"\"\n            ] : [\n                t,\n                \"\"\n            ], d = l.getOptionScopes(this.getDataset(), h), u = Object.keys(ue.elements[t]), f = l.resolveNamedOptions(d, u, ()=>this.getContext(i, s, e), c);\n            return f.$shared && (f.$shared = r, n[o] = Object.freeze(Ws(f, r))), f;\n        }\n        _resolveAnimations(t, e, i) {\n            const s = this.chart, n = this._cachedDataOpts, o = `animation-${e}`, a = n[o];\n            if (a) return a;\n            let r;\n            if (!1 !== s.options.animation) {\n                const s = this.chart.config, n = s.datasetAnimationScopeKeys(this._type, e), o = s.getOptionScopes(this.getDataset(), n);\n                r = s.createResolver(o, this.getContext(t, i, e));\n            }\n            const l = new Os(s, r && r.animations);\n            return r && r._cacheable && (n[o] = Object.freeze(l)), l;\n        }\n        getSharedOptions(t) {\n            if (t.$shared) return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));\n        }\n        includeOptions(t, e) {\n            return !e || Bs(t) || this.chart._animationsDisabled;\n        }\n        _getSharedOptions(t, e) {\n            const i = this.resolveDataElementOptions(t, e), s = this._sharedOptions, n = this.getSharedOptions(i), o = this.includeOptions(e, n) || n !== s;\n            return this.updateSharedOptions(n, e, i), {\n                sharedOptions: n,\n                includeOptions: o\n            };\n        }\n        updateElement(t, e, i, s) {\n            Bs(s) ? Object.assign(t, i) : this._resolveAnimations(e, s).update(t, i);\n        }\n        updateSharedOptions(t, e, i) {\n            t && !Bs(e) && this._resolveAnimations(void 0, e).update(t, i);\n        }\n        _setStyle(t, e, i, s) {\n            t.active = s;\n            const n = this.getStyle(e, s);\n            this._resolveAnimations(e, i, s).update(t, {\n                options: !s && this.getSharedOptions(n) || n\n            });\n        }\n        removeHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !1);\n        }\n        setHoverStyle(t, e, i) {\n            this._setStyle(t, i, \"active\", !0);\n        }\n        _removeDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !1);\n        }\n        _setDatasetHoverStyle() {\n            const t = this._cachedMeta.dataset;\n            t && this._setStyle(t, void 0, \"active\", !0);\n        }\n        _resyncElements(t) {\n            const e = this._data, i = this._cachedMeta.data;\n            for (const [t, e, i] of this._syncList)this[t](e, i);\n            this._syncList = [];\n            const s = i.length, n = e.length, o = Math.min(n, s);\n            o && this.parse(0, o), n > s ? this._insertElements(s, n - s, t) : n < s && this._removeElements(n, s - n);\n        }\n        _insertElements(t, e, i = !0) {\n            const s = this._cachedMeta, n = s.data, o = t + e;\n            let a;\n            const r = (t)=>{\n                for(t.length += e, a = t.length - 1; a >= o; a--)t[a] = t[a - e];\n            };\n            for(r(n), a = t; a < o; ++a)n[a] = new this.dataElementType;\n            this._parsing && r(s._parsed), this.parse(t, e), i && this.updateElements(n, t, e, \"reset\");\n        }\n        updateElements(t, e, i, s) {}\n        _removeElements(t, e) {\n            const i = this._cachedMeta;\n            if (this._parsing) {\n                const s = i._parsed.splice(t, e);\n                i._stacked && Vs(i, s);\n            }\n            i.data.splice(t, e);\n        }\n        _sync(t) {\n            if (this._parsing) this._syncList.push(t);\n            else {\n                const [e, i, s] = t;\n                this[e](i, s);\n            }\n            this.chart._dataChanges.push([\n                this.index,\n                ...t\n            ]);\n        }\n        _onDataPush() {\n            const t = arguments.length;\n            this._sync([\n                \"_insertElements\",\n                this.getDataset().data.length - t,\n                t\n            ]);\n        }\n        _onDataPop() {\n            this._sync([\n                \"_removeElements\",\n                this._cachedMeta.data.length - 1,\n                1\n            ]);\n        }\n        _onDataShift() {\n            this._sync([\n                \"_removeElements\",\n                0,\n                1\n            ]);\n        }\n        _onDataSplice(t, e) {\n            e && this._sync([\n                \"_removeElements\",\n                t,\n                e\n            ]);\n            const i = arguments.length - 2;\n            i && this._sync([\n                \"_insertElements\",\n                t,\n                i\n            ]);\n        }\n        _onDataUnshift() {\n            this._sync([\n                \"_insertElements\",\n                0,\n                arguments.length\n            ]);\n        }\n    }\n    class Hs {\n        static defaults = {};\n        static defaultRoutes = void 0;\n        x;\n        y;\n        active = !1;\n        options;\n        $animations;\n        tooltipPosition(t) {\n            const { x: e, y: i } = this.getProps([\n                \"x\",\n                \"y\"\n            ], t);\n            return {\n                x: e,\n                y: i\n            };\n        }\n        hasValue() {\n            return N(this.x) && N(this.y);\n        }\n        getProps(t, e) {\n            const i = this.$animations;\n            if (!e || !i) return this;\n            const s = {};\n            return t.forEach((t)=>{\n                s[t] = i[t] && i[t].active() ? i[t]._to : this[t];\n            }), s;\n        }\n    }\n    function js(t, e) {\n        const i = t.options.ticks, n = function(t) {\n            const e = t.options.offset, i = t._tickSize(), s = t._length / i + (e ? 0 : 1), n = t._maxLength / i;\n            return Math.floor(Math.min(s, n));\n        }(t), o = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? function(t) {\n            const e = [];\n            let i, s;\n            for(i = 0, s = t.length; i < s; i++)t[i].major && e.push(i);\n            return e;\n        }(e) : [], r = a.length, l = a[0], h = a[r - 1], c = [];\n        if (r > o) return function(t, e, i, s) {\n            let n, o = 0, a = i[0];\n            for(s = Math.ceil(s), n = 0; n < t.length; n++)n === a && (e.push(t[n]), o++, a = i[o * s]);\n        }(e, c, a, r / o), c;\n        const d = function(t, e, i) {\n            const s = function(t) {\n                const e = t.length;\n                let i, s;\n                if (e < 2) return !1;\n                for(s = t[0], i = 1; i < e; ++i)if (t[i] - t[i - 1] !== s) return !1;\n                return s;\n            }(t), n = e.length / i;\n            if (!s) return Math.max(n, 1);\n            const o = W(s);\n            for(let t = 0, e = o.length - 1; t < e; t++){\n                const e = o[t];\n                if (e > n) return e;\n            }\n            return Math.max(n, 1);\n        }(a, e, o);\n        if (r > 0) {\n            let t, i;\n            const n = r > 1 ? Math.round((h - l) / (r - 1)) : null;\n            for($s(e, c, d, s(n) ? 0 : l - n, l), t = 0, i = r - 1; t < i; t++)$s(e, c, d, a[t], a[t + 1]);\n            return $s(e, c, d, h, s(n) ? e.length : h + n), c;\n        }\n        return $s(e, c, d), c;\n    }\n    function $s(t, e, i, s, n) {\n        const o = l(s, 0), a = Math.min(l(n, t.length), t.length);\n        let r, h, c, d = 0;\n        for(i = Math.ceil(i), n && (r = n - s, i = r / Math.floor(r / i)), c = o; c < 0;)d++, c = Math.round(o + d * i);\n        for(h = Math.max(o, 0); h < a; h++)h === c && (e.push(t[h]), d++, c = Math.round(o + d * i));\n    }\n    const Ys = (t, e, i)=>\"top\" === e || \"left\" === e ? t[e] + i : t[e] - i, Us = (t, e)=>Math.min(e || t, t);\n    function Xs(t, e) {\n        const i = [], s = t.length / e, n = t.length;\n        let o = 0;\n        for(; o < n; o += s)i.push(t[Math.floor(o)]);\n        return i;\n    }\n    function qs(t, e, i) {\n        const s = t.ticks.length, n = Math.min(e, s - 1), o = t._startPixel, a = t._endPixel, r = 1e-6;\n        let l, h = t.getPixelForTick(n);\n        if (!(i && (l = 1 === s ? Math.max(h - o, a - h) : 0 === e ? (t.getPixelForTick(1) - h) / 2 : (h - t.getPixelForTick(n - 1)) / 2, h += n < e ? l : -l, h < o - r || h > a + r))) return h;\n    }\n    function Ks(t) {\n        return t.drawTicks ? t.tickLength : 0;\n    }\n    function Gs(t, e) {\n        if (!t.display) return 0;\n        const i = Si(t.font, e), s = ki(t.padding);\n        return (n(t.text) ? t.text.length : 1) * i.lineHeight + s.height;\n    }\n    function Zs(t, e, i) {\n        let s = ut(t);\n        return (i && \"right\" !== e || !i && \"right\" === e) && (s = ((t)=>\"left\" === t ? \"right\" : \"right\" === t ? \"left\" : t)(s)), s;\n    }\n    class Js extends Hs {\n        constructor(t){\n            super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;\n        }\n        init(t) {\n            this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);\n        }\n        parse(t, e) {\n            return t;\n        }\n        getUserBounds() {\n            let { _userMin: t, _userMax: e, _suggestedMin: i, _suggestedMax: s } = this;\n            return t = r(t, Number.POSITIVE_INFINITY), e = r(e, Number.NEGATIVE_INFINITY), i = r(i, Number.POSITIVE_INFINITY), s = r(s, Number.NEGATIVE_INFINITY), {\n                min: r(t, i),\n                max: r(e, s),\n                minDefined: a(t),\n                maxDefined: a(e)\n            };\n        }\n        getMinMax(t) {\n            let e, { min: i, max: s, minDefined: n, maxDefined: o } = this.getUserBounds();\n            if (n && o) return {\n                min: i,\n                max: s\n            };\n            const a = this.getMatchingVisibleMetas();\n            for(let r = 0, l = a.length; r < l; ++r)e = a[r].controller.getMinMax(this, t), n || (i = Math.min(i, e.min)), o || (s = Math.max(s, e.max));\n            return i = o && i > s ? s : i, s = n && i > s ? i : s, {\n                min: r(i, r(s, i)),\n                max: r(s, r(i, s))\n            };\n        }\n        getPadding() {\n            return {\n                left: this.paddingLeft || 0,\n                top: this.paddingTop || 0,\n                right: this.paddingRight || 0,\n                bottom: this.paddingBottom || 0\n            };\n        }\n        getTicks() {\n            return this.ticks;\n        }\n        getLabels() {\n            const t = this.chart.data;\n            return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];\n        }\n        getLabelItems(t = this.chart.chartArea) {\n            return this._labelItems || (this._labelItems = this._computeLabelItems(t));\n        }\n        beforeLayout() {\n            this._cache = {}, this._dataLimitsCached = !1;\n        }\n        beforeUpdate() {\n            d(this.options.beforeUpdate, [\n                this\n            ]);\n        }\n        update(t, e, i) {\n            const { beginAtZero: s, grace: n, ticks: o } = this.options, a = o.sampleSize;\n            this.beforeUpdate(), this.maxWidth = t, this.maxHeight = e, this._margins = i = Object.assign({\n                left: 0,\n                right: 0,\n                top: 0,\n                bottom: 0\n            }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = Di(this, n, s), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();\n            const r = a < this.ticks.length;\n            this._convertTicksToLabels(r ? Xs(this.ticks, a) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || \"auto\" === o.source) && (this.ticks = js(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), r && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();\n        }\n        configure() {\n            let t, e, i = this.options.reverse;\n            this.isHorizontal() ? (t = this.left, e = this.right) : (t = this.top, e = this.bottom, i = !i), this._startPixel = t, this._endPixel = e, this._reversePixels = i, this._length = e - t, this._alignToPixels = this.options.alignToPixels;\n        }\n        afterUpdate() {\n            d(this.options.afterUpdate, [\n                this\n            ]);\n        }\n        beforeSetDimensions() {\n            d(this.options.beforeSetDimensions, [\n                this\n            ]);\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;\n        }\n        afterSetDimensions() {\n            d(this.options.afterSetDimensions, [\n                this\n            ]);\n        }\n        _callHooks(t) {\n            this.chart.notifyPlugins(t, this.getContext()), d(this.options[t], [\n                this\n            ]);\n        }\n        beforeDataLimits() {\n            this._callHooks(\"beforeDataLimits\");\n        }\n        determineDataLimits() {}\n        afterDataLimits() {\n            this._callHooks(\"afterDataLimits\");\n        }\n        beforeBuildTicks() {\n            this._callHooks(\"beforeBuildTicks\");\n        }\n        buildTicks() {\n            return [];\n        }\n        afterBuildTicks() {\n            this._callHooks(\"afterBuildTicks\");\n        }\n        beforeTickToLabelConversion() {\n            d(this.options.beforeTickToLabelConversion, [\n                this\n            ]);\n        }\n        generateTickLabels(t) {\n            const e = this.options.ticks;\n            let i, s, n;\n            for(i = 0, s = t.length; i < s; i++)n = t[i], n.label = d(e.callback, [\n                n.value,\n                i,\n                t\n            ], this);\n        }\n        afterTickToLabelConversion() {\n            d(this.options.afterTickToLabelConversion, [\n                this\n            ]);\n        }\n        beforeCalculateLabelRotation() {\n            d(this.options.beforeCalculateLabelRotation, [\n                this\n            ]);\n        }\n        calculateLabelRotation() {\n            const t = this.options, e = t.ticks, i = Us(this.ticks.length, t.ticks.maxTicksLimit), s = e.minRotation || 0, n = e.maxRotation;\n            let o, a, r, l = s;\n            if (!this._isVisible() || !e.display || s >= n || i <= 1 || !this.isHorizontal()) return void (this.labelRotation = s);\n            const h = this._getLabelSizes(), c = h.widest.width, d = h.highest.height, u = J(this.chart.width - c, 0, this.maxWidth);\n            o = t.offset ? this.maxWidth / i : u / (i - 1), c + 6 > o && (o = u / (i - (t.offset ? .5 : 1)), a = this.maxHeight - Ks(t.grid) - e.padding - Gs(t.title, this.chart.options.font), r = Math.sqrt(c * c + d * d), l = Y(Math.min(Math.asin(J((h.highest.height + 6) / o, -1, 1)), Math.asin(J(a / r, -1, 1)) - Math.asin(J(d / r, -1, 1)))), l = Math.max(s, Math.min(n, l))), this.labelRotation = l;\n        }\n        afterCalculateLabelRotation() {\n            d(this.options.afterCalculateLabelRotation, [\n                this\n            ]);\n        }\n        afterAutoSkip() {}\n        beforeFit() {\n            d(this.options.beforeFit, [\n                this\n            ]);\n        }\n        fit() {\n            const t = {\n                width: 0,\n                height: 0\n            }, { chart: e, options: { ticks: i, title: s, grid: n } } = this, o = this._isVisible(), a = this.isHorizontal();\n            if (o) {\n                const o = Gs(s, e.options.font);\n                if (a ? (t.width = this.maxWidth, t.height = Ks(n) + o) : (t.height = this.maxHeight, t.width = Ks(n) + o), i.display && this.ticks.length) {\n                    const { first: e, last: s, widest: n, highest: o } = this._getLabelSizes(), r = 2 * i.padding, l = $(this.labelRotation), h = Math.cos(l), c = Math.sin(l);\n                    if (a) {\n                        const e = i.mirror ? 0 : c * n.width + h * o.height;\n                        t.height = Math.min(this.maxHeight, t.height + e + r);\n                    } else {\n                        const e = i.mirror ? 0 : h * n.width + c * o.height;\n                        t.width = Math.min(this.maxWidth, t.width + e + r);\n                    }\n                    this._calculatePadding(e, s, c, h);\n                }\n            }\n            this._handleMargins(), a ? (this.width = this._length = e.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = e.height - this._margins.top - this._margins.bottom);\n        }\n        _calculatePadding(t, e, i, s) {\n            const { ticks: { align: n, padding: o }, position: a } = this.options, r = 0 !== this.labelRotation, l = \"top\" !== a && \"x\" === this.axis;\n            if (this.isHorizontal()) {\n                const a = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);\n                let c = 0, d = 0;\n                r ? l ? (c = s * t.width, d = i * e.height) : (c = i * t.height, d = s * e.width) : \"start\" === n ? d = e.width : \"end\" === n ? c = t.width : \"inner\" !== n && (c = t.width / 2, d = e.width / 2), this.paddingLeft = Math.max((c - a + o) * this.width / (this.width - a), 0), this.paddingRight = Math.max((d - h + o) * this.width / (this.width - h), 0);\n            } else {\n                let i = e.height / 2, s = t.height / 2;\n                \"start\" === n ? (i = 0, s = t.height) : \"end\" === n && (i = e.height, s = 0), this.paddingTop = i + o, this.paddingBottom = s + o;\n            }\n        }\n        _handleMargins() {\n            this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));\n        }\n        afterFit() {\n            d(this.options.afterFit, [\n                this\n            ]);\n        }\n        isHorizontal() {\n            const { axis: t, position: e } = this.options;\n            return \"top\" === e || \"bottom\" === e || \"x\" === t;\n        }\n        isFullSize() {\n            return this.options.fullSize;\n        }\n        _convertTicksToLabels(t) {\n            let e, i;\n            for(this.beforeTickToLabelConversion(), this.generateTickLabels(t), e = 0, i = t.length; e < i; e++)s(t[e].label) && (t.splice(e, 1), i--, e--);\n            this.afterTickToLabelConversion();\n        }\n        _getLabelSizes() {\n            let t = this._labelSizes;\n            if (!t) {\n                const e = this.options.ticks.sampleSize;\n                let i = this.ticks;\n                e < i.length && (i = Xs(i, e)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);\n            }\n            return t;\n        }\n        _computeLabelSizes(t, e, i) {\n            const { ctx: o, _longestTextCache: a } = this, r = [], l = [], h = Math.floor(e / Us(e, i));\n            let c, d, f, g, p, m, b, x, _, y, v, M = 0, w = 0;\n            for(c = 0; c < e; c += h){\n                if (g = t[c].label, p = this._resolveTickFontOptions(c), o.font = m = p.string, b = a[m] = a[m] || {\n                    data: {},\n                    gc: []\n                }, x = p.lineHeight, _ = y = 0, s(g) || n(g)) {\n                    if (n(g)) for(d = 0, f = g.length; d < f; ++d)v = g[d], s(v) || n(v) || (_ = Ce(o, b.data, b.gc, _, v), y += x);\n                } else _ = Ce(o, b.data, b.gc, _, g), y = x;\n                r.push(_), l.push(y), M = Math.max(_, M), w = Math.max(y, w);\n            }\n            !function(t, e) {\n                u(t, (t)=>{\n                    const i = t.gc, s = i.length / 2;\n                    let n;\n                    if (s > e) {\n                        for(n = 0; n < s; ++n)delete t.data[i[n]];\n                        i.splice(0, s);\n                    }\n                });\n            }(a, e);\n            const k = r.indexOf(M), S = l.indexOf(w), P = (t)=>({\n                    width: r[t] || 0,\n                    height: l[t] || 0\n                });\n            return {\n                first: P(0),\n                last: P(e - 1),\n                widest: P(k),\n                highest: P(S),\n                widths: r,\n                heights: l\n            };\n        }\n        getLabelForValue(t) {\n            return t;\n        }\n        getPixelForValue(t, e) {\n            return NaN;\n        }\n        getValueForPixel(t) {}\n        getPixelForTick(t) {\n            const e = this.ticks;\n            return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n        }\n        getPixelForDecimal(t) {\n            this._reversePixels && (t = 1 - t);\n            const e = this._startPixel + t * this._length;\n            return Q(this._alignToPixels ? Ae(this.chart, e, 0) : e);\n        }\n        getDecimalForPixel(t) {\n            const e = (t - this._startPixel) / this._length;\n            return this._reversePixels ? 1 - e : e;\n        }\n        getBasePixel() {\n            return this.getPixelForValue(this.getBaseValue());\n        }\n        getBaseValue() {\n            const { min: t, max: e } = this;\n            return t < 0 && e < 0 ? e : t > 0 && e > 0 ? t : 0;\n        }\n        getContext(t) {\n            const e = this.ticks || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return i.$context || (i.$context = function(t, e, i) {\n                    return Ci(t, {\n                        tick: i,\n                        index: e,\n                        type: \"tick\"\n                    });\n                }(this.getContext(), t, i));\n            }\n            return this.$context || (this.$context = Ci(this.chart.getContext(), {\n                scale: this,\n                type: \"scale\"\n            }));\n        }\n        _tickSize() {\n            const t = this.options.ticks, e = $(this.labelRotation), i = Math.abs(Math.cos(e)), s = Math.abs(Math.sin(e)), n = this._getLabelSizes(), o = t.autoSkipPadding || 0, a = n ? n.widest.width + o : 0, r = n ? n.highest.height + o : 0;\n            return this.isHorizontal() ? r * i > a * s ? a / i : r / s : r * s < a * i ? r / i : a / s;\n        }\n        _isVisible() {\n            const t = this.options.display;\n            return \"auto\" !== t ? !!t : this.getMatchingVisibleMetas().length > 0;\n        }\n        _computeGridLineItems(t) {\n            const e = this.axis, i = this.chart, s = this.options, { grid: n, position: a, border: r } = s, h = n.offset, c = this.isHorizontal(), d = this.ticks.length + (h ? 1 : 0), u = Ks(n), f = [], g = r.setContext(this.getContext()), p = g.display ? g.width : 0, m = p / 2, b = function(t) {\n                return Ae(i, t, p);\n            };\n            let x, _, y, v, M, w, k, S, P, D, C, O;\n            if (\"top\" === a) x = b(this.bottom), w = this.bottom - u, S = x - m, D = b(t.top) + m, O = t.bottom;\n            else if (\"bottom\" === a) x = b(this.top), D = t.top, O = b(t.bottom) - m, w = x + m, S = this.top + u;\n            else if (\"left\" === a) x = b(this.right), M = this.right - u, k = x - m, P = b(t.left) + m, C = t.right;\n            else if (\"right\" === a) x = b(this.left), P = t.left, C = b(t.right) - m, M = x + m, k = this.left + u;\n            else if (\"x\" === e) {\n                if (\"center\" === a) x = b((t.top + t.bottom) / 2 + .5);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    x = b(this.chart.scales[t].getPixelForValue(e));\n                }\n                D = t.top, O = t.bottom, w = x + m, S = w + u;\n            } else if (\"y\" === e) {\n                if (\"center\" === a) x = b((t.left + t.right) / 2);\n                else if (o(a)) {\n                    const t = Object.keys(a)[0], e = a[t];\n                    x = b(this.chart.scales[t].getPixelForValue(e));\n                }\n                M = x - m, k = M - u, P = t.left, C = t.right;\n            }\n            const A = l(s.ticks.maxTicksLimit, d), T = Math.max(1, Math.ceil(d / A));\n            for(_ = 0; _ < d; _ += T){\n                const t = this.getContext(_), e = n.setContext(t), s = r.setContext(t), o = e.lineWidth, a = e.color, l = s.dash || [], d = s.dashOffset, u = e.tickWidth, g = e.tickColor, p = e.tickBorderDash || [], m = e.tickBorderDashOffset;\n                y = qs(this, _, h), void 0 !== y && (v = Ae(i, y, o), c ? M = k = P = C = v : w = S = D = O = v, f.push({\n                    tx1: M,\n                    ty1: w,\n                    tx2: k,\n                    ty2: S,\n                    x1: P,\n                    y1: D,\n                    x2: C,\n                    y2: O,\n                    width: o,\n                    color: a,\n                    borderDash: l,\n                    borderDashOffset: d,\n                    tickWidth: u,\n                    tickColor: g,\n                    tickBorderDash: p,\n                    tickBorderDashOffset: m\n                }));\n            }\n            return this._ticksLength = d, this._borderValue = x, f;\n        }\n        _computeLabelItems(t) {\n            const e = this.axis, i = this.options, { position: s, ticks: a } = i, r = this.isHorizontal(), l = this.ticks, { align: h, crossAlign: c, padding: d, mirror: u } = a, f = Ks(i.grid), g = f + d, p = u ? -d : g, m = -$(this.labelRotation), b = [];\n            let x, _, y, v, M, w, k, S, P, D, C, O, A = \"middle\";\n            if (\"top\" === s) w = this.bottom - p, k = this._getXAxisLabelAlignment();\n            else if (\"bottom\" === s) w = this.top + p, k = this._getXAxisLabelAlignment();\n            else if (\"left\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"right\" === s) {\n                const t = this._getYAxisLabelAlignment(f);\n                k = t.textAlign, M = t.x;\n            } else if (\"x\" === e) {\n                if (\"center\" === s) w = (t.top + t.bottom) / 2 + g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    w = this.chart.scales[t].getPixelForValue(e) + g;\n                }\n                k = this._getXAxisLabelAlignment();\n            } else if (\"y\" === e) {\n                if (\"center\" === s) M = (t.left + t.right) / 2 - g;\n                else if (o(s)) {\n                    const t = Object.keys(s)[0], e = s[t];\n                    M = this.chart.scales[t].getPixelForValue(e);\n                }\n                k = this._getYAxisLabelAlignment(f).textAlign;\n            }\n            \"y\" === e && (\"start\" === h ? A = \"top\" : \"end\" === h && (A = \"bottom\"));\n            const T = this._getLabelSizes();\n            for(x = 0, _ = l.length; x < _; ++x){\n                y = l[x], v = y.label;\n                const t = a.setContext(this.getContext(x));\n                S = this.getPixelForTick(x) + a.labelOffset, P = this._resolveTickFontOptions(x), D = P.lineHeight, C = n(v) ? v.length : 1;\n                const e = C / 2, i = t.color, o = t.textStrokeColor, h = t.textStrokeWidth;\n                let d, f = k;\n                if (r ? (M = S, \"inner\" === k && (f = x === _ - 1 ? this.options.reverse ? \"left\" : \"right\" : 0 === x ? this.options.reverse ? \"right\" : \"left\" : \"center\"), O = \"top\" === s ? \"near\" === c || 0 !== m ? -C * D + D / 2 : \"center\" === c ? -T.highest.height / 2 - e * D + D : -T.highest.height + D / 2 : \"near\" === c || 0 !== m ? D / 2 : \"center\" === c ? T.highest.height / 2 - e * D : T.highest.height - C * D, u && (O *= -1), 0 === m || t.showLabelBackdrop || (M += D / 2 * Math.sin(m))) : (w = S, O = (1 - C) * D / 2), t.showLabelBackdrop) {\n                    const e = ki(t.backdropPadding), i = T.heights[x], s = T.widths[x];\n                    let n = O - e.top, o = 0 - e.left;\n                    switch(A){\n                        case \"middle\":\n                            n -= i / 2;\n                            break;\n                        case \"bottom\":\n                            n -= i;\n                    }\n                    switch(k){\n                        case \"center\":\n                            o -= s / 2;\n                            break;\n                        case \"right\":\n                            o -= s;\n                            break;\n                        case \"inner\":\n                            x === _ - 1 ? o -= s : x > 0 && (o -= s / 2);\n                    }\n                    d = {\n                        left: o,\n                        top: n,\n                        width: s + e.width,\n                        height: i + e.height,\n                        color: t.backdropColor\n                    };\n                }\n                b.push({\n                    label: v,\n                    font: P,\n                    textOffset: O,\n                    options: {\n                        rotation: m,\n                        color: i,\n                        strokeColor: o,\n                        strokeWidth: h,\n                        textAlign: f,\n                        textBaseline: A,\n                        translation: [\n                            M,\n                            w\n                        ],\n                        backdrop: d\n                    }\n                });\n            }\n            return b;\n        }\n        _getXAxisLabelAlignment() {\n            const { position: t, ticks: e } = this.options;\n            if (-$(this.labelRotation)) return \"top\" === t ? \"left\" : \"right\";\n            let i = \"center\";\n            return \"start\" === e.align ? i = \"left\" : \"end\" === e.align ? i = \"right\" : \"inner\" === e.align && (i = \"inner\"), i;\n        }\n        _getYAxisLabelAlignment(t) {\n            const { position: e, ticks: { crossAlign: i, mirror: s, padding: n } } = this.options, o = t + n, a = this._getLabelSizes().widest.width;\n            let r, l;\n            return \"left\" === e ? s ? (l = this.right + n, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l += a)) : (l = this.right - o, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l = this.left)) : \"right\" === e ? s ? (l = this.left + n, \"near\" === i ? r = \"right\" : \"center\" === i ? (r = \"center\", l -= a / 2) : (r = \"left\", l -= a)) : (l = this.left + o, \"near\" === i ? r = \"left\" : \"center\" === i ? (r = \"center\", l += a / 2) : (r = \"right\", l = this.right)) : r = \"right\", {\n                textAlign: r,\n                x: l\n            };\n        }\n        _computeLabelArea() {\n            if (this.options.ticks.mirror) return;\n            const t = this.chart, e = this.options.position;\n            return \"left\" === e || \"right\" === e ? {\n                top: 0,\n                left: this.left,\n                bottom: t.height,\n                right: this.right\n            } : \"top\" === e || \"bottom\" === e ? {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: t.width\n            } : void 0;\n        }\n        drawBackground() {\n            const { ctx: t, options: { backgroundColor: e }, left: i, top: s, width: n, height: o } = this;\n            e && (t.save(), t.fillStyle = e, t.fillRect(i, s, n, o), t.restore());\n        }\n        getLineWidthForValue(t) {\n            const e = this.options.grid;\n            if (!this._isVisible() || !e.display) return 0;\n            const i = this.ticks.findIndex((e)=>e.value === t);\n            if (i >= 0) return e.setContext(this.getContext(i)).lineWidth;\n            return 0;\n        }\n        drawGrid(t) {\n            const e = this.options.grid, i = this.ctx, s = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));\n            let n, o;\n            const a = (t, e, s)=>{\n                s.width && s.color && (i.save(), i.lineWidth = s.width, i.strokeStyle = s.color, i.setLineDash(s.borderDash || []), i.lineDashOffset = s.borderDashOffset, i.beginPath(), i.moveTo(t.x, t.y), i.lineTo(e.x, e.y), i.stroke(), i.restore());\n            };\n            if (e.display) for(n = 0, o = s.length; n < o; ++n){\n                const t = s[n];\n                e.drawOnChartArea && a({\n                    x: t.x1,\n                    y: t.y1\n                }, {\n                    x: t.x2,\n                    y: t.y2\n                }, t), e.drawTicks && a({\n                    x: t.tx1,\n                    y: t.ty1\n                }, {\n                    x: t.tx2,\n                    y: t.ty2\n                }, {\n                    color: t.tickColor,\n                    width: t.tickWidth,\n                    borderDash: t.tickBorderDash,\n                    borderDashOffset: t.tickBorderDashOffset\n                });\n            }\n        }\n        drawBorder() {\n            const { chart: t, ctx: e, options: { border: i, grid: s } } = this, n = i.setContext(this.getContext()), o = i.display ? n.width : 0;\n            if (!o) return;\n            const a = s.setContext(this.getContext(0)).lineWidth, r = this._borderValue;\n            let l, h, c, d;\n            this.isHorizontal() ? (l = Ae(t, this.left, o) - o / 2, h = Ae(t, this.right, a) + a / 2, c = d = r) : (c = Ae(t, this.top, o) - o / 2, d = Ae(t, this.bottom, a) + a / 2, l = h = r), e.save(), e.lineWidth = n.width, e.strokeStyle = n.color, e.beginPath(), e.moveTo(l, c), e.lineTo(h, d), e.stroke(), e.restore();\n        }\n        drawLabels(t) {\n            if (!this.options.ticks.display) return;\n            const e = this.ctx, i = this._computeLabelArea();\n            i && Ie(e, i);\n            const s = this.getLabelItems(t);\n            for (const t of s){\n                const i = t.options, s = t.font;\n                Ne(e, t.label, 0, t.textOffset, s, i);\n            }\n            i && ze(e);\n        }\n        drawTitle() {\n            const { ctx: t, options: { position: e, title: i, reverse: s } } = this;\n            if (!i.display) return;\n            const a = Si(i.font), r = ki(i.padding), l = i.align;\n            let h = a.lineHeight / 2;\n            \"bottom\" === e || \"center\" === e || o(e) ? (h += r.bottom, n(i.text) && (h += a.lineHeight * (i.text.length - 1))) : h += r.top;\n            const { titleX: c, titleY: d, maxWidth: u, rotation: f } = function(t, e, i, s) {\n                const { top: n, left: a, bottom: r, right: l, chart: h } = t, { chartArea: c, scales: d } = h;\n                let u, f, g, p = 0;\n                const m = r - n, b = l - a;\n                if (t.isHorizontal()) {\n                    if (f = ft(s, a, l), o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        g = d[t].getPixelForValue(s) + m - e;\n                    } else g = \"center\" === i ? (c.bottom + c.top) / 2 + m - e : Ys(t, i, e);\n                    u = l - a;\n                } else {\n                    if (o(i)) {\n                        const t = Object.keys(i)[0], s = i[t];\n                        f = d[t].getPixelForValue(s) - b + e;\n                    } else f = \"center\" === i ? (c.left + c.right) / 2 - b + e : Ys(t, i, e);\n                    g = ft(s, r, n), p = \"left\" === i ? -E : E;\n                }\n                return {\n                    titleX: f,\n                    titleY: g,\n                    maxWidth: u,\n                    rotation: p\n                };\n            }(this, h, e, l);\n            Ne(t, i.text, 0, 0, a, {\n                color: i.color,\n                maxWidth: u,\n                rotation: f,\n                textAlign: Zs(l, e, s),\n                textBaseline: \"middle\",\n                translation: [\n                    c,\n                    d\n                ]\n            });\n        }\n        draw(t) {\n            this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));\n        }\n        _layers() {\n            const t = this.options, e = t.ticks && t.ticks.z || 0, i = l(t.grid && t.grid.z, -1), s = l(t.border && t.border.z, 0);\n            return this._isVisible() && this.draw === Js.prototype.draw ? [\n                {\n                    z: i,\n                    draw: (t)=>{\n                        this.drawBackground(), this.drawGrid(t), this.drawTitle();\n                    }\n                },\n                {\n                    z: s,\n                    draw: ()=>{\n                        this.drawBorder();\n                    }\n                },\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.drawLabels(t);\n                    }\n                }\n            ] : [\n                {\n                    z: e,\n                    draw: (t)=>{\n                        this.draw(t);\n                    }\n                }\n            ];\n        }\n        getMatchingVisibleMetas(t) {\n            const e = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + \"AxisID\", s = [];\n            let n, o;\n            for(n = 0, o = e.length; n < o; ++n){\n                const o = e[n];\n                o[i] !== this.id || t && o.type !== t || s.push(o);\n            }\n            return s;\n        }\n        _resolveTickFontOptions(t) {\n            return Si(this.options.ticks.setContext(this.getContext(t)).font);\n        }\n        _maxDigits() {\n            const t = this._resolveTickFontOptions(0).lineHeight;\n            return (this.isHorizontal() ? this.width : this.height) / t;\n        }\n    }\n    class Qs {\n        constructor(t, e, i){\n            this.type = t, this.scope = e, this.override = i, this.items = Object.create(null);\n        }\n        isForType(t) {\n            return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);\n        }\n        register(t) {\n            const e = Object.getPrototypeOf(t);\n            let i;\n            (function(t) {\n                return \"id\" in t && \"defaults\" in t;\n            })(e) && (i = this.register(e));\n            const s = this.items, n = t.id, o = this.scope + \".\" + n;\n            if (!n) throw new Error(\"class does not have id: \" + t);\n            return n in s || (s[n] = t, function(t, e, i) {\n                const s = b(Object.create(null), [\n                    i ? ue.get(i) : {},\n                    ue.get(e),\n                    t.defaults\n                ]);\n                ue.set(e, s), t.defaultRoutes && function(t, e) {\n                    Object.keys(e).forEach((i)=>{\n                        const s = i.split(\".\"), n = s.pop(), o = [\n                            t\n                        ].concat(s).join(\".\"), a = e[i].split(\".\"), r = a.pop(), l = a.join(\".\");\n                        ue.route(o, n, l, r);\n                    });\n                }(e, t.defaultRoutes);\n                t.descriptors && ue.describe(e, t.descriptors);\n            }(t, o, i), this.override && ue.override(t.id, t.overrides)), o;\n        }\n        get(t) {\n            return this.items[t];\n        }\n        unregister(t) {\n            const e = this.items, i = t.id, s = this.scope;\n            i in e && delete e[i], s && i in ue[s] && (delete ue[s][i], this.override && delete re[i]);\n        }\n    }\n    class tn {\n        constructor(){\n            this.controllers = new Qs(Ns, \"datasets\", !0), this.elements = new Qs(Hs, \"elements\"), this.plugins = new Qs(Object, \"plugins\"), this.scales = new Qs(Js, \"scales\"), this._typedRegistries = [\n                this.controllers,\n                this.scales,\n                this.elements\n            ];\n        }\n        add(...t) {\n            this._each(\"register\", t);\n        }\n        remove(...t) {\n            this._each(\"unregister\", t);\n        }\n        addControllers(...t) {\n            this._each(\"register\", t, this.controllers);\n        }\n        addElements(...t) {\n            this._each(\"register\", t, this.elements);\n        }\n        addPlugins(...t) {\n            this._each(\"register\", t, this.plugins);\n        }\n        addScales(...t) {\n            this._each(\"register\", t, this.scales);\n        }\n        getController(t) {\n            return this._get(t, this.controllers, \"controller\");\n        }\n        getElement(t) {\n            return this._get(t, this.elements, \"element\");\n        }\n        getPlugin(t) {\n            return this._get(t, this.plugins, \"plugin\");\n        }\n        getScale(t) {\n            return this._get(t, this.scales, \"scale\");\n        }\n        removeControllers(...t) {\n            this._each(\"unregister\", t, this.controllers);\n        }\n        removeElements(...t) {\n            this._each(\"unregister\", t, this.elements);\n        }\n        removePlugins(...t) {\n            this._each(\"unregister\", t, this.plugins);\n        }\n        removeScales(...t) {\n            this._each(\"unregister\", t, this.scales);\n        }\n        _each(t, e, i) {\n            [\n                ...e\n            ].forEach((e)=>{\n                const s = i || this._getRegistryForType(e);\n                i || s.isForType(e) || s === this.plugins && e.id ? this._exec(t, s, e) : u(e, (e)=>{\n                    const s = i || this._getRegistryForType(e);\n                    this._exec(t, s, e);\n                });\n            });\n        }\n        _exec(t, e, i) {\n            const s = w(t);\n            d(i[\"before\" + s], [], i), e[t](i), d(i[\"after\" + s], [], i);\n        }\n        _getRegistryForType(t) {\n            for(let e = 0; e < this._typedRegistries.length; e++){\n                const i = this._typedRegistries[e];\n                if (i.isForType(t)) return i;\n            }\n            return this.plugins;\n        }\n        _get(t, e, i) {\n            const s = e.get(t);\n            if (void 0 === s) throw new Error('\"' + t + '\" is not a registered ' + i + \".\");\n            return s;\n        }\n    }\n    var en = new tn;\n    class sn {\n        constructor(){\n            this._init = [];\n        }\n        notify(t, e, i, s) {\n            \"beforeInit\" === e && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, \"install\"));\n            const n = s ? this._descriptors(t).filter(s) : this._descriptors(t), o = this._notify(n, t, e, i);\n            return \"afterDestroy\" === e && (this._notify(n, t, \"stop\"), this._notify(this._init, t, \"uninstall\")), o;\n        }\n        _notify(t, e, i, s) {\n            s = s || {};\n            for (const n of t){\n                const t = n.plugin;\n                if (!1 === d(t[i], [\n                    e,\n                    s,\n                    n.options\n                ], t) && s.cancelable) return !1;\n            }\n            return !0;\n        }\n        invalidate() {\n            s(this._cache) || (this._oldCache = this._cache, this._cache = void 0);\n        }\n        _descriptors(t) {\n            if (this._cache) return this._cache;\n            const e = this._cache = this._createDescriptors(t);\n            return this._notifyStateChanges(t), e;\n        }\n        _createDescriptors(t, e) {\n            const i = t && t.config, s = l(i.options && i.options.plugins, {}), n = function(t) {\n                const e = {}, i = [], s = Object.keys(en.plugins.items);\n                for(let t = 0; t < s.length; t++)i.push(en.getPlugin(s[t]));\n                const n = t.plugins || [];\n                for(let t = 0; t < n.length; t++){\n                    const s = n[t];\n                    -1 === i.indexOf(s) && (i.push(s), e[s.id] = !0);\n                }\n                return {\n                    plugins: i,\n                    localIds: e\n                };\n            }(i);\n            return !1 !== s || e ? function(t, { plugins: e, localIds: i }, s, n) {\n                const o = [], a = t.getContext();\n                for (const r of e){\n                    const e = r.id, l = nn(s[e], n);\n                    null !== l && o.push({\n                        plugin: r,\n                        options: on(t.config, {\n                            plugin: r,\n                            local: i[e]\n                        }, l, a)\n                    });\n                }\n                return o;\n            }(t, n, s, e) : [];\n        }\n        _notifyStateChanges(t) {\n            const e = this._oldCache || [], i = this._cache, s = (t, e)=>t.filter((t)=>!e.some((e)=>t.plugin.id === e.plugin.id));\n            this._notify(s(e, i), t, \"stop\"), this._notify(s(i, e), t, \"start\");\n        }\n    }\n    function nn(t, e) {\n        return e || !1 !== t ? !0 === t ? {} : t : null;\n    }\n    function on(t, { plugin: e, local: i }, s, n) {\n        const o = t.pluginScopeKeys(e), a = t.getOptionScopes(s, o);\n        return i && e.defaults && a.push(e.defaults), t.createResolver(a, n, [\n            \"\"\n        ], {\n            scriptable: !1,\n            indexable: !1,\n            allKeys: !0\n        });\n    }\n    function an(t, e) {\n        const i = ue.datasets[t] || {};\n        return ((e.datasets || {})[t] || {}).indexAxis || e.indexAxis || i.indexAxis || \"x\";\n    }\n    function rn(t) {\n        if (\"x\" === t || \"y\" === t || \"r\" === t) return t;\n    }\n    function ln(t, ...e) {\n        if (rn(t)) return t;\n        for (const s of e){\n            const e = s.axis || (\"top\" === (i = s.position) || \"bottom\" === i ? \"x\" : \"left\" === i || \"right\" === i ? \"y\" : void 0) || t.length > 1 && rn(t[0].toLowerCase());\n            if (e) return e;\n        }\n        var i;\n        throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`);\n    }\n    function hn(t, e, i) {\n        if (i[e + \"AxisID\"] === t) return {\n            axis: e\n        };\n    }\n    function cn(t, e) {\n        const i = re[t.type] || {\n            scales: {}\n        }, s = e.scales || {}, n = an(t.type, e), a = Object.create(null);\n        return Object.keys(s).forEach((e)=>{\n            const r = s[e];\n            if (!o(r)) return console.error(`Invalid scale configuration for scale: ${e}`);\n            if (r._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${e}`);\n            const l = ln(e, r, function(t, e) {\n                if (e.data && e.data.datasets) {\n                    const i = e.data.datasets.filter((e)=>e.xAxisID === t || e.yAxisID === t);\n                    if (i.length) return hn(t, \"x\", i[0]) || hn(t, \"y\", i[0]);\n                }\n                return {};\n            }(e, t), ue.scales[r.type]), h = function(t, e) {\n                return t === e ? \"_index_\" : \"_value_\";\n            }(l, n), c = i.scales || {};\n            a[e] = x(Object.create(null), [\n                {\n                    axis: l\n                },\n                r,\n                c[l],\n                c[h]\n            ]);\n        }), t.data.datasets.forEach((i)=>{\n            const n = i.type || t.type, o = i.indexAxis || an(n, e), r = (re[n] || {}).scales || {};\n            Object.keys(r).forEach((t)=>{\n                const e = function(t, e) {\n                    let i = t;\n                    return \"_index_\" === t ? i = e : \"_value_\" === t && (i = \"x\" === e ? \"y\" : \"x\"), i;\n                }(t, o), n = i[e + \"AxisID\"] || e;\n                a[n] = a[n] || Object.create(null), x(a[n], [\n                    {\n                        axis: e\n                    },\n                    s[n],\n                    r[t]\n                ]);\n            });\n        }), Object.keys(a).forEach((t)=>{\n            const e = a[t];\n            x(e, [\n                ue.scales[e.type],\n                ue.scale\n            ]);\n        }), a;\n    }\n    function dn(t) {\n        const e = t.options || (t.options = {});\n        e.plugins = l(e.plugins, {}), e.scales = cn(t, e);\n    }\n    function un(t) {\n        return (t = t || {}).datasets = t.datasets || [], t.labels = t.labels || [], t;\n    }\n    const fn = new Map, gn = new Set;\n    function pn(t, e) {\n        let i = fn.get(t);\n        return i || (i = e(), fn.set(t, i), gn.add(i)), i;\n    }\n    const mn = (t, e, i)=>{\n        const s = M(e, i);\n        void 0 !== s && t.add(s);\n    };\n    class bn {\n        constructor(t){\n            this._config = function(t) {\n                return (t = t || {}).data = un(t.data), dn(t), t;\n            }(t), this._scopeCache = new Map, this._resolverCache = new Map;\n        }\n        get platform() {\n            return this._config.platform;\n        }\n        get type() {\n            return this._config.type;\n        }\n        set type(t) {\n            this._config.type = t;\n        }\n        get data() {\n            return this._config.data;\n        }\n        set data(t) {\n            this._config.data = un(t);\n        }\n        get options() {\n            return this._config.options;\n        }\n        set options(t) {\n            this._config.options = t;\n        }\n        get plugins() {\n            return this._config.plugins;\n        }\n        update() {\n            const t = this._config;\n            this.clearCache(), dn(t);\n        }\n        clearCache() {\n            this._scopeCache.clear(), this._resolverCache.clear();\n        }\n        datasetScopeKeys(t) {\n            return pn(t, ()=>[\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetAnimationScopeKeys(t, e) {\n            return pn(`${t}.transition.${e}`, ()=>[\n                    [\n                        `datasets.${t}.transitions.${e}`,\n                        `transitions.${e}`\n                    ],\n                    [\n                        `datasets.${t}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        datasetElementScopeKeys(t, e) {\n            return pn(`${t}-${e}`, ()=>[\n                    [\n                        `datasets.${t}.elements.${e}`,\n                        `datasets.${t}`,\n                        `elements.${e}`,\n                        \"\"\n                    ]\n                ]);\n        }\n        pluginScopeKeys(t) {\n            const e = t.id;\n            return pn(`${this.type}-plugin-${e}`, ()=>[\n                    [\n                        `plugins.${e}`,\n                        ...t.additionalOptionScopes || []\n                    ]\n                ]);\n        }\n        _cachedScopes(t, e) {\n            const i = this._scopeCache;\n            let s = i.get(t);\n            return s && !e || (s = new Map, i.set(t, s)), s;\n        }\n        getOptionScopes(t, e, i) {\n            const { options: s, type: n } = this, o = this._cachedScopes(t, i), a = o.get(e);\n            if (a) return a;\n            const r = new Set;\n            e.forEach((e)=>{\n                t && (r.add(t), e.forEach((e)=>mn(r, t, e))), e.forEach((t)=>mn(r, s, t)), e.forEach((t)=>mn(r, re[n] || {}, t)), e.forEach((t)=>mn(r, ue, t)), e.forEach((t)=>mn(r, le, t));\n            });\n            const l = Array.from(r);\n            return 0 === l.length && l.push(Object.create(null)), gn.has(e) && o.set(e, l), l;\n        }\n        chartOptionScopes() {\n            const { options: t, type: e } = this;\n            return [\n                t,\n                re[e] || {},\n                ue.datasets[e] || {},\n                {\n                    type: e\n                },\n                ue,\n                le\n            ];\n        }\n        resolveNamedOptions(t, e, i, s = [\n            \"\"\n        ]) {\n            const o = {\n                $shared: !0\n            }, { resolver: a, subPrefixes: r } = xn(this._resolverCache, t, s);\n            let l = a;\n            if (function(t, e) {\n                const { isScriptable: i, isIndexable: s } = Ye(t);\n                for (const o of e){\n                    const e = i(o), a = s(o), r = (a || e) && t[o];\n                    if (e && (S(r) || _n(r)) || a && n(r)) return !0;\n                }\n                return !1;\n            }(a, e)) {\n                o.$shared = !1;\n                l = $e(a, i = S(i) ? i() : i, this.createResolver(t, i, r));\n            }\n            for (const t of e)o[t] = l[t];\n            return o;\n        }\n        createResolver(t, e, i = [\n            \"\"\n        ], s) {\n            const { resolver: n } = xn(this._resolverCache, t, i);\n            return o(e) ? $e(n, e, void 0, s) : n;\n        }\n    }\n    function xn(t, e, i) {\n        let s = t.get(e);\n        s || (s = new Map, t.set(e, s));\n        const n = i.join();\n        let o = s.get(n);\n        if (!o) o = {\n            resolver: je(e, i),\n            subPrefixes: i.filter((t)=>!t.toLowerCase().includes(\"hover\"))\n        }, s.set(n, o);\n        return o;\n    }\n    const _n = (t)=>o(t) && Object.getOwnPropertyNames(t).some((e)=>S(t[e]));\n    const yn = [\n        \"top\",\n        \"bottom\",\n        \"left\",\n        \"right\",\n        \"chartArea\"\n    ];\n    function vn(t, e) {\n        return \"top\" === t || \"bottom\" === t || -1 === yn.indexOf(t) && \"x\" === e;\n    }\n    function Mn(t, e) {\n        return function(i, s) {\n            return i[t] === s[t] ? i[e] - s[e] : i[t] - s[t];\n        };\n    }\n    function wn(t) {\n        const e = t.chart, i = e.options.animation;\n        e.notifyPlugins(\"afterRender\"), d(i && i.onComplete, [\n            t\n        ], e);\n    }\n    function kn(t) {\n        const e = t.chart, i = e.options.animation;\n        d(i && i.onProgress, [\n            t\n        ], e);\n    }\n    function Sn(t) {\n        return fe() && \"string\" == typeof t ? t = document.getElementById(t) : t && t.length && (t = t[0]), t && t.canvas && (t = t.canvas), t;\n    }\n    const Pn = {}, Dn = (t)=>{\n        const e = Sn(t);\n        return Object.values(Pn).filter((t)=>t.canvas === e).pop();\n    };\n    function Cn(t, e, i) {\n        const s = Object.keys(t);\n        for (const n of s){\n            const s = +n;\n            if (s >= e) {\n                const o = t[n];\n                delete t[n], (i > 0 || s > e) && (t[s + i] = o);\n            }\n        }\n    }\n    function On(t, e, i) {\n        return t.options.clip ? t[i] : e[i];\n    }\n    class An {\n        static defaults = ue;\n        static instances = Pn;\n        static overrides = re;\n        static registry = en;\n        static version = \"4.4.1\";\n        static getChart = Dn;\n        static register(...t) {\n            en.add(...t), Tn();\n        }\n        static unregister(...t) {\n            en.remove(...t), Tn();\n        }\n        constructor(t, e){\n            const s = this.config = new bn(e), n = Sn(t), o = Dn(n);\n            if (o) throw new Error(\"Canvas is already in use. Chart with ID '\" + o.id + \"' must be destroyed before the canvas with ID '\" + o.canvas.id + \"' can be reused.\");\n            const a = s.createResolver(s.chartOptionScopes(), this.getContext());\n            this.platform = new (s.platform || ks(n)), this.platform.updateConfig(s);\n            const r = this.platform.acquireContext(n, a.aspectRatio), l = r && r.canvas, h = l && l.height, c = l && l.width;\n            this.id = i(), this.ctx = r, this.canvas = l, this.width = c, this.height = h, this._options = a, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sn, this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = dt((t)=>this.update(t), a.resizeDelay || 0), this._dataChanges = [], Pn[this.id] = this, r && l ? (xt.listen(this, \"complete\", wn), xt.listen(this, \"progress\", kn), this._initialize(), this.attached && this.update()) : console.error(\"Failed to create chart: can't acquire context from the given item\");\n        }\n        get aspectRatio() {\n            const { options: { aspectRatio: t, maintainAspectRatio: e }, width: i, height: n, _aspectRatio: o } = this;\n            return s(t) ? e && o ? o : n ? i / n : null : t;\n        }\n        get data() {\n            return this.config.data;\n        }\n        set data(t) {\n            this.config.data = t;\n        }\n        get options() {\n            return this._options;\n        }\n        set options(t) {\n            this.config.options = t;\n        }\n        get registry() {\n            return en;\n        }\n        _initialize() {\n            return this.notifyPlugins(\"beforeInit\"), this.options.responsive ? this.resize() : ke(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins(\"afterInit\"), this;\n        }\n        clear() {\n            return Te(this.canvas, this.ctx), this;\n        }\n        stop() {\n            return xt.stop(this), this;\n        }\n        resize(t, e) {\n            xt.running(this) ? this._resizeBeforeDraw = {\n                width: t,\n                height: e\n            } : this._resize(t, e);\n        }\n        _resize(t, e) {\n            const i = this.options, s = this.canvas, n = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(s, t, e, n), a = i.devicePixelRatio || this.platform.getDevicePixelRatio(), r = this.width ? \"resize\" : \"attach\";\n            this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, ke(this, a, !0) && (this.notifyPlugins(\"resize\", {\n                size: o\n            }), d(i.onResize, [\n                this,\n                o\n            ], this), this.attached && this._doResize(r) && this.render());\n        }\n        ensureScalesHaveIDs() {\n            u(this.options.scales || {}, (t, e)=>{\n                t.id = e;\n            });\n        }\n        buildOrUpdateScales() {\n            const t = this.options, e = t.scales, i = this.scales, s = Object.keys(i).reduce((t, e)=>(t[e] = !1, t), {});\n            let n = [];\n            e && (n = n.concat(Object.keys(e).map((t)=>{\n                const i = e[t], s = ln(t, i), n = \"r\" === s, o = \"x\" === s;\n                return {\n                    options: i,\n                    dposition: n ? \"chartArea\" : o ? \"bottom\" : \"left\",\n                    dtype: n ? \"radialLinear\" : o ? \"category\" : \"linear\"\n                };\n            }))), u(n, (e)=>{\n                const n = e.options, o = n.id, a = ln(o, n), r = l(n.type, e.dtype);\n                void 0 !== n.position && vn(n.position, a) === vn(e.dposition) || (n.position = e.dposition), s[o] = !0;\n                let h = null;\n                if (o in i && i[o].type === r) h = i[o];\n                else h = new (en.getScale(r))({\n                    id: o,\n                    type: r,\n                    ctx: this.ctx,\n                    chart: this\n                }), i[h.id] = h;\n                h.init(n, t);\n            }), u(s, (t, e)=>{\n                t || delete i[e];\n            }), u(i, (t)=>{\n                as.configure(this, t, t.options), as.addBox(this, t);\n            });\n        }\n        _updateMetasets() {\n            const t = this._metasets, e = this.data.datasets.length, i = t.length;\n            if (t.sort((t, e)=>t.index - e.index), i > e) {\n                for(let t = e; t < i; ++t)this._destroyDatasetMeta(t);\n                t.splice(e, i - e);\n            }\n            this._sortedMetasets = t.slice(0).sort(Mn(\"order\", \"index\"));\n        }\n        _removeUnreferencedMetasets() {\n            const { _metasets: t, data: { datasets: e } } = this;\n            t.length > e.length && delete this._stacks, t.forEach((t, i)=>{\n                0 === e.filter((e)=>e === t._dataset).length && this._destroyDatasetMeta(i);\n            });\n        }\n        buildOrUpdateControllers() {\n            const t = [], e = this.data.datasets;\n            let i, s;\n            for(this._removeUnreferencedMetasets(), i = 0, s = e.length; i < s; i++){\n                const s = e[i];\n                let n = this.getDatasetMeta(i);\n                const o = s.type || this.config.type;\n                if (n.type && n.type !== o && (this._destroyDatasetMeta(i), n = this.getDatasetMeta(i)), n.type = o, n.indexAxis = s.indexAxis || an(o, this.options), n.order = s.order || 0, n.index = i, n.label = \"\" + s.label, n.visible = this.isDatasetVisible(i), n.controller) n.controller.updateIndex(i), n.controller.linkScales();\n                else {\n                    const e = en.getController(o), { datasetElementType: s, dataElementType: a } = ue.datasets[o];\n                    Object.assign(e, {\n                        dataElementType: en.getElement(a),\n                        datasetElementType: s && en.getElement(s)\n                    }), n.controller = new e(this, i), t.push(n.controller);\n                }\n            }\n            return this._updateMetasets(), t;\n        }\n        _resetElements() {\n            u(this.data.datasets, (t, e)=>{\n                this.getDatasetMeta(e).controller.reset();\n            }, this);\n        }\n        reset() {\n            this._resetElements(), this.notifyPlugins(\"reset\");\n        }\n        update(t) {\n            const e = this.config;\n            e.update();\n            const i = this._options = e.createResolver(e.chartOptionScopes(), this.getContext()), s = this._animationsDisabled = !i.animation;\n            if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), !1 === this.notifyPlugins(\"beforeUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) return;\n            const n = this.buildOrUpdateControllers();\n            this.notifyPlugins(\"beforeElementsUpdate\");\n            let o = 0;\n            for(let t = 0, e = this.data.datasets.length; t < e; t++){\n                const { controller: e } = this.getDatasetMeta(t), i = !s && -1 === n.indexOf(e);\n                e.buildOrUpdateElements(i), o = Math.max(+e.getMaxOverflow(), o);\n            }\n            o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), s || u(n, (t)=>{\n                t.reset();\n            }), this._updateDatasets(t), this.notifyPlugins(\"afterUpdate\", {\n                mode: t\n            }), this._layers.sort(Mn(\"z\", \"_idx\"));\n            const { _active: a, _lastEvent: r } = this;\n            r ? this._eventHandler(r, !0) : a.length && this._updateHoverStyles(a, a, !0), this.render();\n        }\n        _updateScales() {\n            u(this.scales, (t)=>{\n                as.removeBox(this, t);\n            }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();\n        }\n        _checkEventBindings() {\n            const t = this.options, e = new Set(Object.keys(this._listeners)), i = new Set(t.events);\n            P(e, i) && !!this._responsiveListeners === t.responsive || (this.unbindEvents(), this.bindEvents());\n        }\n        _updateHiddenIndices() {\n            const { _hiddenIndices: t } = this, e = this._getUniformDataChanges() || [];\n            for (const { method: i, start: s, count: n } of e)Cn(t, s, \"_removeElements\" === i ? -n : n);\n        }\n        _getUniformDataChanges() {\n            const t = this._dataChanges;\n            if (!t || !t.length) return;\n            this._dataChanges = [];\n            const e = this.data.datasets.length, i = (e)=>new Set(t.filter((t)=>t[0] === e).map((t, e)=>e + \",\" + t.splice(1).join(\",\"))), s = i(0);\n            for(let t = 1; t < e; t++)if (!P(s, i(t))) return;\n            return Array.from(s).map((t)=>t.split(\",\")).map((t)=>({\n                    method: t[1],\n                    start: +t[2],\n                    count: +t[3]\n                }));\n        }\n        _updateLayout(t) {\n            if (!1 === this.notifyPlugins(\"beforeLayout\", {\n                cancelable: !0\n            })) return;\n            as.update(this, this.width, this.height, t);\n            const e = this.chartArea, i = e.width <= 0 || e.height <= 0;\n            this._layers = [], u(this.boxes, (t)=>{\n                i && \"chartArea\" === t.position || (t.configure && t.configure(), this._layers.push(...t._layers()));\n            }, this), this._layers.forEach((t, e)=>{\n                t._idx = e;\n            }), this.notifyPlugins(\"afterLayout\");\n        }\n        _updateDatasets(t) {\n            if (!1 !== this.notifyPlugins(\"beforeDatasetsUpdate\", {\n                mode: t,\n                cancelable: !0\n            })) {\n                for(let t = 0, e = this.data.datasets.length; t < e; ++t)this.getDatasetMeta(t).controller.configure();\n                for(let e = 0, i = this.data.datasets.length; e < i; ++e)this._updateDataset(e, S(t) ? t({\n                    datasetIndex: e\n                }) : t);\n                this.notifyPlugins(\"afterDatasetsUpdate\", {\n                    mode: t\n                });\n            }\n        }\n        _updateDataset(t, e) {\n            const i = this.getDatasetMeta(t), s = {\n                meta: i,\n                index: t,\n                mode: e,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetUpdate\", s) && (i.controller._update(e), s.cancelable = !1, this.notifyPlugins(\"afterDatasetUpdate\", s));\n        }\n        render() {\n            !1 !== this.notifyPlugins(\"beforeRender\", {\n                cancelable: !0\n            }) && (xt.has(this) ? this.attached && !xt.running(this) && xt.start(this) : (this.draw(), wn({\n                chart: this\n            })));\n        }\n        draw() {\n            let t;\n            if (this._resizeBeforeDraw) {\n                const { width: t, height: e } = this._resizeBeforeDraw;\n                this._resize(t, e), this._resizeBeforeDraw = null;\n            }\n            if (this.clear(), this.width <= 0 || this.height <= 0) return;\n            if (!1 === this.notifyPlugins(\"beforeDraw\", {\n                cancelable: !0\n            })) return;\n            const e = this._layers;\n            for(t = 0; t < e.length && e[t].z <= 0; ++t)e[t].draw(this.chartArea);\n            for(this._drawDatasets(); t < e.length; ++t)e[t].draw(this.chartArea);\n            this.notifyPlugins(\"afterDraw\");\n        }\n        _getSortedDatasetMetas(t) {\n            const e = this._sortedMetasets, i = [];\n            let s, n;\n            for(s = 0, n = e.length; s < n; ++s){\n                const n = e[s];\n                t && !n.visible || i.push(n);\n            }\n            return i;\n        }\n        getSortedVisibleDatasetMetas() {\n            return this._getSortedDatasetMetas(!0);\n        }\n        _drawDatasets() {\n            if (!1 === this.notifyPlugins(\"beforeDatasetsDraw\", {\n                cancelable: !0\n            })) return;\n            const t = this.getSortedVisibleDatasetMetas();\n            for(let e = t.length - 1; e >= 0; --e)this._drawDataset(t[e]);\n            this.notifyPlugins(\"afterDatasetsDraw\");\n        }\n        _drawDataset(t) {\n            const e = this.ctx, i = t._clip, s = !i.disabled, n = function(t, e) {\n                const { xScale: i, yScale: s } = t;\n                return i && s ? {\n                    left: On(i, e, \"left\"),\n                    right: On(i, e, \"right\"),\n                    top: On(s, e, \"top\"),\n                    bottom: On(s, e, \"bottom\")\n                } : e;\n            }(t, this.chartArea), o = {\n                meta: t,\n                index: t.index,\n                cancelable: !0\n            };\n            !1 !== this.notifyPlugins(\"beforeDatasetDraw\", o) && (s && Ie(e, {\n                left: !1 === i.left ? 0 : n.left - i.left,\n                right: !1 === i.right ? this.width : n.right + i.right,\n                top: !1 === i.top ? 0 : n.top - i.top,\n                bottom: !1 === i.bottom ? this.height : n.bottom + i.bottom\n            }), t.controller.draw(), s && ze(e), o.cancelable = !1, this.notifyPlugins(\"afterDatasetDraw\", o));\n        }\n        isPointInArea(t) {\n            return Re(t, this.chartArea, this._minPadding);\n        }\n        getElementsAtEventForMode(t, e, i, s) {\n            const n = Xi.modes[e];\n            return \"function\" == typeof n ? n(this, t, i, s) : [];\n        }\n        getDatasetMeta(t) {\n            const e = this.data.datasets[t], i = this._metasets;\n            let s = i.filter((t)=>t && t._dataset === e).pop();\n            return s || (s = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: e && e.order || 0,\n                index: t,\n                _dataset: e,\n                _parsed: [],\n                _sorted: !1\n            }, i.push(s)), s;\n        }\n        getContext() {\n            return this.$context || (this.$context = Ci(null, {\n                chart: this,\n                type: \"chart\"\n            }));\n        }\n        getVisibleDatasetCount() {\n            return this.getSortedVisibleDatasetMetas().length;\n        }\n        isDatasetVisible(t) {\n            const e = this.data.datasets[t];\n            if (!e) return !1;\n            const i = this.getDatasetMeta(t);\n            return \"boolean\" == typeof i.hidden ? !i.hidden : !e.hidden;\n        }\n        setDatasetVisibility(t, e) {\n            this.getDatasetMeta(t).hidden = !e;\n        }\n        toggleDataVisibility(t) {\n            this._hiddenIndices[t] = !this._hiddenIndices[t];\n        }\n        getDataVisibility(t) {\n            return !this._hiddenIndices[t];\n        }\n        _updateVisibility(t, e, i) {\n            const s = i ? \"show\" : \"hide\", n = this.getDatasetMeta(t), o = n.controller._resolveAnimations(void 0, s);\n            k(e) ? (n.data[e].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(n, {\n                visible: i\n            }), this.update((e)=>e.datasetIndex === t ? s : void 0));\n        }\n        hide(t, e) {\n            this._updateVisibility(t, e, !1);\n        }\n        show(t, e) {\n            this._updateVisibility(t, e, !0);\n        }\n        _destroyDatasetMeta(t) {\n            const e = this._metasets[t];\n            e && e.controller && e.controller._destroy(), delete this._metasets[t];\n        }\n        _stop() {\n            let t, e;\n            for(this.stop(), xt.remove(this), t = 0, e = this.data.datasets.length; t < e; ++t)this._destroyDatasetMeta(t);\n        }\n        destroy() {\n            this.notifyPlugins(\"beforeDestroy\");\n            const { canvas: t, ctx: e } = this;\n            this._stop(), this.config.clearCache(), t && (this.unbindEvents(), Te(t, e), this.platform.releaseContext(e), this.canvas = null, this.ctx = null), delete Pn[this.id], this.notifyPlugins(\"afterDestroy\");\n        }\n        toBase64Image(...t) {\n            return this.canvas.toDataURL(...t);\n        }\n        bindEvents() {\n            this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;\n        }\n        bindUserEvents() {\n            const t = this._listeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (t, e, i)=>{\n                t.offsetX = e, t.offsetY = i, this._eventHandler(t);\n            };\n            u(this.options.events, (t)=>i(t, s));\n        }\n        bindResponsiveEvents() {\n            this._responsiveListeners || (this._responsiveListeners = {});\n            const t = this._responsiveListeners, e = this.platform, i = (i, s)=>{\n                e.addEventListener(this, i, s), t[i] = s;\n            }, s = (i, s)=>{\n                t[i] && (e.removeEventListener(this, i, s), delete t[i]);\n            }, n = (t, e)=>{\n                this.canvas && this.resize(t, e);\n            };\n            let o;\n            const a = ()=>{\n                s(\"attach\", a), this.attached = !0, this.resize(), i(\"resize\", n), i(\"detach\", o);\n            };\n            o = ()=>{\n                this.attached = !1, s(\"resize\", n), this._stop(), this._resize(0, 0), i(\"attach\", a);\n            }, e.isAttached(this.canvas) ? a() : o();\n        }\n        unbindEvents() {\n            u(this._listeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._listeners = {}, u(this._responsiveListeners, (t, e)=>{\n                this.platform.removeEventListener(this, e, t);\n            }), this._responsiveListeners = void 0;\n        }\n        updateHoverStyle(t, e, i) {\n            const s = i ? \"set\" : \"remove\";\n            let n, o, a, r;\n            for(\"dataset\" === e && (n = this.getDatasetMeta(t[0].datasetIndex), n.controller[\"_\" + s + \"DatasetHoverStyle\"]()), a = 0, r = t.length; a < r; ++a){\n                o = t[a];\n                const e = o && this.getDatasetMeta(o.datasetIndex).controller;\n                e && e[s + \"HoverStyle\"](o.element, o.datasetIndex, o.index);\n            }\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t) {\n            const e = this._active || [], i = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.getDatasetMeta(t);\n                if (!i) throw new Error(\"No dataset found at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            });\n            !f(i, e) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, e));\n        }\n        notifyPlugins(t, e, i) {\n            return this._plugins.notify(this, t, e, i);\n        }\n        isPluginEnabled(t) {\n            return 1 === this._plugins._cache.filter((e)=>e.plugin.id === t).length;\n        }\n        _updateHoverStyles(t, e, i) {\n            const s = this.options.hover, n = (t, e)=>t.filter((t)=>!e.some((e)=>t.datasetIndex === e.datasetIndex && t.index === e.index)), o = n(e, t), a = i ? t : n(t, e);\n            o.length && this.updateHoverStyle(o, s.mode, !1), a.length && s.mode && this.updateHoverStyle(a, s.mode, !0);\n        }\n        _eventHandler(t, e) {\n            const i = {\n                event: t,\n                replay: e,\n                cancelable: !0,\n                inChartArea: this.isPointInArea(t)\n            }, s = (e)=>(e.options.events || this.options.events).includes(t.native.type);\n            if (!1 === this.notifyPlugins(\"beforeEvent\", i, s)) return;\n            const n = this._handleEvent(t, e, i.inChartArea);\n            return i.cancelable = !1, this.notifyPlugins(\"afterEvent\", i, s), (n || i.changed) && this.render(), this;\n        }\n        _handleEvent(t, e, i) {\n            const { _active: s = [], options: n } = this, o = e, a = this._getActiveElements(t, s, i, o), r = D(t), l = function(t, e, i, s) {\n                return i && \"mouseout\" !== t.type ? s ? e : t : null;\n            }(t, this._lastEvent, i, r);\n            i && (this._lastEvent = null, d(n.onHover, [\n                t,\n                a,\n                this\n            ], this), r && d(n.onClick, [\n                t,\n                a,\n                this\n            ], this));\n            const h = !f(a, s);\n            return (h || e) && (this._active = a, this._updateHoverStyles(a, s, e)), this._lastEvent = l, h;\n        }\n        _getActiveElements(t, e, i, s) {\n            if (\"mouseout\" === t.type) return [];\n            if (!i) return e;\n            const n = this.options.hover;\n            return this.getElementsAtEventForMode(t, n.mode, n, s);\n        }\n    }\n    function Tn() {\n        return u(An.instances, (t)=>t._plugins.invalidate());\n    }\n    function Ln() {\n        throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n    }\n    class En {\n        static override(t) {\n            Object.assign(En.prototype, t);\n        }\n        options;\n        constructor(t){\n            this.options = t || {};\n        }\n        init() {}\n        formats() {\n            return Ln();\n        }\n        parse() {\n            return Ln();\n        }\n        format() {\n            return Ln();\n        }\n        add() {\n            return Ln();\n        }\n        diff() {\n            return Ln();\n        }\n        startOf() {\n            return Ln();\n        }\n        endOf() {\n            return Ln();\n        }\n    }\n    var Rn = {\n        _date: En\n    };\n    function In(t) {\n        const e = t.iScale, i = function(t, e) {\n            if (!t._cache.$bar) {\n                const i = t.getMatchingVisibleMetas(e);\n                let s = [];\n                for(let e = 0, n = i.length; e < n; e++)s = s.concat(i[e].controller.getAllParsedValues(t));\n                t._cache.$bar = lt(s.sort((t, e)=>t - e));\n            }\n            return t._cache.$bar;\n        }(e, t.type);\n        let s, n, o, a, r = e._length;\n        const l = ()=>{\n            32767 !== o && -32768 !== o && (k(a) && (r = Math.min(r, Math.abs(o - a) || r)), a = o);\n        };\n        for(s = 0, n = i.length; s < n; ++s)o = e.getPixelForValue(i[s]), l();\n        for(a = void 0, s = 0, n = e.ticks.length; s < n; ++s)o = e.getPixelForTick(s), l();\n        return r;\n    }\n    function zn(t, e, i, s) {\n        return n(t) ? function(t, e, i, s) {\n            const n = i.parse(t[0], s), o = i.parse(t[1], s), a = Math.min(n, o), r = Math.max(n, o);\n            let l = a, h = r;\n            Math.abs(a) > Math.abs(r) && (l = r, h = a), e[i.axis] = h, e._custom = {\n                barStart: l,\n                barEnd: h,\n                start: n,\n                end: o,\n                min: a,\n                max: r\n            };\n        }(t, e, i, s) : e[i.axis] = i.parse(t, s), e;\n    }\n    function Fn(t, e, i, s) {\n        const n = t.iScale, o = t.vScale, a = n.getLabels(), r = n === o, l = [];\n        let h, c, d, u;\n        for(h = i, c = i + s; h < c; ++h)u = e[h], d = {}, d[n.axis] = r || n.parse(a[h], h), l.push(zn(u, d, o, h));\n        return l;\n    }\n    function Vn(t) {\n        return t && void 0 !== t.barStart && void 0 !== t.barEnd;\n    }\n    function Bn(t, e, i, s) {\n        let n = e.borderSkipped;\n        const o = {};\n        if (!n) return void (t.borderSkipped = o);\n        if (!0 === n) return void (t.borderSkipped = {\n            top: !0,\n            right: !0,\n            bottom: !0,\n            left: !0\n        });\n        const { start: a, end: r, reverse: l, top: h, bottom: c } = function(t) {\n            let e, i, s, n, o;\n            return t.horizontal ? (e = t.base > t.x, i = \"left\", s = \"right\") : (e = t.base < t.y, i = \"bottom\", s = \"top\"), e ? (n = \"end\", o = \"start\") : (n = \"start\", o = \"end\"), {\n                start: i,\n                end: s,\n                reverse: e,\n                top: n,\n                bottom: o\n            };\n        }(t);\n        \"middle\" === n && i && (t.enableBorderRadius = !0, (i._top || 0) === s ? n = h : (i._bottom || 0) === s ? n = c : (o[Wn(c, a, r, l)] = !0, n = h)), o[Wn(n, a, r, l)] = !0, t.borderSkipped = o;\n    }\n    function Wn(t, e, i, s) {\n        var n, o, a;\n        return s ? (a = i, t = Nn(t = (n = t) === (o = e) ? a : n === a ? o : n, i, e)) : t = Nn(t, e, i), t;\n    }\n    function Nn(t, e, i) {\n        return \"start\" === t ? e : \"end\" === t ? i : t;\n    }\n    function Hn(t, { inflateAmount: e }, i) {\n        t.inflateAmount = \"auto\" === e ? 1 === i ? .33 : 0 : e;\n    }\n    class jn extends Ns {\n        static id = \"doughnut\";\n        static defaults = {\n            datasetElementType: !1,\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !1\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"circumference\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\",\n                        \"startAngle\",\n                        \"x\",\n                        \"y\",\n                        \"offset\",\n                        \"borderWidth\",\n                        \"spacing\"\n                    ]\n                }\n            },\n            cutout: \"50%\",\n            rotation: 0,\n            circumference: 360,\n            radius: \"100%\",\n            spacing: 0,\n            indexAxis: \"r\"\n        };\n        static descriptors = {\n            _scriptable: (t)=>\"spacing\" !== t,\n            _indexable: (t)=>\"spacing\" !== t && !t.startsWith(\"borderDash\") && !t.startsWith(\"hoverBorderDash\")\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;\n        }\n        linkScales() {}\n        parse(t, e) {\n            const i = this.getDataset().data, s = this._cachedMeta;\n            if (!1 === this._parsing) s._parsed = i;\n            else {\n                let n, a, r = (t)=>+i[t];\n                if (o(i[t])) {\n                    const { key: t = \"value\" } = this._parsing;\n                    r = (e)=>+M(i[e], t);\n                }\n                for(n = t, a = t + e; n < a; ++n)s._parsed[n] = r(n);\n            }\n        }\n        _getRotation() {\n            return $(this.options.rotation - 90);\n        }\n        _getCircumference() {\n            return $(this.options.circumference);\n        }\n        _getRotationExtents() {\n            let t = O, e = -O;\n            for(let i = 0; i < this.chart.data.datasets.length; ++i)if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const s = this.chart.getDatasetMeta(i).controller, n = s._getRotation(), o = s._getCircumference();\n                t = Math.min(t, n), e = Math.max(e, n + o);\n            }\n            return {\n                rotation: t,\n                circumference: e - t\n            };\n        }\n        update(t) {\n            const e = this.chart, { chartArea: i } = e, s = this._cachedMeta, n = s.data, o = this.getMaxBorderWidth() + this.getMaxOffset(n) + this.options.spacing, a = Math.max((Math.min(i.width, i.height) - o) / 2, 0), r = Math.min(h(this.options.cutout, a), 1), l = this._getRingWeight(this.index), { circumference: d, rotation: u } = this._getRotationExtents(), { ratioX: f, ratioY: g, offsetX: p, offsetY: m } = function(t, e, i) {\n                let s = 1, n = 1, o = 0, a = 0;\n                if (e < O) {\n                    const r = t, l = r + e, h = Math.cos(r), c = Math.sin(r), d = Math.cos(l), u = Math.sin(l), f = (t, e, s)=>Z(t, r, l, !0) ? 1 : Math.max(e, e * i, s, s * i), g = (t, e, s)=>Z(t, r, l, !0) ? -1 : Math.min(e, e * i, s, s * i), p = f(0, h, d), m = f(E, c, u), b = g(C, h, d), x = g(C + E, c, u);\n                    s = (p - b) / 2, n = (m - x) / 2, o = -(p + b) / 2, a = -(m + x) / 2;\n                }\n                return {\n                    ratioX: s,\n                    ratioY: n,\n                    offsetX: o,\n                    offsetY: a\n                };\n            }(u, d, r), b = (i.width - o) / f, x = (i.height - o) / g, _ = Math.max(Math.min(b, x) / 2, 0), y = c(this.options.radius, _), v = (y - Math.max(y * r, 0)) / this._getVisibleDatasetWeightTotal();\n            this.offsetX = p * y, this.offsetY = m * y, s.total = this.calculateTotal(), this.outerRadius = y - v * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - v * l, 0), this.updateElements(n, 0, n.length, t);\n        }\n        _circumference(t, e) {\n            const i = this.options, s = this._cachedMeta, n = this._getCircumference();\n            return e && i.animation.animateRotate || !this.chart.getDataVisibility(t) || null === s._parsed[t] || s.data[t].hidden ? 0 : this.calculateCircumference(s._parsed[t] * n / O);\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.chartArea, r = o.options.animation, l = (a.left + a.right) / 2, h = (a.top + a.bottom) / 2, c = n && r.animateScale, d = c ? 0 : this.innerRadius, u = c ? 0 : this.outerRadius, { sharedOptions: f, includeOptions: g } = this._getSharedOptions(e, s);\n            let p, m = this._getRotation();\n            for(p = 0; p < e; ++p)m += this._circumference(p, n);\n            for(p = e; p < e + i; ++p){\n                const e = this._circumference(p, n), i = t[p], o = {\n                    x: l + this.offsetX,\n                    y: h + this.offsetY,\n                    startAngle: m,\n                    endAngle: m + e,\n                    circumference: e,\n                    outerRadius: u,\n                    innerRadius: d\n                };\n                g && (o.options = f || this.resolveDataElementOptions(p, i.active ? \"active\" : s)), m += e, this.updateElement(i, p, o, s);\n            }\n        }\n        calculateTotal() {\n            const t = this._cachedMeta, e = t.data;\n            let i, s = 0;\n            for(i = 0; i < e.length; i++){\n                const n = t._parsed[i];\n                null === n || isNaN(n) || !this.chart.getDataVisibility(i) || e[i].hidden || (s += Math.abs(n));\n            }\n            return s;\n        }\n        calculateCircumference(t) {\n            const e = this._cachedMeta.total;\n            return e > 0 && !isNaN(t) ? O * (Math.abs(t) / e) : 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t], i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        getMaxBorderWidth(t) {\n            let e = 0;\n            const i = this.chart;\n            let s, n, o, a, r;\n            if (!t) {\n                for(s = 0, n = i.data.datasets.length; s < n; ++s)if (i.isDatasetVisible(s)) {\n                    o = i.getDatasetMeta(s), t = o.data, a = o.controller;\n                    break;\n                }\n            }\n            if (!t) return 0;\n            for(s = 0, n = t.length; s < n; ++s)r = a.resolveDataElementOptions(s), \"inner\" !== r.borderAlign && (e = Math.max(e, r.borderWidth || 0, r.hoverBorderWidth || 0));\n            return e;\n        }\n        getMaxOffset(t) {\n            let e = 0;\n            for(let i = 0, s = t.length; i < s; ++i){\n                const t = this.resolveDataElementOptions(i);\n                e = Math.max(e, t.offset || 0, t.hoverOffset || 0);\n            }\n            return e;\n        }\n        _getRingWeightOffset(t) {\n            let e = 0;\n            for(let i = 0; i < t; ++i)this.chart.isDatasetVisible(i) && (e += this._getRingWeight(i));\n            return e;\n        }\n        _getRingWeight(t) {\n            return Math.max(l(this.chart.data.datasets[t].weight, 1), 0);\n        }\n        _getVisibleDatasetWeightTotal() {\n            return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n        }\n    }\n    class $n extends Ns {\n        static id = \"polarArea\";\n        static defaults = {\n            dataElementType: \"arc\",\n            animation: {\n                animateRotate: !0,\n                animateScale: !0\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"startAngle\",\n                        \"endAngle\",\n                        \"innerRadius\",\n                        \"outerRadius\"\n                    ]\n                }\n            },\n            indexAxis: \"r\",\n            startAngle: 0\n        };\n        static overrides = {\n            aspectRatio: 1,\n            plugins: {\n                legend: {\n                    labels: {\n                        generateLabels (t) {\n                            const e = t.data;\n                            if (e.labels.length && e.datasets.length) {\n                                const { labels: { pointStyle: i, color: s } } = t.legend.options;\n                                return e.labels.map((e, n)=>{\n                                    const o = t.getDatasetMeta(0).controller.getStyle(n);\n                                    return {\n                                        text: e,\n                                        fillStyle: o.backgroundColor,\n                                        strokeStyle: o.borderColor,\n                                        fontColor: s,\n                                        lineWidth: o.borderWidth,\n                                        pointStyle: i,\n                                        hidden: !t.getDataVisibility(n),\n                                        index: n\n                                    };\n                                });\n                            }\n                            return [];\n                        }\n                    },\n                    onClick (t, e, i) {\n                        i.chart.toggleDataVisibility(e.index), i.chart.update();\n                    }\n                }\n            },\n            scales: {\n                r: {\n                    type: \"radialLinear\",\n                    angleLines: {\n                        display: !1\n                    },\n                    beginAtZero: !0,\n                    grid: {\n                        circular: !0\n                    },\n                    pointLabels: {\n                        display: !1\n                    },\n                    startAngle: 0\n                }\n            }\n        };\n        constructor(t, e){\n            super(t, e), this.innerRadius = void 0, this.outerRadius = void 0;\n        }\n        getLabelAndValue(t) {\n            const e = this._cachedMeta, i = this.chart, s = i.data.labels || [], n = ne(e._parsed[t].r, i.options.locale);\n            return {\n                label: s[t] || \"\",\n                value: n\n            };\n        }\n        parseObjectData(t, e, i, s) {\n            return ii.bind(this)(t, e, i, s);\n        }\n        update(t) {\n            const e = this._cachedMeta.data;\n            this._updateRadius(), this.updateElements(e, 0, e.length, t);\n        }\n        getMinMax() {\n            const t = this._cachedMeta, e = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            };\n            return t.data.forEach((t, i)=>{\n                const s = this.getParsed(i).r;\n                !isNaN(s) && this.chart.getDataVisibility(i) && (s < e.min && (e.min = s), s > e.max && (e.max = s));\n            }), e;\n        }\n        _updateRadius() {\n            const t = this.chart, e = t.chartArea, i = t.options, s = Math.min(e.right - e.left, e.bottom - e.top), n = Math.max(s / 2, 0), o = (n - Math.max(i.cutoutPercentage ? n / 100 * i.cutoutPercentage : 1, 0)) / t.getVisibleDatasetCount();\n            this.outerRadius = n - o * this.index, this.innerRadius = this.outerRadius - o;\n        }\n        updateElements(t, e, i, s) {\n            const n = \"reset\" === s, o = this.chart, a = o.options.animation, r = this._cachedMeta.rScale, l = r.xCenter, h = r.yCenter, c = r.getIndexAngle(0) - .5 * C;\n            let d, u = c;\n            const f = 360 / this.countVisibleElements();\n            for(d = 0; d < e; ++d)u += this._computeAngle(d, s, f);\n            for(d = e; d < e + i; d++){\n                const e = t[d];\n                let i = u, g = u + this._computeAngle(d, s, f), p = o.getDataVisibility(d) ? r.getDistanceFromCenterForValue(this.getParsed(d).r) : 0;\n                u = g, n && (a.animateScale && (p = 0), a.animateRotate && (i = g = c));\n                const m = {\n                    x: l,\n                    y: h,\n                    innerRadius: 0,\n                    outerRadius: p,\n                    startAngle: i,\n                    endAngle: g,\n                    options: this.resolveDataElementOptions(d, e.active ? \"active\" : s)\n                };\n                this.updateElement(e, d, m, s);\n            }\n        }\n        countVisibleElements() {\n            const t = this._cachedMeta;\n            let e = 0;\n            return t.data.forEach((t, i)=>{\n                !isNaN(this.getParsed(i).r) && this.chart.getDataVisibility(i) && e++;\n            }), e;\n        }\n        _computeAngle(t, e, i) {\n            return this.chart.getDataVisibility(t) ? $(this.resolveDataElementOptions(t, e).angle || i) : 0;\n        }\n    }\n    var Yn = Object.freeze({\n        __proto__: null,\n        BarController: class extends Ns {\n            static id = \"bar\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"bar\",\n                categoryPercentage: .8,\n                barPercentage: .9,\n                grouped: !0,\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"base\",\n                            \"width\",\n                            \"height\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\",\n                        offset: !0,\n                        grid: {\n                            offset: !0\n                        }\n                    },\n                    _value_: {\n                        type: \"linear\",\n                        beginAtZero: !0\n                    }\n                }\n            };\n            parsePrimitiveData(t, e, i, s) {\n                return Fn(t, e, i, s);\n            }\n            parseArrayData(t, e, i, s) {\n                return Fn(t, e, i, s);\n            }\n            parseObjectData(t, e, i, s) {\n                const { iScale: n, vScale: o } = t, { xAxisKey: a = \"x\", yAxisKey: r = \"y\" } = this._parsing, l = \"x\" === n.axis ? a : r, h = \"x\" === o.axis ? a : r, c = [];\n                let d, u, f, g;\n                for(d = i, u = i + s; d < u; ++d)g = e[d], f = {}, f[n.axis] = n.parse(M(g, l), d), c.push(zn(M(g, h), f, o, d));\n                return c;\n            }\n            updateRangeFromParsed(t, e, i, s) {\n                super.updateRangeFromParsed(t, e, i, s);\n                const n = i._custom;\n                n && e === this._cachedMeta.vScale && (t.min = Math.min(t.min, n.min), t.max = Math.max(t.max, n.max));\n            }\n            getMaxOverflow() {\n                return 0;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, { iScale: i, vScale: s } = e, n = this.getParsed(t), o = n._custom, a = Vn(o) ? \"[\" + o.start + \", \" + o.end + \"]\" : \"\" + s.getLabelForValue(n[s.axis]);\n                return {\n                    label: \"\" + i.getLabelForValue(n[i.axis]),\n                    value: a\n                };\n            }\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n                this._cachedMeta.stack = this.getDataset().stack;\n            }\n            update(t) {\n                const e = this._cachedMeta;\n                this.updateElements(e.data, 0, e.data.length, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { index: a, _cachedMeta: { vScale: r } } = this, l = r.getBasePixel(), h = r.isHorizontal(), c = this._getRuler(), { sharedOptions: d, includeOptions: u } = this._getSharedOptions(e, n);\n                for(let f = e; f < e + i; f++){\n                    const e = this.getParsed(f), i = o || s(e[r.axis]) ? {\n                        base: l,\n                        head: l\n                    } : this._calculateBarValuePixels(f), g = this._calculateBarIndexPixels(f, c), p = (e._stacks || {})[r.axis], m = {\n                        horizontal: h,\n                        base: i.base,\n                        enableBorderRadius: !p || Vn(e._custom) || a === p._top || a === p._bottom,\n                        x: h ? i.head : g.center,\n                        y: h ? g.center : i.head,\n                        height: h ? g.size : Math.abs(i.size),\n                        width: h ? Math.abs(i.size) : g.size\n                    };\n                    u && (m.options = d || this.resolveDataElementOptions(f, t[f].active ? \"active\" : n));\n                    const b = m.options || t[f].options;\n                    Bn(m, b, p, a), Hn(m, b, c.ratio), this.updateElement(t[f], f, m, n);\n                }\n            }\n            _getStacks(t, e) {\n                const { iScale: i } = this._cachedMeta, n = i.getMatchingVisibleMetas(this._type).filter((t)=>t.controller.options.grouped), o = i.options.stacked, a = [], r = (t)=>{\n                    const i = t.controller.getParsed(e), n = i && i[t.vScale.axis];\n                    if (s(n) || isNaN(n)) return !0;\n                };\n                for (const i of n)if ((void 0 === e || !r(i)) && ((!1 === o || -1 === a.indexOf(i.stack) || void 0 === o && void 0 === i.stack) && a.push(i.stack), i.index === t)) break;\n                return a.length || a.push(void 0), a;\n            }\n            _getStackCount(t) {\n                return this._getStacks(void 0, t).length;\n            }\n            _getStackIndex(t, e, i) {\n                const s = this._getStacks(t, i), n = void 0 !== e ? s.indexOf(e) : -1;\n                return -1 === n ? s.length - 1 : n;\n            }\n            _getRuler() {\n                const t = this.options, e = this._cachedMeta, i = e.iScale, s = [];\n                let n, o;\n                for(n = 0, o = e.data.length; n < o; ++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis], n));\n                const a = t.barThickness;\n                return {\n                    min: a || In(e),\n                    pixels: s,\n                    start: i._startPixel,\n                    end: i._endPixel,\n                    stackCount: this._getStackCount(),\n                    scale: i,\n                    grouped: t.grouped,\n                    ratio: a ? 1 : t.categoryPercentage * t.barPercentage\n                };\n            }\n            _calculateBarValuePixels(t) {\n                const { _cachedMeta: { vScale: e, _stacked: i, index: n }, options: { base: o, minBarLength: a } } = this, r = o || 0, l = this.getParsed(t), h = l._custom, c = Vn(h);\n                let d, u, f = l[e.axis], g = 0, p = i ? this.applyStack(e, l, i) : f;\n                p !== f && (g = p - f, p = f), c && (f = h.barStart, p = h.barEnd - h.barStart, 0 !== f && F(f) !== F(h.barEnd) && (g = 0), g += f);\n                const m = s(o) || c ? g : o;\n                let b = e.getPixelForValue(m);\n                if (d = this.chart.getDataVisibility(t) ? e.getPixelForValue(g + p) : b, u = d - b, Math.abs(u) < a) {\n                    u = function(t, e, i) {\n                        return 0 !== t ? F(t) : (e.isHorizontal() ? 1 : -1) * (e.min >= i ? 1 : -1);\n                    }(u, e, r) * a, f === r && (b -= u / 2);\n                    const t = e.getPixelForDecimal(0), s = e.getPixelForDecimal(1), o = Math.min(t, s), h = Math.max(t, s);\n                    b = Math.max(Math.min(b, h), o), d = b + u, i && !c && (l._stacks[e.axis]._visualValues[n] = e.getValueForPixel(d) - e.getValueForPixel(b));\n                }\n                if (b === e.getPixelForValue(r)) {\n                    const t = F(u) * e.getLineWidthForValue(r) / 2;\n                    b += t, u -= t;\n                }\n                return {\n                    size: u,\n                    base: b,\n                    head: d,\n                    center: d + u / 2\n                };\n            }\n            _calculateBarIndexPixels(t, e) {\n                const i = e.scale, n = this.options, o = n.skipNull, a = l(n.maxBarThickness, 1 / 0);\n                let r, h;\n                if (e.grouped) {\n                    const i = o ? this._getStackCount(t) : e.stackCount, l = \"flex\" === n.barThickness ? function(t, e, i, s) {\n                        const n = e.pixels, o = n[t];\n                        let a = t > 0 ? n[t - 1] : null, r = t < n.length - 1 ? n[t + 1] : null;\n                        const l = i.categoryPercentage;\n                        null === a && (a = o - (null === r ? e.end - e.start : r - o)), null === r && (r = o + o - a);\n                        const h = o - (o - Math.min(a, r)) / 2 * l;\n                        return {\n                            chunk: Math.abs(r - a) / 2 * l / s,\n                            ratio: i.barPercentage,\n                            start: h\n                        };\n                    }(t, e, n, i) : function(t, e, i, n) {\n                        const o = i.barThickness;\n                        let a, r;\n                        return s(o) ? (a = e.min * i.categoryPercentage, r = i.barPercentage) : (a = o * n, r = 1), {\n                            chunk: a / n,\n                            ratio: r,\n                            start: e.pixels[t] - a / 2\n                        };\n                    }(t, e, n, i), c = this._getStackIndex(this.index, this._cachedMeta.stack, o ? t : void 0);\n                    r = l.start + l.chunk * c + l.chunk / 2, h = Math.min(a, l.chunk * l.ratio);\n                } else r = i.getPixelForValue(this.getParsed(t)[i.axis], t), h = Math.min(a, e.min * e.ratio);\n                return {\n                    base: r - h / 2,\n                    head: r + h / 2,\n                    center: r,\n                    size: h\n                };\n            }\n            draw() {\n                const t = this._cachedMeta, e = t.vScale, i = t.data, s = i.length;\n                let n = 0;\n                for(; n < s; ++n)null !== this.getParsed(n)[e.axis] && i[n].draw(this._ctx);\n            }\n        },\n        BubbleController: class extends Ns {\n            static id = \"bubble\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                animations: {\n                    numbers: {\n                        type: \"number\",\n                        properties: [\n                            \"x\",\n                            \"y\",\n                            \"borderWidth\",\n                            \"radius\"\n                        ]\n                    }\n                }\n            };\n            static overrides = {\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, super.initialize();\n            }\n            parsePrimitiveData(t, e, i, s) {\n                const n = super.parsePrimitiveData(t, e, i, s);\n                for(let t = 0; t < n.length; t++)n[t]._custom = this.resolveDataElementOptions(t + i).radius;\n                return n;\n            }\n            parseArrayData(t, e, i, s) {\n                const n = super.parseArrayData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s[2], this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            parseObjectData(t, e, i, s) {\n                const n = super.parseObjectData(t, e, i, s);\n                for(let t = 0; t < n.length; t++){\n                    const s = e[i + t];\n                    n[t]._custom = l(s && s.r && +s.r, this.resolveDataElementOptions(t + i).radius);\n                }\n                return n;\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta.data;\n                let e = 0;\n                for(let i = t.length - 1; i >= 0; --i)e = Math.max(e, t[i].size(this.resolveDataElementOptions(i)) / 2);\n                return e > 0 && e;\n            }\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y), l = o._custom;\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + (l ? \", \" + l : \"\") + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta.data;\n                this.updateElements(e, 0, e.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = \"reset\" === s, { iScale: o, vScale: a } = this._cachedMeta, { sharedOptions: r, includeOptions: l } = this._getSharedOptions(e, s), h = o.axis, c = a.axis;\n                for(let d = e; d < e + i; d++){\n                    const e = t[d], i = !n && this.getParsed(d), u = {}, f = u[h] = n ? o.getPixelForDecimal(.5) : o.getPixelForValue(i[h]), g = u[c] = n ? a.getBasePixel() : a.getPixelForValue(i[c]);\n                    u.skip = isNaN(f) || isNaN(g), l && (u.options = r || this.resolveDataElementOptions(d, e.active ? \"active\" : s), n && (u.options.radius = 0)), this.updateElement(e, d, u, s);\n                }\n            }\n            resolveDataElementOptions(t, e) {\n                const i = this.getParsed(t);\n                let s = super.resolveDataElementOptions(t, e);\n                s.$shared && (s = Object.assign({}, s, {\n                    $shared: !1\n                }));\n                const n = s.radius;\n                return \"active\" !== e && (s.radius = 0), s.radius += l(i && i._custom, n), s;\n            }\n        },\n        DoughnutController: jn,\n        LineController: class extends Ns {\n            static id = \"line\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                showLine: !0,\n                spanGaps: !1\n            };\n            static overrides = {\n                scales: {\n                    _index_: {\n                        type: \"category\"\n                    },\n                    _value_: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            initialize() {\n                this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();\n            }\n            update(t) {\n                const e = this._cachedMeta, { dataset: i, data: s = [], _dataset: n } = e, o = this.chart._animationsDisabled;\n                let { start: a, count: r } = pt(e, s, o);\n                this._drawStart = a, this._drawCount = r, mt(e) && (a = 0, r = s.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!n._decimated, i.points = s;\n                const l = this.resolveDatasetElementOptions(t);\n                this.options.showLine || (l.borderWidth = 0), l.segment = this.options.segment, this.updateElement(i, void 0, {\n                    animated: !o,\n                    options: l\n                }, t), this.updateElements(s, a, r, t);\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, { sharedOptions: c, includeOptions: d } = this._getSharedOptions(e, n), u = a.axis, f = r.axis, { spanGaps: g, segment: p } = this.options, m = N(g) ? g : Number.POSITIVE_INFINITY, b = this.chart._animationsDisabled || o || \"none\" === n, x = e + i, _ = t.length;\n                let y = e > 0 && this.getParsed(e - 1);\n                for(let i = 0; i < _; ++i){\n                    const g = t[i], _ = b ? g : {};\n                    if (i < e || i >= x) {\n                        _.skip = !0;\n                        continue;\n                    }\n                    const v = this.getParsed(i), M = s(v[f]), w = _[u] = a.getPixelForValue(v[u], i), k = _[f] = o || M ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, v, l) : v[f], i);\n                    _.skip = isNaN(w) || isNaN(k) || M, _.stop = i > 0 && Math.abs(v[u] - y[u]) > m, p && (_.parsed = v, _.raw = h.data[i]), d && (_.options = c || this.resolveDataElementOptions(i, g.active ? \"active\" : n)), b || this.updateElement(g, i, _, n), y = v;\n                }\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.dataset, i = e.options && e.options.borderWidth || 0, s = t.data || [];\n                if (!s.length) return i;\n                const n = s[0].size(this.resolveDataElementOptions(0)), o = s[s.length - 1].size(this.resolveDataElementOptions(s.length - 1));\n                return Math.max(i, n, o) / 2;\n            }\n            draw() {\n                const t = this._cachedMeta;\n                t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();\n            }\n        },\n        PieController: class extends jn {\n            static id = \"pie\";\n            static defaults = {\n                cutout: 0,\n                rotation: 0,\n                circumference: 360,\n                radius: \"100%\"\n            };\n        },\n        PolarAreaController: $n,\n        RadarController: class extends Ns {\n            static id = \"radar\";\n            static defaults = {\n                datasetElementType: \"line\",\n                dataElementType: \"point\",\n                indexAxis: \"r\",\n                showLine: !0,\n                elements: {\n                    line: {\n                        fill: \"start\"\n                    }\n                }\n            };\n            static overrides = {\n                aspectRatio: 1,\n                scales: {\n                    r: {\n                        type: \"radialLinear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta.vScale, i = this.getParsed(t);\n                return {\n                    label: e.getLabels()[t],\n                    value: \"\" + e.getLabelForValue(i[e.axis])\n                };\n            }\n            parseObjectData(t, e, i, s) {\n                return ii.bind(this)(t, e, i, s);\n            }\n            update(t) {\n                const e = this._cachedMeta, i = e.dataset, s = e.data || [], n = e.iScale.getLabels();\n                if (i.points = s, \"resize\" !== t) {\n                    const e = this.resolveDatasetElementOptions(t);\n                    this.options.showLine || (e.borderWidth = 0);\n                    const o = {\n                        _loop: !0,\n                        _fullLoop: n.length === s.length,\n                        options: e\n                    };\n                    this.updateElement(i, void 0, o, t);\n                }\n                this.updateElements(s, 0, s.length, t);\n            }\n            updateElements(t, e, i, s) {\n                const n = this._cachedMeta.rScale, o = \"reset\" === s;\n                for(let a = e; a < e + i; a++){\n                    const e = t[a], i = this.resolveDataElementOptions(a, e.active ? \"active\" : s), r = n.getPointPositionForValue(a, this.getParsed(a).r), l = o ? n.xCenter : r.x, h = o ? n.yCenter : r.y, c = {\n                        x: l,\n                        y: h,\n                        angle: r.angle,\n                        skip: isNaN(l) || isNaN(h),\n                        options: i\n                    };\n                    this.updateElement(e, a, c, s);\n                }\n            }\n        },\n        ScatterController: class extends Ns {\n            static id = \"scatter\";\n            static defaults = {\n                datasetElementType: !1,\n                dataElementType: \"point\",\n                showLine: !1,\n                fill: !1\n            };\n            static overrides = {\n                interaction: {\n                    mode: \"point\"\n                },\n                scales: {\n                    x: {\n                        type: \"linear\"\n                    },\n                    y: {\n                        type: \"linear\"\n                    }\n                }\n            };\n            getLabelAndValue(t) {\n                const e = this._cachedMeta, i = this.chart.data.labels || [], { xScale: s, yScale: n } = e, o = this.getParsed(t), a = s.getLabelForValue(o.x), r = n.getLabelForValue(o.y);\n                return {\n                    label: i[t] || \"\",\n                    value: \"(\" + a + \", \" + r + \")\"\n                };\n            }\n            update(t) {\n                const e = this._cachedMeta, { data: i = [] } = e, s = this.chart._animationsDisabled;\n                let { start: n, count: o } = pt(e, i, s);\n                if (this._drawStart = n, this._drawCount = o, mt(e) && (n = 0, o = i.length), this.options.showLine) {\n                    this.datasetElementType || this.addElements();\n                    const { dataset: n, _dataset: o } = e;\n                    n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!o._decimated, n.points = i;\n                    const a = this.resolveDatasetElementOptions(t);\n                    a.segment = this.options.segment, this.updateElement(n, void 0, {\n                        animated: !s,\n                        options: a\n                    }, t);\n                } else this.datasetElementType && (delete e.dataset, this.datasetElementType = !1);\n                this.updateElements(i, n, o, t);\n            }\n            addElements() {\n                const { showLine: t } = this.options;\n                !this.datasetElementType && t && (this.datasetElementType = this.chart.registry.getElement(\"line\")), super.addElements();\n            }\n            updateElements(t, e, i, n) {\n                const o = \"reset\" === n, { iScale: a, vScale: r, _stacked: l, _dataset: h } = this._cachedMeta, c = this.resolveDataElementOptions(e, n), d = this.getSharedOptions(c), u = this.includeOptions(n, d), f = a.axis, g = r.axis, { spanGaps: p, segment: m } = this.options, b = N(p) ? p : Number.POSITIVE_INFINITY, x = this.chart._animationsDisabled || o || \"none\" === n;\n                let _ = e > 0 && this.getParsed(e - 1);\n                for(let c = e; c < e + i; ++c){\n                    const e = t[c], i = this.getParsed(c), p = x ? e : {}, y = s(i[g]), v = p[f] = a.getPixelForValue(i[f], c), M = p[g] = o || y ? r.getBasePixel() : r.getPixelForValue(l ? this.applyStack(r, i, l) : i[g], c);\n                    p.skip = isNaN(v) || isNaN(M) || y, p.stop = c > 0 && Math.abs(i[f] - _[f]) > b, m && (p.parsed = i, p.raw = h.data[c]), u && (p.options = d || this.resolveDataElementOptions(c, e.active ? \"active\" : n)), x || this.updateElement(e, c, p, n), _ = i;\n                }\n                this.updateSharedOptions(d, n, c);\n            }\n            getMaxOverflow() {\n                const t = this._cachedMeta, e = t.data || [];\n                if (!this.options.showLine) {\n                    let t = 0;\n                    for(let i = e.length - 1; i >= 0; --i)t = Math.max(t, e[i].size(this.resolveDataElementOptions(i)) / 2);\n                    return t > 0 && t;\n                }\n                const i = t.dataset, s = i.options && i.options.borderWidth || 0;\n                if (!e.length) return s;\n                const n = e[0].size(this.resolveDataElementOptions(0)), o = e[e.length - 1].size(this.resolveDataElementOptions(e.length - 1));\n                return Math.max(s, n, o) / 2;\n            }\n        }\n    });\n    function Un(t, e, i, s) {\n        const n = vi(t.options.borderRadius, [\n            \"outerStart\",\n            \"outerEnd\",\n            \"innerStart\",\n            \"innerEnd\"\n        ]);\n        const o = (i - e) / 2, a = Math.min(o, s * e / 2), r = (t)=>{\n            const e = (i - Math.min(o, t)) * s / 2;\n            return J(t, 0, Math.min(o, e));\n        };\n        return {\n            outerStart: r(n.outerStart),\n            outerEnd: r(n.outerEnd),\n            innerStart: J(n.innerStart, 0, a),\n            innerEnd: J(n.innerEnd, 0, a)\n        };\n    }\n    function Xn(t, e, i, s) {\n        return {\n            x: i + t * Math.cos(e),\n            y: s + t * Math.sin(e)\n        };\n    }\n    function qn(t, e, i, s, n, o) {\n        const { x: a, y: r, startAngle: l, pixelMargin: h, innerRadius: c } = e, d = Math.max(e.outerRadius + s + i - h, 0), u = c > 0 ? c + s + i + h : 0;\n        let f = 0;\n        const g = n - l;\n        if (s) {\n            const t = ((c > 0 ? c - s : 0) + (d > 0 ? d - s : 0)) / 2;\n            f = (g - (0 !== t ? g * t / (t + s) : g)) / 2;\n        }\n        const p = (g - Math.max(.001, g * d - i / C) / d) / 2, m = l + p + f, b = n - p - f, { outerStart: x, outerEnd: _, innerStart: y, innerEnd: v } = Un(e, u, d, b - m), M = d - x, w = d - _, k = m + x / M, S = b - _ / w, P = u + y, D = u + v, O = m + y / P, A = b - v / D;\n        if (t.beginPath(), o) {\n            const e = (k + S) / 2;\n            if (t.arc(a, r, d, k, e), t.arc(a, r, d, e, S), _ > 0) {\n                const e = Xn(w, S, a, r);\n                t.arc(e.x, e.y, _, S, b + E);\n            }\n            const i = Xn(D, b, a, r);\n            if (t.lineTo(i.x, i.y), v > 0) {\n                const e = Xn(D, A, a, r);\n                t.arc(e.x, e.y, v, b + E, A + Math.PI);\n            }\n            const s = (b - v / u + (m + y / u)) / 2;\n            if (t.arc(a, r, u, b - v / u, s, !0), t.arc(a, r, u, s, m + y / u, !0), y > 0) {\n                const e = Xn(P, O, a, r);\n                t.arc(e.x, e.y, y, O + Math.PI, m - E);\n            }\n            const n = Xn(M, m, a, r);\n            if (t.lineTo(n.x, n.y), x > 0) {\n                const e = Xn(M, k, a, r);\n                t.arc(e.x, e.y, x, m - E, k);\n            }\n        } else {\n            t.moveTo(a, r);\n            const e = Math.cos(k) * d + a, i = Math.sin(k) * d + r;\n            t.lineTo(e, i);\n            const s = Math.cos(S) * d + a, n = Math.sin(S) * d + r;\n            t.lineTo(s, n);\n        }\n        t.closePath();\n    }\n    function Kn(t, e, i, s, n) {\n        const { fullCircles: o, startAngle: a, circumference: r, options: l } = e, { borderWidth: h, borderJoinStyle: c, borderDash: d, borderDashOffset: u } = l, f = \"inner\" === l.borderAlign;\n        if (!h) return;\n        t.setLineDash(d || []), t.lineDashOffset = u, f ? (t.lineWidth = 2 * h, t.lineJoin = c || \"round\") : (t.lineWidth = h, t.lineJoin = c || \"bevel\");\n        let g = e.endAngle;\n        if (o) {\n            qn(t, e, i, s, g, n);\n            for(let e = 0; e < o; ++e)t.stroke();\n            isNaN(r) || (g = a + (r % O || O));\n        }\n        f && function(t, e, i) {\n            const { startAngle: s, pixelMargin: n, x: o, y: a, outerRadius: r, innerRadius: l } = e;\n            let h = n / r;\n            t.beginPath(), t.arc(o, a, r, s - h, i + h), l > n ? (h = n / l, t.arc(o, a, l, i + h, s - h, !0)) : t.arc(o, a, n, i + E, s - E), t.closePath(), t.clip();\n        }(t, e, g), o || (qn(t, e, i, s, g, n), t.stroke());\n    }\n    function Gn(t, e, i = e) {\n        t.lineCap = l(i.borderCapStyle, e.borderCapStyle), t.setLineDash(l(i.borderDash, e.borderDash)), t.lineDashOffset = l(i.borderDashOffset, e.borderDashOffset), t.lineJoin = l(i.borderJoinStyle, e.borderJoinStyle), t.lineWidth = l(i.borderWidth, e.borderWidth), t.strokeStyle = l(i.borderColor, e.borderColor);\n    }\n    function Zn(t, e, i) {\n        t.lineTo(i.x, i.y);\n    }\n    function Jn(t, e, i = {}) {\n        const s = t.length, { start: n = 0, end: o = s - 1 } = i, { start: a, end: r } = e, l = Math.max(n, a), h = Math.min(o, r), c = n < a && o < a || n > r && o > r;\n        return {\n            count: s,\n            start: l,\n            loop: e.loop,\n            ilen: h < l && !c ? s + h - l : h - l\n        };\n    }\n    function Qn(t, e, i, s) {\n        const { points: n, options: o } = e, { count: a, start: r, loop: l, ilen: h } = Jn(n, i, s), c = function(t) {\n            return t.stepped ? Fe : t.tension || \"monotone\" === t.cubicInterpolationMode ? Ve : Zn;\n        }(o);\n        let d, u, f, { move: g = !0, reverse: p } = s || {};\n        for(d = 0; d <= h; ++d)u = n[(r + (p ? h - d : d)) % a], u.skip || (g ? (t.moveTo(u.x, u.y), g = !1) : c(t, f, u, p, o.stepped), f = u);\n        return l && (u = n[(r + (p ? h : 0)) % a], c(t, f, u, p, o.stepped)), !!l;\n    }\n    function to(t, e, i, s) {\n        const n = e.points, { count: o, start: a, ilen: r } = Jn(n, i, s), { move: l = !0, reverse: h } = s || {};\n        let c, d, u, f, g, p, m = 0, b = 0;\n        const x = (t)=>(a + (h ? r - t : t)) % o, _ = ()=>{\n            f !== g && (t.lineTo(m, g), t.lineTo(m, f), t.lineTo(m, p));\n        };\n        for(l && (d = n[x(0)], t.moveTo(d.x, d.y)), c = 0; c <= r; ++c){\n            if (d = n[x(c)], d.skip) continue;\n            const e = d.x, i = d.y, s = 0 | e;\n            s === u ? (i < f ? f = i : i > g && (g = i), m = (b * m + e) / ++b) : (_(), t.lineTo(e, i), u = s, b = 0, f = g = i), p = i;\n        }\n        _();\n    }\n    function eo(t) {\n        const e = t.options, i = e.borderDash && e.borderDash.length;\n        return !(t._decimated || t._loop || e.tension || \"monotone\" === e.cubicInterpolationMode || e.stepped || i) ? to : Qn;\n    }\n    const io = \"function\" == typeof Path2D;\n    function so(t, e, i, s) {\n        io && !e.options.segment ? function(t, e, i, s) {\n            let n = e._path;\n            n || (n = e._path = new Path2D, e.path(n, i, s) && n.closePath()), Gn(t, e.options), t.stroke(n);\n        }(t, e, i, s) : function(t, e, i, s) {\n            const { segments: n, options: o } = e, a = eo(e);\n            for (const r of n)Gn(t, o, r.style), t.beginPath(), a(t, e, r, {\n                start: i,\n                end: i + s - 1\n            }) && t.closePath(), t.stroke();\n        }(t, e, i, s);\n    }\n    class no extends Hs {\n        static id = \"line\";\n        static defaults = {\n            borderCapStyle: \"butt\",\n            borderDash: [],\n            borderDashOffset: 0,\n            borderJoinStyle: \"miter\",\n            borderWidth: 3,\n            capBezierPoints: !0,\n            cubicInterpolationMode: \"default\",\n            fill: !1,\n            spanGaps: !1,\n            stepped: !1,\n            tension: 0\n        };\n        static defaultRoutes = {\n            backgroundColor: \"backgroundColor\",\n            borderColor: \"borderColor\"\n        };\n        static descriptors = {\n            _scriptable: !0,\n            _indexable: (t)=>\"borderDash\" !== t && \"fill\" !== t\n        };\n        constructor(t){\n            super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);\n        }\n        updateControlPoints(t, e) {\n            const i = this.options;\n            if ((i.tension || \"monotone\" === i.cubicInterpolationMode) && !i.stepped && !this._pointsUpdated) {\n                const s = i.spanGaps ? this._loop : this._fullLoop;\n                hi(this._points, i, t, s, e), this._pointsUpdated = !0;\n            }\n        }\n        set points(t) {\n            this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;\n        }\n        get points() {\n            return this._points;\n        }\n        get segments() {\n            return this._segments || (this._segments = zi(this, this.options.segment));\n        }\n        first() {\n            const t = this.segments, e = this.points;\n            return t.length && e[t[0].start];\n        }\n        last() {\n            const t = this.segments, e = this.points, i = t.length;\n            return i && e[t[i - 1].end];\n        }\n        interpolate(t, e) {\n            const i = this.options, s = t[e], n = this.points, o = Ii(this, {\n                property: e,\n                start: s,\n                end: s\n            });\n            if (!o.length) return;\n            const a = [], r = function(t) {\n                return t.stepped ? pi : t.tension || \"monotone\" === t.cubicInterpolationMode ? mi : gi;\n            }(i);\n            let l, h;\n            for(l = 0, h = o.length; l < h; ++l){\n                const { start: h, end: c } = o[l], d = n[h], u = n[c];\n                if (d === u) {\n                    a.push(d);\n                    continue;\n                }\n                const f = r(d, u, Math.abs((s - d[e]) / (u[e] - d[e])), i.stepped);\n                f[e] = t[e], a.push(f);\n            }\n            return 1 === a.length ? a[0] : a;\n        }\n        pathSegment(t, e, i) {\n            return eo(this)(t, this, e, i);\n        }\n        path(t, e, i) {\n            const s = this.segments, n = eo(this);\n            let o = this._loop;\n            e = e || 0, i = i || this.points.length - e;\n            for (const a of s)o &= n(t, this, a, {\n                start: e,\n                end: e + i - 1\n            });\n            return !!o;\n        }\n        draw(t, e, i, s) {\n            const n = this.options || {};\n            (this.points || []).length && n.borderWidth && (t.save(), so(t, this, i, s), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);\n        }\n    }\n    function oo(t, e, i, s) {\n        const n = t.options, { [i]: o } = t.getProps([\n            i\n        ], s);\n        return Math.abs(e - o) < n.radius + n.hitRadius;\n    }\n    function ao(t, e) {\n        const { x: i, y: s, base: n, width: o, height: a } = t.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"width\",\n            \"height\"\n        ], e);\n        let r, l, h, c, d;\n        return t.horizontal ? (d = a / 2, r = Math.min(i, n), l = Math.max(i, n), h = s - d, c = s + d) : (d = o / 2, r = i - d, l = i + d, h = Math.min(s, n), c = Math.max(s, n)), {\n            left: r,\n            top: h,\n            right: l,\n            bottom: c\n        };\n    }\n    function ro(t, e, i, s) {\n        return t ? 0 : J(e, i, s);\n    }\n    function lo(t) {\n        const e = ao(t), i = e.right - e.left, s = e.bottom - e.top, n = function(t, e, i) {\n            const s = t.options.borderWidth, n = t.borderSkipped, o = Mi(s);\n            return {\n                t: ro(n.top, o.top, 0, i),\n                r: ro(n.right, o.right, 0, e),\n                b: ro(n.bottom, o.bottom, 0, i),\n                l: ro(n.left, o.left, 0, e)\n            };\n        }(t, i / 2, s / 2), a = function(t, e, i) {\n            const { enableBorderRadius: s } = t.getProps([\n                \"enableBorderRadius\"\n            ]), n = t.options.borderRadius, a = wi(n), r = Math.min(e, i), l = t.borderSkipped, h = s || o(n);\n            return {\n                topLeft: ro(!h || l.top || l.left, a.topLeft, 0, r),\n                topRight: ro(!h || l.top || l.right, a.topRight, 0, r),\n                bottomLeft: ro(!h || l.bottom || l.left, a.bottomLeft, 0, r),\n                bottomRight: ro(!h || l.bottom || l.right, a.bottomRight, 0, r)\n            };\n        }(t, i / 2, s / 2);\n        return {\n            outer: {\n                x: e.left,\n                y: e.top,\n                w: i,\n                h: s,\n                radius: a\n            },\n            inner: {\n                x: e.left + n.l,\n                y: e.top + n.t,\n                w: i - n.l - n.r,\n                h: s - n.t - n.b,\n                radius: {\n                    topLeft: Math.max(0, a.topLeft - Math.max(n.t, n.l)),\n                    topRight: Math.max(0, a.topRight - Math.max(n.t, n.r)),\n                    bottomLeft: Math.max(0, a.bottomLeft - Math.max(n.b, n.l)),\n                    bottomRight: Math.max(0, a.bottomRight - Math.max(n.b, n.r))\n                }\n            }\n        };\n    }\n    function ho(t, e, i, s) {\n        const n = null === e, o = null === i, a = t && !(n && o) && ao(t, s);\n        return a && (n || tt(e, a.left, a.right)) && (o || tt(i, a.top, a.bottom));\n    }\n    function co(t, e) {\n        t.rect(e.x, e.y, e.w, e.h);\n    }\n    function uo(t, e, i = {}) {\n        const s = t.x !== i.x ? -e : 0, n = t.y !== i.y ? -e : 0, o = (t.x + t.w !== i.x + i.w ? e : 0) - s, a = (t.y + t.h !== i.y + i.h ? e : 0) - n;\n        return {\n            x: t.x + s,\n            y: t.y + n,\n            w: t.w + o,\n            h: t.h + a,\n            radius: t.radius\n        };\n    }\n    var fo = Object.freeze({\n        __proto__: null,\n        ArcElement: class extends Hs {\n            static id = \"arc\";\n            static defaults = {\n                borderAlign: \"center\",\n                borderColor: \"#fff\",\n                borderDash: [],\n                borderDashOffset: 0,\n                borderJoinStyle: void 0,\n                borderRadius: 0,\n                borderWidth: 2,\n                offset: 0,\n                spacing: 0,\n                angle: void 0,\n                circular: !0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\"\n            };\n            static descriptors = {\n                _scriptable: !0,\n                _indexable: (t)=>\"borderDash\" !== t\n            };\n            circumference;\n            endAngle;\n            fullCircles;\n            innerRadius;\n            outerRadius;\n            pixelMargin;\n            startAngle;\n            constructor(t){\n                super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i), { angle: n, distance: o } = X(s, {\n                    x: t,\n                    y: e\n                }), { startAngle: a, endAngle: r, innerRadius: h, outerRadius: c, circumference: d } = this.getProps([\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\",\n                    \"circumference\"\n                ], i), u = (this.options.spacing + this.options.borderWidth) / 2, f = l(d, r - a) >= O || Z(n, a, r), g = tt(o, h + u, c + u);\n                return f && g;\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, startAngle: s, endAngle: n, innerRadius: o, outerRadius: a } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"startAngle\",\n                    \"endAngle\",\n                    \"innerRadius\",\n                    \"outerRadius\"\n                ], t), { offset: r, spacing: l } = this.options, h = (s + n) / 2, c = (o + a + l + r) / 2;\n                return {\n                    x: e + Math.cos(h) * c,\n                    y: i + Math.sin(h) * c\n                };\n            }\n            tooltipPosition(t) {\n                return this.getCenterPoint(t);\n            }\n            draw(t) {\n                const { options: e, circumference: i } = this, s = (e.offset || 0) / 4, n = (e.spacing || 0) / 2, o = e.circular;\n                if (this.pixelMargin = \"inner\" === e.borderAlign ? .33 : 0, this.fullCircles = i > O ? Math.floor(i / O) : 0, 0 === i || this.innerRadius < 0 || this.outerRadius < 0) return;\n                t.save();\n                const a = (this.startAngle + this.endAngle) / 2;\n                t.translate(Math.cos(a) * s, Math.sin(a) * s);\n                const r = s * (1 - Math.sin(Math.min(C, i || 0)));\n                t.fillStyle = e.backgroundColor, t.strokeStyle = e.borderColor, function(t, e, i, s, n) {\n                    const { fullCircles: o, startAngle: a, circumference: r } = e;\n                    let l = e.endAngle;\n                    if (o) {\n                        qn(t, e, i, s, l, n);\n                        for(let e = 0; e < o; ++e)t.fill();\n                        isNaN(r) || (l = a + (r % O || O));\n                    }\n                    qn(t, e, i, s, l, n), t.fill();\n                }(t, this, r, n, o), Kn(t, this, r, n, o), t.restore();\n            }\n        },\n        BarElement: class extends Hs {\n            static id = \"bar\";\n            static defaults = {\n                borderSkipped: \"start\",\n                borderWidth: 0,\n                borderRadius: 0,\n                inflateAmount: \"auto\",\n                pointStyle: void 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);\n            }\n            draw(t) {\n                const { inflateAmount: e, options: { borderColor: i, backgroundColor: s } } = this, { inner: n, outer: o } = lo(this), a = (r = o.radius).topLeft || r.topRight || r.bottomLeft || r.bottomRight ? He : co;\n                var r;\n                t.save(), o.w === n.w && o.h === n.h || (t.beginPath(), a(t, uo(o, e, n)), t.clip(), a(t, uo(n, -e, o)), t.fillStyle = i, t.fill(\"evenodd\")), t.beginPath(), a(t, uo(n, e)), t.fillStyle = s, t.fill(), t.restore();\n            }\n            inRange(t, e, i) {\n                return ho(this, t, e, i);\n            }\n            inXRange(t, e) {\n                return ho(this, t, null, e);\n            }\n            inYRange(t, e) {\n                return ho(this, null, t, e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i, base: s, horizontal: n } = this.getProps([\n                    \"x\",\n                    \"y\",\n                    \"base\",\n                    \"horizontal\"\n                ], t);\n                return {\n                    x: n ? (e + s) / 2 : e,\n                    y: n ? i : (i + s) / 2\n                };\n            }\n            getRange(t) {\n                return \"x\" === t ? this.width / 2 : this.height / 2;\n            }\n        },\n        LineElement: no,\n        PointElement: class extends Hs {\n            static id = \"point\";\n            parsed;\n            skip;\n            stop;\n            static defaults = {\n                borderWidth: 1,\n                hitRadius: 1,\n                hoverBorderWidth: 1,\n                hoverRadius: 4,\n                pointStyle: \"circle\",\n                radius: 3,\n                rotation: 0\n            };\n            static defaultRoutes = {\n                backgroundColor: \"backgroundColor\",\n                borderColor: \"borderColor\"\n            };\n            constructor(t){\n                super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);\n            }\n            inRange(t, e, i) {\n                const s = this.options, { x: n, y: o } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], i);\n                return Math.pow(t - n, 2) + Math.pow(e - o, 2) < Math.pow(s.hitRadius + s.radius, 2);\n            }\n            inXRange(t, e) {\n                return oo(this, t, \"x\", e);\n            }\n            inYRange(t, e) {\n                return oo(this, t, \"y\", e);\n            }\n            getCenterPoint(t) {\n                const { x: e, y: i } = this.getProps([\n                    \"x\",\n                    \"y\"\n                ], t);\n                return {\n                    x: e,\n                    y: i\n                };\n            }\n            size(t) {\n                let e = (t = t || this.options || {}).radius || 0;\n                e = Math.max(e, e && t.hoverRadius || 0);\n                return 2 * (e + (e && t.borderWidth || 0));\n            }\n            draw(t, e) {\n                const i = this.options;\n                this.skip || i.radius < .1 || !Re(this, e, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Le(t, i, this.x, this.y));\n            }\n            getRange() {\n                const t = this.options || {};\n                return t.radius + t.hitRadius;\n            }\n        }\n    });\n    function go(t, e, i, s) {\n        const n = t.indexOf(e);\n        if (-1 === n) return ((t, e, i, s)=>(\"string\" == typeof e ? (i = t.push(e) - 1, s.unshift({\n                index: i,\n                label: e\n            })) : isNaN(e) && (i = null), i))(t, e, i, s);\n        return n !== t.lastIndexOf(e) ? i : n;\n    }\n    function po(t) {\n        const e = this.getLabels();\n        return t >= 0 && t < e.length ? e[t] : t;\n    }\n    function mo(t, e, { horizontal: i, minRotation: s }) {\n        const n = $(s), o = (i ? Math.sin(n) : Math.cos(n)) || .001, a = .75 * e * (\"\" + t).length;\n        return Math.min(e / o, a);\n    }\n    class bo extends Js {\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            return s(t) || (\"number\" == typeof t || t instanceof Number) && !isFinite(+t) ? null : +t;\n        }\n        handleTickRangeOptions() {\n            const { beginAtZero: t } = this.options, { minDefined: e, maxDefined: i } = this.getUserBounds();\n            let { min: s, max: n } = this;\n            const o = (t)=>s = e ? s : t, a = (t)=>n = i ? n : t;\n            if (t) {\n                const t = F(s), e = F(n);\n                t < 0 && e < 0 ? a(0) : t > 0 && e > 0 && o(0);\n            }\n            if (s === n) {\n                let e = 0 === n ? 1 : Math.abs(.05 * n);\n                a(n + e), t || o(s - e);\n            }\n            this.min = s, this.max = n;\n        }\n        getTickLimit() {\n            const t = this.options.ticks;\n            let e, { maxTicksLimit: i, stepSize: s } = t;\n            return s ? (e = Math.ceil(this.max / s) - Math.floor(this.min / s) + 1, e > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`), e = 1e3)) : (e = this.computeTickLimit(), i = i || 11), i && (e = Math.min(i, e)), e;\n        }\n        computeTickLimit() {\n            return Number.POSITIVE_INFINITY;\n        }\n        buildTicks() {\n            const t = this.options, e = t.ticks;\n            let i = this.getTickLimit();\n            i = Math.max(2, i);\n            const n = function(t, e) {\n                const i = [], { bounds: n, step: o, min: a, max: r, precision: l, count: h, maxTicks: c, maxDigits: d, includeBounds: u } = t, f = o || 1, g = c - 1, { min: p, max: m } = e, b = !s(a), x = !s(r), _ = !s(h), y = (m - p) / (d + 1);\n                let v, M, w, k, S = B((m - p) / g / f) * f;\n                if (S < 1e-14 && !b && !x) return [\n                    {\n                        value: p\n                    },\n                    {\n                        value: m\n                    }\n                ];\n                k = Math.ceil(m / S) - Math.floor(p / S), k > g && (S = B(k * S / g / f) * f), s(l) || (v = Math.pow(10, l), S = Math.ceil(S * v) / v), \"ticks\" === n ? (M = Math.floor(p / S) * S, w = Math.ceil(m / S) * S) : (M = p, w = m), b && x && o && H((r - a) / o, S / 1e3) ? (k = Math.round(Math.min((r - a) / S, c)), S = (r - a) / k, M = a, w = r) : _ ? (M = b ? a : M, w = x ? r : w, k = h - 1, S = (w - M) / k) : (k = (w - M) / S, k = V(k, Math.round(k), S / 1e3) ? Math.round(k) : Math.ceil(k));\n                const P = Math.max(U(S), U(M));\n                v = Math.pow(10, s(l) ? P : l), M = Math.round(M * v) / v, w = Math.round(w * v) / v;\n                let D = 0;\n                for(b && (u && M !== a ? (i.push({\n                    value: a\n                }), M < a && D++, V(Math.round((M + D * S) * v) / v, a, mo(a, y, t)) && D++) : M < a && D++); D < k; ++D){\n                    const t = Math.round((M + D * S) * v) / v;\n                    if (x && t > r) break;\n                    i.push({\n                        value: t\n                    });\n                }\n                return x && u && w !== r ? i.length && V(i[i.length - 1].value, r, mo(r, y, t)) ? i[i.length - 1].value = r : i.push({\n                    value: r\n                }) : x && w !== r || i.push({\n                    value: w\n                }), i;\n            }({\n                maxTicks: i,\n                bounds: t.bounds,\n                min: t.min,\n                max: t.max,\n                precision: e.precision,\n                step: e.stepSize,\n                count: e.count,\n                maxDigits: this._maxDigits(),\n                horizontal: this.isHorizontal(),\n                minRotation: e.minRotation || 0,\n                includeBounds: !1 !== e.includeBounds\n            }, this._range || this);\n            return \"ticks\" === t.bounds && j(n, this, \"value\"), t.reverse ? (n.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), n;\n        }\n        configure() {\n            const t = this.ticks;\n            let e = this.min, i = this.max;\n            if (super.configure(), this.options.offset && t.length) {\n                const s = (i - e) / Math.max(t.length - 1, 1) / 2;\n                e -= s, i += s;\n            }\n            this._startValue = e, this._endValue = i, this._valueRange = i - e;\n        }\n        getLabelForValue(t) {\n            return ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n    }\n    class xo extends bo {\n        static id = \"linear\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.numeric\n            }\n        };\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? t : 0, this.max = a(e) ? e : 1, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            const t = this.isHorizontal(), e = t ? this.width : this.height, i = $(this.options.ticks.minRotation), s = (t ? Math.sin(i) : Math.cos(i)) || .001, n = this._resolveTickFontOptions(0);\n            return Math.ceil(e / Math.min(40, n.lineHeight / s));\n        }\n        getPixelForValue(t) {\n            return null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            return this._startValue + this.getDecimalForPixel(t) * this._valueRange;\n        }\n    }\n    const _o = (t)=>Math.floor(z(t)), yo = (t, e)=>Math.pow(10, _o(t) + e);\n    function vo(t) {\n        return 1 === t / Math.pow(10, _o(t));\n    }\n    function Mo(t, e, i) {\n        const s = Math.pow(10, i), n = Math.floor(t / s);\n        return Math.ceil(e / s) - n;\n    }\n    function wo(t, { min: e, max: i }) {\n        e = r(t.min, e);\n        const s = [], n = _o(e);\n        let o = function(t, e) {\n            let i = _o(e - t);\n            for(; Mo(t, e, i) > 10;)i++;\n            for(; Mo(t, e, i) < 10;)i--;\n            return Math.min(i, _o(t));\n        }(e, i), a = o < 0 ? Math.pow(10, Math.abs(o)) : 1;\n        const l = Math.pow(10, o), h = n > o ? Math.pow(10, n) : 0, c = Math.round((e - h) * a) / a, d = Math.floor((e - h) / l / 10) * l * 10;\n        let u = Math.floor((c - d) / Math.pow(10, o)), f = r(t.min, Math.round((h + d + u * Math.pow(10, o)) * a) / a);\n        for(; f < i;)s.push({\n            value: f,\n            major: vo(f),\n            significand: u\n        }), u >= 10 ? u = u < 15 ? 15 : 20 : u++, u >= 20 && (o++, u = 2, a = o >= 0 ? 1 : a), f = Math.round((h + d + u * Math.pow(10, o)) * a) / a;\n        const g = r(t.max, f);\n        return s.push({\n            value: g,\n            major: vo(g),\n            significand: u\n        }), s;\n    }\n    class ko extends Js {\n        static id = \"logarithmic\";\n        static defaults = {\n            ticks: {\n                callback: ae.formatters.logarithmic,\n                major: {\n                    enabled: !0\n                }\n            }\n        };\n        constructor(t){\n            super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._valueRange = 0;\n        }\n        parse(t, e) {\n            const i = bo.prototype.parse.apply(this, [\n                t,\n                e\n            ]);\n            if (0 !== i) return a(i) && i > 0 ? i : null;\n            this._zero = !0;\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!0);\n            this.min = a(t) ? Math.max(0, t) : null, this.max = a(e) ? Math.max(0, e) : null, this.options.beginAtZero && (this._zero = !0), this._zero && this.min !== this._suggestedMin && !a(this._userMin) && (this.min = t === yo(this.min, 0) ? yo(this.min, -1) : yo(this.min, 0)), this.handleTickRangeOptions();\n        }\n        handleTickRangeOptions() {\n            const { minDefined: t, maxDefined: e } = this.getUserBounds();\n            let i = this.min, s = this.max;\n            const n = (e)=>i = t ? i : e, o = (t)=>s = e ? s : t;\n            i === s && (i <= 0 ? (n(1), o(10)) : (n(yo(i, -1)), o(yo(s, 1)))), i <= 0 && n(yo(s, -1)), s <= 0 && o(yo(i, 1)), this.min = i, this.max = s;\n        }\n        buildTicks() {\n            const t = this.options, e = wo({\n                min: this._userMin,\n                max: this._userMax\n            }, this);\n            return \"ticks\" === t.bounds && j(e, this, \"value\"), t.reverse ? (e.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), e;\n        }\n        getLabelForValue(t) {\n            return void 0 === t ? \"0\" : ne(t, this.chart.options.locale, this.options.ticks.format);\n        }\n        configure() {\n            const t = this.min;\n            super.configure(), this._startValue = z(t), this._valueRange = z(this.max) - z(t);\n        }\n        getPixelForValue(t) {\n            return void 0 !== t && 0 !== t || (t = this.min), null === t || isNaN(t) ? NaN : this.getPixelForDecimal(t === this.min ? 0 : (z(t) - this._startValue) / this._valueRange);\n        }\n        getValueForPixel(t) {\n            const e = this.getDecimalForPixel(t);\n            return Math.pow(10, this._startValue + e * this._valueRange);\n        }\n    }\n    function So(t) {\n        const e = t.ticks;\n        if (e.display && t.display) {\n            const t = ki(e.backdropPadding);\n            return l(e.font && e.font.size, ue.font.size) + t.height;\n        }\n        return 0;\n    }\n    function Po(t, e, i, s, n) {\n        return t === s || t === n ? {\n            start: e - i / 2,\n            end: e + i / 2\n        } : t < s || t > n ? {\n            start: e - i,\n            end: e\n        } : {\n            start: e,\n            end: e + i\n        };\n    }\n    function Do(t) {\n        const e = {\n            l: t.left + t._padding.left,\n            r: t.right - t._padding.right,\n            t: t.top + t._padding.top,\n            b: t.bottom - t._padding.bottom\n        }, i = Object.assign({}, e), s = [], o = [], a = t._pointLabels.length, r = t.options.pointLabels, l = r.centerPointLabels ? C / a : 0;\n        for(let u = 0; u < a; u++){\n            const a = r.setContext(t.getPointLabelContext(u));\n            o[u] = a.padding;\n            const f = t.getPointPosition(u, t.drawingArea + o[u], l), g = Si(a.font), p = (h = t.ctx, c = g, d = n(d = t._pointLabels[u]) ? d : [\n                d\n            ], {\n                w: Oe(h, c.string, d),\n                h: d.length * c.lineHeight\n            });\n            s[u] = p;\n            const m = G(t.getIndexAngle(u) + l), b = Math.round(Y(m));\n            Co(i, e, m, Po(b, f.x, p.w, 0, 180), Po(b, f.y, p.h, 90, 270));\n        }\n        var h, c, d;\n        t.setCenterPoint(e.l - i.l, i.r - e.r, e.t - i.t, i.b - e.b), t._pointLabelItems = function(t, e, i) {\n            const s = [], n = t._pointLabels.length, o = t.options, { centerPointLabels: a, display: r } = o.pointLabels, l = {\n                extra: So(o) / 2,\n                additionalAngle: a ? C / n : 0\n            };\n            let h;\n            for(let o = 0; o < n; o++){\n                l.padding = i[o], l.size = e[o];\n                const n = Oo(t, o, l);\n                s.push(n), \"auto\" === r && (n.visible = Ao(n, h), n.visible && (h = n));\n            }\n            return s;\n        }(t, s, o);\n    }\n    function Co(t, e, i, s, n) {\n        const o = Math.abs(Math.sin(i)), a = Math.abs(Math.cos(i));\n        let r = 0, l = 0;\n        s.start < e.l ? (r = (e.l - s.start) / o, t.l = Math.min(t.l, e.l - r)) : s.end > e.r && (r = (s.end - e.r) / o, t.r = Math.max(t.r, e.r + r)), n.start < e.t ? (l = (e.t - n.start) / a, t.t = Math.min(t.t, e.t - l)) : n.end > e.b && (l = (n.end - e.b) / a, t.b = Math.max(t.b, e.b + l));\n    }\n    function Oo(t, e, i) {\n        const s = t.drawingArea, { extra: n, additionalAngle: o, padding: a, size: r } = i, l = t.getPointPosition(e, s + n + a, o), h = Math.round(Y(G(l.angle + E))), c = function(t, e, i) {\n            90 === i || 270 === i ? t -= e / 2 : (i > 270 || i < 90) && (t -= e);\n            return t;\n        }(l.y, r.h, h), d = function(t) {\n            if (0 === t || 180 === t) return \"center\";\n            if (t < 180) return \"left\";\n            return \"right\";\n        }(h), u = function(t, e, i) {\n            \"right\" === i ? t -= e : \"center\" === i && (t -= e / 2);\n            return t;\n        }(l.x, r.w, d);\n        return {\n            visible: !0,\n            x: l.x,\n            y: c,\n            textAlign: d,\n            left: u,\n            top: c,\n            right: u + r.w,\n            bottom: c + r.h\n        };\n    }\n    function Ao(t, e) {\n        if (!e) return !0;\n        const { left: i, top: s, right: n, bottom: o } = t;\n        return !(Re({\n            x: i,\n            y: s\n        }, e) || Re({\n            x: i,\n            y: o\n        }, e) || Re({\n            x: n,\n            y: s\n        }, e) || Re({\n            x: n,\n            y: o\n        }, e));\n    }\n    function To(t, e, i) {\n        const { left: n, top: o, right: a, bottom: r } = i, { backdropColor: l } = e;\n        if (!s(l)) {\n            const i = wi(e.borderRadius), s = ki(e.backdropPadding);\n            t.fillStyle = l;\n            const h = n - s.left, c = o - s.top, d = a - n + s.width, u = r - o + s.height;\n            Object.values(i).some((t)=>0 !== t) ? (t.beginPath(), He(t, {\n                x: h,\n                y: c,\n                w: d,\n                h: u,\n                radius: i\n            }), t.fill()) : t.fillRect(h, c, d, u);\n        }\n    }\n    function Lo(t, e, i, s) {\n        const { ctx: n } = t;\n        if (i) n.arc(t.xCenter, t.yCenter, e, 0, O);\n        else {\n            let i = t.getPointPosition(0, e);\n            n.moveTo(i.x, i.y);\n            for(let o = 1; o < s; o++)i = t.getPointPosition(o, e), n.lineTo(i.x, i.y);\n        }\n    }\n    class Eo extends bo {\n        static id = \"radialLinear\";\n        static defaults = {\n            display: !0,\n            animate: !0,\n            position: \"chartArea\",\n            angleLines: {\n                display: !0,\n                lineWidth: 1,\n                borderDash: [],\n                borderDashOffset: 0\n            },\n            grid: {\n                circular: !1\n            },\n            startAngle: 0,\n            ticks: {\n                showLabelBackdrop: !0,\n                callback: ae.formatters.numeric\n            },\n            pointLabels: {\n                backdropColor: void 0,\n                backdropPadding: 2,\n                display: !0,\n                font: {\n                    size: 10\n                },\n                callback: (t)=>t,\n                padding: 5,\n                centerPointLabels: !1\n            }\n        };\n        static defaultRoutes = {\n            \"angleLines.color\": \"borderColor\",\n            \"pointLabels.color\": \"color\",\n            \"ticks.color\": \"color\"\n        };\n        static descriptors = {\n            angleLines: {\n                _fallback: \"grid\"\n            }\n        };\n        constructor(t){\n            super(t), this.xCenter = void 0, this.yCenter = void 0, this.drawingArea = void 0, this._pointLabels = [], this._pointLabelItems = [];\n        }\n        setDimensions() {\n            const t = this._padding = ki(So(this.options) / 2), e = this.width = this.maxWidth - t.width, i = this.height = this.maxHeight - t.height;\n            this.xCenter = Math.floor(this.left + e / 2 + t.left), this.yCenter = Math.floor(this.top + i / 2 + t.top), this.drawingArea = Math.floor(Math.min(e, i) / 2);\n        }\n        determineDataLimits() {\n            const { min: t, max: e } = this.getMinMax(!1);\n            this.min = a(t) && !isNaN(t) ? t : 0, this.max = a(e) && !isNaN(e) ? e : 0, this.handleTickRangeOptions();\n        }\n        computeTickLimit() {\n            return Math.ceil(this.drawingArea / So(this.options));\n        }\n        generateTickLabels(t) {\n            bo.prototype.generateTickLabels.call(this, t), this._pointLabels = this.getLabels().map((t, e)=>{\n                const i = d(this.options.pointLabels.callback, [\n                    t,\n                    e\n                ], this);\n                return i || 0 === i ? i : \"\";\n            }).filter((t, e)=>this.chart.getDataVisibility(e));\n        }\n        fit() {\n            const t = this.options;\n            t.display && t.pointLabels.display ? Do(this) : this.setCenterPoint(0, 0, 0, 0);\n        }\n        setCenterPoint(t, e, i, s) {\n            this.xCenter += Math.floor((t - e) / 2), this.yCenter += Math.floor((i - s) / 2), this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(t, e, i, s));\n        }\n        getIndexAngle(t) {\n            return G(t * (O / (this._pointLabels.length || 1)) + $(this.options.startAngle || 0));\n        }\n        getDistanceFromCenterForValue(t) {\n            if (s(t)) return NaN;\n            const e = this.drawingArea / (this.max - this.min);\n            return this.options.reverse ? (this.max - t) * e : (t - this.min) * e;\n        }\n        getValueForDistanceFromCenter(t) {\n            if (s(t)) return NaN;\n            const e = t / (this.drawingArea / (this.max - this.min));\n            return this.options.reverse ? this.max - e : this.min + e;\n        }\n        getPointLabelContext(t) {\n            const e = this._pointLabels || [];\n            if (t >= 0 && t < e.length) {\n                const i = e[t];\n                return function(t, e, i) {\n                    return Ci(t, {\n                        label: i,\n                        index: e,\n                        type: \"pointLabel\"\n                    });\n                }(this.getContext(), t, i);\n            }\n        }\n        getPointPosition(t, e, i = 0) {\n            const s = this.getIndexAngle(t) - E + i;\n            return {\n                x: Math.cos(s) * e + this.xCenter,\n                y: Math.sin(s) * e + this.yCenter,\n                angle: s\n            };\n        }\n        getPointPositionForValue(t, e) {\n            return this.getPointPosition(t, this.getDistanceFromCenterForValue(e));\n        }\n        getBasePosition(t) {\n            return this.getPointPositionForValue(t || 0, this.getBaseValue());\n        }\n        getPointLabelPosition(t) {\n            const { left: e, top: i, right: s, bottom: n } = this._pointLabelItems[t];\n            return {\n                left: e,\n                top: i,\n                right: s,\n                bottom: n\n            };\n        }\n        drawBackground() {\n            const { backgroundColor: t, grid: { circular: e } } = this.options;\n            if (t) {\n                const i = this.ctx;\n                i.save(), i.beginPath(), Lo(this, this.getDistanceFromCenterForValue(this._endValue), e, this._pointLabels.length), i.closePath(), i.fillStyle = t, i.fill(), i.restore();\n            }\n        }\n        drawGrid() {\n            const t = this.ctx, e = this.options, { angleLines: i, grid: s, border: n } = e, o = this._pointLabels.length;\n            let a, r, l;\n            if (e.pointLabels.display && function(t, e) {\n                const { ctx: i, options: { pointLabels: s } } = t;\n                for(let n = e - 1; n >= 0; n--){\n                    const e = t._pointLabelItems[n];\n                    if (!e.visible) continue;\n                    const o = s.setContext(t.getPointLabelContext(n));\n                    To(i, o, e);\n                    const a = Si(o.font), { x: r, y: l, textAlign: h } = e;\n                    Ne(i, t._pointLabels[n], r, l + a.lineHeight / 2, a, {\n                        color: o.color,\n                        textAlign: h,\n                        textBaseline: \"middle\"\n                    });\n                }\n            }(this, o), s.display && this.ticks.forEach((t, e)=>{\n                if (0 !== e) {\n                    r = this.getDistanceFromCenterForValue(t.value);\n                    const i = this.getContext(e), a = s.setContext(i), l = n.setContext(i);\n                    !function(t, e, i, s, n) {\n                        const o = t.ctx, a = e.circular, { color: r, lineWidth: l } = e;\n                        !a && !s || !r || !l || i < 0 || (o.save(), o.strokeStyle = r, o.lineWidth = l, o.setLineDash(n.dash), o.lineDashOffset = n.dashOffset, o.beginPath(), Lo(t, i, a, s), o.closePath(), o.stroke(), o.restore());\n                    }(this, a, r, o, l);\n                }\n            }), i.display) {\n                for(t.save(), a = o - 1; a >= 0; a--){\n                    const s = i.setContext(this.getPointLabelContext(a)), { color: n, lineWidth: o } = s;\n                    o && n && (t.lineWidth = o, t.strokeStyle = n, t.setLineDash(s.borderDash), t.lineDashOffset = s.borderDashOffset, r = this.getDistanceFromCenterForValue(e.ticks.reverse ? this.min : this.max), l = this.getPointPosition(a, r), t.beginPath(), t.moveTo(this.xCenter, this.yCenter), t.lineTo(l.x, l.y), t.stroke());\n                }\n                t.restore();\n            }\n        }\n        drawBorder() {}\n        drawLabels() {\n            const t = this.ctx, e = this.options, i = e.ticks;\n            if (!i.display) return;\n            const s = this.getIndexAngle(0);\n            let n, o;\n            t.save(), t.translate(this.xCenter, this.yCenter), t.rotate(s), t.textAlign = \"center\", t.textBaseline = \"middle\", this.ticks.forEach((s, a)=>{\n                if (0 === a && !e.reverse) return;\n                const r = i.setContext(this.getContext(a)), l = Si(r.font);\n                if (n = this.getDistanceFromCenterForValue(this.ticks[a].value), r.showLabelBackdrop) {\n                    t.font = l.string, o = t.measureText(s.label).width, t.fillStyle = r.backdropColor;\n                    const e = ki(r.backdropPadding);\n                    t.fillRect(-o / 2 - e.left, -n - l.size / 2 - e.top, o + e.width, l.size + e.height);\n                }\n                Ne(t, s.label, 0, -n, l, {\n                    color: r.color,\n                    strokeColor: r.textStrokeColor,\n                    strokeWidth: r.textStrokeWidth\n                });\n            }), t.restore();\n        }\n        drawTitle() {}\n    }\n    const Ro = {\n        millisecond: {\n            common: !0,\n            size: 1,\n            steps: 1e3\n        },\n        second: {\n            common: !0,\n            size: 1e3,\n            steps: 60\n        },\n        minute: {\n            common: !0,\n            size: 6e4,\n            steps: 60\n        },\n        hour: {\n            common: !0,\n            size: 36e5,\n            steps: 24\n        },\n        day: {\n            common: !0,\n            size: 864e5,\n            steps: 30\n        },\n        week: {\n            common: !1,\n            size: 6048e5,\n            steps: 4\n        },\n        month: {\n            common: !0,\n            size: 2628e6,\n            steps: 12\n        },\n        quarter: {\n            common: !1,\n            size: 7884e6,\n            steps: 4\n        },\n        year: {\n            common: !0,\n            size: 3154e7\n        }\n    }, Io = Object.keys(Ro);\n    function zo(t, e) {\n        return t - e;\n    }\n    function Fo(t, e) {\n        if (s(e)) return null;\n        const i = t._adapter, { parser: n, round: o, isoWeekday: r } = t._parseOpts;\n        let l = e;\n        return \"function\" == typeof n && (l = n(l)), a(l) || (l = \"string\" == typeof n ? i.parse(l, n) : i.parse(l)), null === l ? null : (o && (l = \"week\" !== o || !N(r) && !0 !== r ? i.startOf(l, o) : i.startOf(l, \"isoWeek\", r)), +l);\n    }\n    function Vo(t, e, i, s) {\n        const n = Io.length;\n        for(let o = Io.indexOf(t); o < n - 1; ++o){\n            const t = Ro[Io[o]], n = t.steps ? t.steps : Number.MAX_SAFE_INTEGER;\n            if (t.common && Math.ceil((i - e) / (n * t.size)) <= s) return Io[o];\n        }\n        return Io[n - 1];\n    }\n    function Bo(t, e, i) {\n        if (i) {\n            if (i.length) {\n                const { lo: s, hi: n } = et(i, e);\n                t[i[s] >= e ? i[s] : i[n]] = !0;\n            }\n        } else t[e] = !0;\n    }\n    function Wo(t, e, i) {\n        const s = [], n = {}, o = e.length;\n        let a, r;\n        for(a = 0; a < o; ++a)r = e[a], n[r] = a, s.push({\n            value: r,\n            major: !1\n        });\n        return 0 !== o && i ? function(t, e, i, s) {\n            const n = t._adapter, o = +n.startOf(e[0].value, s), a = e[e.length - 1].value;\n            let r, l;\n            for(r = o; r <= a; r = +n.add(r, 1, s))l = i[r], l >= 0 && (e[l].major = !0);\n            return e;\n        }(t, s, n, i) : s;\n    }\n    class No extends Js {\n        static id = \"time\";\n        static defaults = {\n            bounds: \"data\",\n            adapters: {},\n            time: {\n                parser: !1,\n                unit: !1,\n                round: !1,\n                isoWeekday: !1,\n                minUnit: \"millisecond\",\n                displayFormats: {}\n            },\n            ticks: {\n                source: \"auto\",\n                callback: !1,\n                major: {\n                    enabled: !1\n                }\n            }\n        };\n        constructor(t){\n            super(t), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            }, this._unit = \"day\", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;\n        }\n        init(t, e = {}) {\n            const i = t.time || (t.time = {}), s = this._adapter = new Rn._date(t.adapters.date);\n            s.init(e), x(i.displayFormats, s.formats()), this._parseOpts = {\n                parser: i.parser,\n                round: i.round,\n                isoWeekday: i.isoWeekday\n            }, super.init(t), this._normalized = e.normalized;\n        }\n        parse(t, e) {\n            return void 0 === t ? null : Fo(this, t);\n        }\n        beforeLayout() {\n            super.beforeLayout(), this._cache = {\n                data: [],\n                labels: [],\n                all: []\n            };\n        }\n        determineDataLimits() {\n            const t = this.options, e = this._adapter, i = t.time.unit || \"day\";\n            let { min: s, max: n, minDefined: o, maxDefined: r } = this.getUserBounds();\n            function l(t) {\n                o || isNaN(t.min) || (s = Math.min(s, t.min)), r || isNaN(t.max) || (n = Math.max(n, t.max));\n            }\n            o && r || (l(this._getLabelBounds()), \"ticks\" === t.bounds && \"labels\" === t.ticks.source || l(this.getMinMax(!1))), s = a(s) && !isNaN(s) ? s : +e.startOf(Date.now(), i), n = a(n) && !isNaN(n) ? n : +e.endOf(Date.now(), i) + 1, this.min = Math.min(s, n - 1), this.max = Math.max(s + 1, n);\n        }\n        _getLabelBounds() {\n            const t = this.getLabelTimestamps();\n            let e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;\n            return t.length && (e = t[0], i = t[t.length - 1]), {\n                min: e,\n                max: i\n            };\n        }\n        buildTicks() {\n            const t = this.options, e = t.time, i = t.ticks, s = \"labels\" === i.source ? this.getLabelTimestamps() : this._generate();\n            \"ticks\" === t.bounds && s.length && (this.min = this._userMin || s[0], this.max = this._userMax || s[s.length - 1]);\n            const n = this.min, o = nt(s, n, this.max);\n            return this._unit = e.unit || (i.autoSkip ? Vo(e.minUnit, this.min, this.max, this._getLabelCapacity(n)) : function(t, e, i, s, n) {\n                for(let o = Io.length - 1; o >= Io.indexOf(i); o--){\n                    const i = Io[o];\n                    if (Ro[i].common && t._adapter.diff(n, s, i) >= e - 1) return i;\n                }\n                return Io[i ? Io.indexOf(i) : 0];\n            }(this, o.length, e.minUnit, this.min, this.max)), this._majorUnit = i.major.enabled && \"year\" !== this._unit ? function(t) {\n                for(let e = Io.indexOf(t) + 1, i = Io.length; e < i; ++e)if (Ro[Io[e]].common) return Io[e];\n            }(this._unit) : void 0, this.initOffsets(s), t.reverse && o.reverse(), Wo(this, o, this._majorUnit);\n        }\n        afterAutoSkip() {\n            this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t)=>+t.value));\n        }\n        initOffsets(t = []) {\n            let e, i, s = 0, n = 0;\n            this.options.offset && t.length && (e = this.getDecimalForValue(t[0]), s = 1 === t.length ? 1 - e : (this.getDecimalForValue(t[1]) - e) / 2, i = this.getDecimalForValue(t[t.length - 1]), n = 1 === t.length ? i : (i - this.getDecimalForValue(t[t.length - 2])) / 2);\n            const o = t.length < 3 ? .5 : .25;\n            s = J(s, 0, o), n = J(n, 0, o), this._offsets = {\n                start: s,\n                end: n,\n                factor: 1 / (s + 1 + n)\n            };\n        }\n        _generate() {\n            const t = this._adapter, e = this.min, i = this.max, s = this.options, n = s.time, o = n.unit || Vo(n.minUnit, e, i, this._getLabelCapacity(e)), a = l(s.ticks.stepSize, 1), r = \"week\" === o && n.isoWeekday, h = N(r) || !0 === r, c = {};\n            let d, u, f = e;\n            if (h && (f = +t.startOf(f, \"isoWeek\", r)), f = +t.startOf(f, h ? \"day\" : o), t.diff(i, e, o) > 1e5 * a) throw new Error(e + \" and \" + i + \" are too far apart with stepSize of \" + a + \" \" + o);\n            const g = \"data\" === s.ticks.source && this.getDataTimestamps();\n            for(d = f, u = 0; d < i; d = +t.add(d, a, o), u++)Bo(c, d, g);\n            return d !== i && \"ticks\" !== s.bounds && 1 !== u || Bo(c, d, g), Object.keys(c).sort(zo).map((t)=>+t);\n        }\n        getLabelForValue(t) {\n            const e = this._adapter, i = this.options.time;\n            return i.tooltipFormat ? e.format(t, i.tooltipFormat) : e.format(t, i.displayFormats.datetime);\n        }\n        format(t, e) {\n            const i = this.options.time.displayFormats, s = this._unit, n = e || i[s];\n            return this._adapter.format(t, n);\n        }\n        _tickFormatFunction(t, e, i, s) {\n            const n = this.options, o = n.ticks.callback;\n            if (o) return d(o, [\n                t,\n                e,\n                i\n            ], this);\n            const a = n.time.displayFormats, r = this._unit, l = this._majorUnit, h = r && a[r], c = l && a[l], u = i[e], f = l && c && u && u.major;\n            return this._adapter.format(t, s || (f ? c : h));\n        }\n        generateTickLabels(t) {\n            let e, i, s;\n            for(e = 0, i = t.length; e < i; ++e)s = t[e], s.label = this._tickFormatFunction(s.value, e, t);\n        }\n        getDecimalForValue(t) {\n            return null === t ? NaN : (t - this.min) / (this.max - this.min);\n        }\n        getPixelForValue(t) {\n            const e = this._offsets, i = this.getDecimalForValue(t);\n            return this.getPixelForDecimal((e.start + i) * e.factor);\n        }\n        getValueForPixel(t) {\n            const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n            return this.min + i * (this.max - this.min);\n        }\n        _getLabelSize(t) {\n            const e = this.options.ticks, i = this.ctx.measureText(t).width, s = $(this.isHorizontal() ? e.maxRotation : e.minRotation), n = Math.cos(s), o = Math.sin(s), a = this._resolveTickFontOptions(0).size;\n            return {\n                w: i * n + a * o,\n                h: i * o + a * n\n            };\n        }\n        _getLabelCapacity(t) {\n            const e = this.options.time, i = e.displayFormats, s = i[e.unit] || i.millisecond, n = this._tickFormatFunction(t, 0, Wo(this, [\n                t\n            ], this._majorUnit), s), o = this._getLabelSize(n), a = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;\n            return a > 0 ? a : 1;\n        }\n        getDataTimestamps() {\n            let t, e, i = this._cache.data || [];\n            if (i.length) return i;\n            const s = this.getMatchingVisibleMetas();\n            if (this._normalized && s.length) return this._cache.data = s[0].controller.getAllParsedValues(this);\n            for(t = 0, e = s.length; t < e; ++t)i = i.concat(s[t].controller.getAllParsedValues(this));\n            return this._cache.data = this.normalize(i);\n        }\n        getLabelTimestamps() {\n            const t = this._cache.labels || [];\n            let e, i;\n            if (t.length) return t;\n            const s = this.getLabels();\n            for(e = 0, i = s.length; e < i; ++e)t.push(Fo(this, s[e]));\n            return this._cache.labels = this._normalized ? t : this.normalize(t);\n        }\n        normalize(t) {\n            return lt(t.sort(zo));\n        }\n    }\n    function Ho(t, e, i) {\n        let s, n, o, a, r = 0, l = t.length - 1;\n        i ? (e >= t[r].pos && e <= t[l].pos && ({ lo: r, hi: l } = it(t, \"pos\", e)), { pos: s, time: o } = t[r], { pos: n, time: a } = t[l]) : (e >= t[r].time && e <= t[l].time && ({ lo: r, hi: l } = it(t, \"time\", e)), { time: s, pos: o } = t[r], { time: n, pos: a } = t[l]);\n        const h = n - s;\n        return h ? o + (a - o) * (e - s) / h : o;\n    }\n    var jo = Object.freeze({\n        __proto__: null,\n        CategoryScale: class extends Js {\n            static id = \"category\";\n            static defaults = {\n                ticks: {\n                    callback: po\n                }\n            };\n            constructor(t){\n                super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];\n            }\n            init(t) {\n                const e = this._addedLabels;\n                if (e.length) {\n                    const t = this.getLabels();\n                    for (const { index: i, label: s } of e)t[i] === s && t.splice(i, 1);\n                    this._addedLabels = [];\n                }\n                super.init(t);\n            }\n            parse(t, e) {\n                if (s(t)) return null;\n                const i = this.getLabels();\n                return ((t, e)=>null === t ? null : J(Math.round(t), 0, e))(e = isFinite(e) && i[e] === t ? e : go(i, t, l(e, t), this._addedLabels), i.length - 1);\n            }\n            determineDataLimits() {\n                const { minDefined: t, maxDefined: e } = this.getUserBounds();\n                let { min: i, max: s } = this.getMinMax(!0);\n                \"ticks\" === this.options.bounds && (t || (i = 0), e || (s = this.getLabels().length - 1)), this.min = i, this.max = s;\n            }\n            buildTicks() {\n                const t = this.min, e = this.max, i = this.options.offset, s = [];\n                let n = this.getLabels();\n                n = 0 === t && e === n.length - 1 ? n : n.slice(t, e + 1), this._valueRange = Math.max(n.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? .5 : 0);\n                for(let i = t; i <= e; i++)s.push({\n                    value: i\n                });\n                return s;\n            }\n            getLabelForValue(t) {\n                return po.call(this, t);\n            }\n            configure() {\n                super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);\n            }\n            getPixelForValue(t) {\n                return \"number\" != typeof t && (t = this.parse(t)), null === t ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);\n            }\n            getPixelForTick(t) {\n                const e = this.ticks;\n                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t].value);\n            }\n            getValueForPixel(t) {\n                return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);\n            }\n            getBasePixel() {\n                return this.bottom;\n            }\n        },\n        LinearScale: xo,\n        LogarithmicScale: ko,\n        RadialLinearScale: Eo,\n        TimeScale: No,\n        TimeSeriesScale: class extends No {\n            static id = \"timeseries\";\n            static defaults = No.defaults;\n            constructor(t){\n                super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;\n            }\n            initOffsets() {\n                const t = this._getTimestampsForTable(), e = this._table = this.buildLookupTable(t);\n                this._minPos = Ho(e, this.min), this._tableRange = Ho(e, this.max) - this._minPos, super.initOffsets(t);\n            }\n            buildLookupTable(t) {\n                const { min: e, max: i } = this, s = [], n = [];\n                let o, a, r, l, h;\n                for(o = 0, a = t.length; o < a; ++o)l = t[o], l >= e && l <= i && s.push(l);\n                if (s.length < 2) return [\n                    {\n                        time: e,\n                        pos: 0\n                    },\n                    {\n                        time: i,\n                        pos: 1\n                    }\n                ];\n                for(o = 0, a = s.length; o < a; ++o)h = s[o + 1], r = s[o - 1], l = s[o], Math.round((h + r) / 2) !== l && n.push({\n                    time: l,\n                    pos: o / (a - 1)\n                });\n                return n;\n            }\n            _generate() {\n                const t = this.min, e = this.max;\n                let i = super.getDataTimestamps();\n                return i.includes(t) && i.length || i.splice(0, 0, t), i.includes(e) && 1 !== i.length || i.push(e), i.sort((t, e)=>t - e);\n            }\n            _getTimestampsForTable() {\n                let t = this._cache.all || [];\n                if (t.length) return t;\n                const e = this.getDataTimestamps(), i = this.getLabelTimestamps();\n                return t = e.length && i.length ? this.normalize(e.concat(i)) : e.length ? e : i, t = this._cache.all = t, t;\n            }\n            getDecimalForValue(t) {\n                return (Ho(this._table, t) - this._minPos) / this._tableRange;\n            }\n            getValueForPixel(t) {\n                const e = this._offsets, i = this.getDecimalForPixel(t) / e.factor - e.end;\n                return Ho(this._table, i * this._tableRange + this._minPos, !0);\n            }\n        }\n    });\n    const $o = [\n        \"rgb(54, 162, 235)\",\n        \"rgb(255, 99, 132)\",\n        \"rgb(255, 159, 64)\",\n        \"rgb(255, 205, 86)\",\n        \"rgb(75, 192, 192)\",\n        \"rgb(153, 102, 255)\",\n        \"rgb(201, 203, 207)\"\n    ], Yo = $o.map((t)=>t.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\n    function Uo(t) {\n        return $o[t % $o.length];\n    }\n    function Xo(t) {\n        return Yo[t % Yo.length];\n    }\n    function qo(t) {\n        let e = 0;\n        return (i, s)=>{\n            const n = t.getDatasetMeta(s).controller;\n            n instanceof jn ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Uo(e++)), e;\n            }(i, e) : n instanceof $n ? e = function(t, e) {\n                return t.backgroundColor = t.data.map(()=>Xo(e++)), e;\n            }(i, e) : n && (e = function(t, e) {\n                return t.borderColor = Uo(e), t.backgroundColor = Xo(e), ++e;\n            }(i, e));\n        };\n    }\n    function Ko(t) {\n        let e;\n        for(e in t)if (t[e].borderColor || t[e].backgroundColor) return !0;\n        return !1;\n    }\n    var Go = {\n        id: \"colors\",\n        defaults: {\n            enabled: !0,\n            forceOverride: !1\n        },\n        beforeLayout (t, e, i) {\n            if (!i.enabled) return;\n            const { data: { datasets: s }, options: n } = t.config, { elements: o } = n;\n            if (!i.forceOverride && (Ko(s) || (a = n) && (a.borderColor || a.backgroundColor) || o && Ko(o))) return;\n            var a;\n            const r = qo(t);\n            s.forEach(r);\n        }\n    };\n    function Zo(t) {\n        if (t._decimated) {\n            const e = t._data;\n            delete t._decimated, delete t._data, Object.defineProperty(t, \"data\", {\n                configurable: !0,\n                enumerable: !0,\n                writable: !0,\n                value: e\n            });\n        }\n    }\n    function Jo(t) {\n        t.data.datasets.forEach((t)=>{\n            Zo(t);\n        });\n    }\n    var Qo = {\n        id: \"decimation\",\n        defaults: {\n            algorithm: \"min-max\",\n            enabled: !1\n        },\n        beforeElementsUpdate: (t, e, i)=>{\n            if (!i.enabled) return void Jo(t);\n            const n = t.width;\n            t.data.datasets.forEach((e, o)=>{\n                const { _data: a, indexAxis: r } = e, l = t.getDatasetMeta(o), h = a || e.data;\n                if (\"y\" === Pi([\n                    r,\n                    t.options.indexAxis\n                ])) return;\n                if (!l.controller.supportsDecimation) return;\n                const c = t.scales[l.xAxisID];\n                if (\"linear\" !== c.type && \"time\" !== c.type) return;\n                if (t.options.parsing) return;\n                let { start: d, count: u } = function(t, e) {\n                    const i = e.length;\n                    let s, n = 0;\n                    const { iScale: o } = t, { min: a, max: r, minDefined: l, maxDefined: h } = o.getUserBounds();\n                    return l && (n = J(it(e, o.axis, a).lo, 0, i - 1)), s = h ? J(it(e, o.axis, r).hi + 1, n, i) - n : i - n, {\n                        start: n,\n                        count: s\n                    };\n                }(l, h);\n                if (u <= (i.threshold || 4 * n)) return void Zo(e);\n                let f;\n                switch(s(a) && (e._data = h, delete e.data, Object.defineProperty(e, \"data\", {\n                    configurable: !0,\n                    enumerable: !0,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(t) {\n                        this._data = t;\n                    }\n                })), i.algorithm){\n                    case \"lttb\":\n                        f = function(t, e, i, s, n) {\n                            const o = n.samples || s;\n                            if (o >= i) return t.slice(e, e + i);\n                            const a = [], r = (i - 2) / (o - 2);\n                            let l = 0;\n                            const h = e + i - 1;\n                            let c, d, u, f, g, p = e;\n                            for(a[l++] = t[p], c = 0; c < o - 2; c++){\n                                let s, n = 0, o = 0;\n                                const h = Math.floor((c + 1) * r) + 1 + e, m = Math.min(Math.floor((c + 2) * r) + 1, i) + e, b = m - h;\n                                for(s = h; s < m; s++)n += t[s].x, o += t[s].y;\n                                n /= b, o /= b;\n                                const x = Math.floor(c * r) + 1 + e, _ = Math.min(Math.floor((c + 1) * r) + 1, i) + e, { x: y, y: v } = t[p];\n                                for(u = f = -1, s = x; s < _; s++)f = .5 * Math.abs((y - n) * (t[s].y - v) - (y - t[s].x) * (o - v)), f > u && (u = f, d = t[s], g = s);\n                                a[l++] = d, p = g;\n                            }\n                            return a[l++] = t[h], a;\n                        }(h, d, u, n, i);\n                        break;\n                    case \"min-max\":\n                        f = function(t, e, i, n) {\n                            let o, a, r, l, h, c, d, u, f, g, p = 0, m = 0;\n                            const b = [], x = e + i - 1, _ = t[e].x, y = t[x].x - _;\n                            for(o = e; o < e + i; ++o){\n                                a = t[o], r = (a.x - _) / y * n, l = a.y;\n                                const e = 0 | r;\n                                if (e === h) l < f ? (f = l, c = o) : l > g && (g = l, d = o), p = (m * p + a.x) / ++m;\n                                else {\n                                    const i = o - 1;\n                                    if (!s(c) && !s(d)) {\n                                        const e = Math.min(c, d), s = Math.max(c, d);\n                                        e !== u && e !== i && b.push({\n                                            ...t[e],\n                                            x: p\n                                        }), s !== u && s !== i && b.push({\n                                            ...t[s],\n                                            x: p\n                                        });\n                                    }\n                                    o > 0 && i !== u && b.push(t[i]), b.push(a), h = e, m = 0, f = g = l, c = d = u = o;\n                                }\n                            }\n                            return b;\n                        }(h, d, u, n);\n                        break;\n                    default:\n                        throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`);\n                }\n                e._decimated = f;\n            });\n        },\n        destroy (t) {\n            Jo(t);\n        }\n    };\n    function ta(t, e, i, s) {\n        if (s) return;\n        let n = e[t], o = i[t];\n        return \"angle\" === t && (n = G(n), o = G(o)), {\n            property: t,\n            start: n,\n            end: o\n        };\n    }\n    function ea(t, e, i) {\n        for(; e > t; e--){\n            const t = i[e];\n            if (!isNaN(t.x) && !isNaN(t.y)) break;\n        }\n        return e;\n    }\n    function ia(t, e, i, s) {\n        return t && e ? s(t[i], e[i]) : t ? t[i] : e ? e[i] : 0;\n    }\n    function sa(t, e) {\n        let i = [], s = !1;\n        return n(t) ? (s = !0, i = t) : i = function(t, e) {\n            const { x: i = null, y: s = null } = t || {}, n = e.points, o = [];\n            return e.segments.forEach(({ start: t, end: e })=>{\n                e = ea(t, e, n);\n                const a = n[t], r = n[e];\n                null !== s ? (o.push({\n                    x: a.x,\n                    y: s\n                }), o.push({\n                    x: r.x,\n                    y: s\n                })) : null !== i && (o.push({\n                    x: i,\n                    y: a.y\n                }), o.push({\n                    x: i,\n                    y: r.y\n                }));\n            }), o;\n        }(t, e), i.length ? new no({\n            points: i,\n            options: {\n                tension: 0\n            },\n            _loop: s,\n            _fullLoop: s\n        }) : null;\n    }\n    function na(t) {\n        return t && !1 !== t.fill;\n    }\n    function oa(t, e, i) {\n        let s = t[e].fill;\n        const n = [\n            e\n        ];\n        let o;\n        if (!i) return s;\n        for(; !1 !== s && -1 === n.indexOf(s);){\n            if (!a(s)) return s;\n            if (o = t[s], !o) return !1;\n            if (o.visible) return s;\n            n.push(s), s = o.fill;\n        }\n        return !1;\n    }\n    function aa(t, e, i) {\n        const s = function(t) {\n            const e = t.options, i = e.fill;\n            let s = l(i && i.target, i);\n            void 0 === s && (s = !!e.backgroundColor);\n            if (!1 === s || null === s) return !1;\n            if (!0 === s) return \"origin\";\n            return s;\n        }(t);\n        if (o(s)) return !isNaN(s.value) && s;\n        let n = parseFloat(s);\n        return a(n) && Math.floor(n) === n ? function(t, e, i, s) {\n            \"-\" !== t && \"+\" !== t || (i = e + i);\n            if (i === e || i < 0 || i >= s) return !1;\n            return i;\n        }(s[0], e, n, i) : [\n            \"origin\",\n            \"start\",\n            \"end\",\n            \"stack\",\n            \"shape\"\n        ].indexOf(s) >= 0 && s;\n    }\n    function ra(t, e, i) {\n        const s = [];\n        for(let n = 0; n < i.length; n++){\n            const o = i[n], { first: a, last: r, point: l } = la(o, e, \"x\");\n            if (!(!l || a && r)) {\n                if (a) s.unshift(l);\n                else if (t.push(l), !r) break;\n            }\n        }\n        t.push(...s);\n    }\n    function la(t, e, i) {\n        const s = t.interpolate(e, i);\n        if (!s) return {};\n        const n = s[i], o = t.segments, a = t.points;\n        let r = !1, l = !1;\n        for(let t = 0; t < o.length; t++){\n            const e = o[t], s = a[e.start][i], h = a[e.end][i];\n            if (tt(n, s, h)) {\n                r = n === s, l = n === h;\n                break;\n            }\n        }\n        return {\n            first: r,\n            last: l,\n            point: s\n        };\n    }\n    class ha {\n        constructor(t){\n            this.x = t.x, this.y = t.y, this.radius = t.radius;\n        }\n        pathSegment(t, e, i) {\n            const { x: s, y: n, radius: o } = this;\n            return e = e || {\n                start: 0,\n                end: O\n            }, t.arc(s, n, o, e.end, e.start, !0), !i.bounds;\n        }\n        interpolate(t) {\n            const { x: e, y: i, radius: s } = this, n = t.angle;\n            return {\n                x: e + Math.cos(n) * s,\n                y: i + Math.sin(n) * s,\n                angle: n\n            };\n        }\n    }\n    function ca(t) {\n        const { chart: e, fill: i, line: s } = t;\n        if (a(i)) return function(t, e) {\n            const i = t.getDatasetMeta(e), s = i && t.isDatasetVisible(e);\n            return s ? i.dataset : null;\n        }(e, i);\n        if (\"stack\" === i) return function(t) {\n            const { scale: e, index: i, line: s } = t, n = [], o = s.segments, a = s.points, r = function(t, e) {\n                const i = [], s = t.getMatchingVisibleMetas(\"line\");\n                for(let t = 0; t < s.length; t++){\n                    const n = s[t];\n                    if (n.index === e) break;\n                    n.hidden || i.unshift(n.dataset);\n                }\n                return i;\n            }(e, i);\n            r.push(sa({\n                x: null,\n                y: e.bottom\n            }, s));\n            for(let t = 0; t < o.length; t++){\n                const e = o[t];\n                for(let t = e.start; t <= e.end; t++)ra(n, a[t], r);\n            }\n            return new no({\n                points: n,\n                options: {}\n            });\n        }(t);\n        if (\"shape\" === i) return !0;\n        const n = function(t) {\n            const e = t.scale || {};\n            if (e.getPointPositionForValue) return function(t) {\n                const { scale: e, fill: i } = t, s = e.options, n = e.getLabels().length, a = s.reverse ? e.max : e.min, r = function(t, e, i) {\n                    let s;\n                    return s = \"start\" === t ? i : \"end\" === t ? e.options.reverse ? e.min : e.max : o(t) ? t.value : e.getBaseValue(), s;\n                }(i, e, a), l = [];\n                if (s.grid.circular) {\n                    const t = e.getPointPositionForValue(0, a);\n                    return new ha({\n                        x: t.x,\n                        y: t.y,\n                        radius: e.getDistanceFromCenterForValue(r)\n                    });\n                }\n                for(let t = 0; t < n; ++t)l.push(e.getPointPositionForValue(t, r));\n                return l;\n            }(t);\n            return function(t) {\n                const { scale: e = {}, fill: i } = t, s = function(t, e) {\n                    let i = null;\n                    return \"start\" === t ? i = e.bottom : \"end\" === t ? i = e.top : o(t) ? i = e.getPixelForValue(t.value) : e.getBasePixel && (i = e.getBasePixel()), i;\n                }(i, e);\n                if (a(s)) {\n                    const t = e.isHorizontal();\n                    return {\n                        x: t ? s : null,\n                        y: t ? null : s\n                    };\n                }\n                return null;\n            }(t);\n        }(t);\n        return n instanceof ha ? n : sa(n, s);\n    }\n    function da(t, e, i) {\n        const s = ca(e), { line: n, scale: o, axis: a } = e, r = n.options, l = r.fill, h = r.backgroundColor, { above: c = h, below: d = h } = l || {};\n        s && n.points.length && (Ie(t, i), function(t, e) {\n            const { line: i, target: s, above: n, below: o, area: a, scale: r } = e, l = i._loop ? \"angle\" : e.axis;\n            t.save(), \"x\" === l && o !== n && (ua(t, s, a.top), fa(t, {\n                line: i,\n                target: s,\n                color: n,\n                scale: r,\n                property: l\n            }), t.restore(), t.save(), ua(t, s, a.bottom));\n            fa(t, {\n                line: i,\n                target: s,\n                color: o,\n                scale: r,\n                property: l\n            }), t.restore();\n        }(t, {\n            line: n,\n            target: s,\n            above: c,\n            below: d,\n            area: i,\n            scale: o,\n            axis: a\n        }), ze(t));\n    }\n    function ua(t, e, i) {\n        const { segments: s, points: n } = e;\n        let o = !0, a = !1;\n        t.beginPath();\n        for (const r of s){\n            const { start: s, end: l } = r, h = n[s], c = n[ea(s, l, n)];\n            o ? (t.moveTo(h.x, h.y), o = !1) : (t.lineTo(h.x, i), t.lineTo(h.x, h.y)), a = !!e.pathSegment(t, r, {\n                move: a\n            }), a ? t.closePath() : t.lineTo(c.x, i);\n        }\n        t.lineTo(e.first().x, i), t.closePath(), t.clip();\n    }\n    function fa(t, e) {\n        const { line: i, target: s, property: n, color: o, scale: a } = e, r = function(t, e, i) {\n            const s = t.segments, n = t.points, o = e.points, a = [];\n            for (const t of s){\n                let { start: s, end: r } = t;\n                r = ea(s, r, n);\n                const l = ta(i, n[s], n[r], t.loop);\n                if (!e.segments) {\n                    a.push({\n                        source: t,\n                        target: l,\n                        start: n[s],\n                        end: n[r]\n                    });\n                    continue;\n                }\n                const h = Ii(e, l);\n                for (const e of h){\n                    const s = ta(i, o[e.start], o[e.end], e.loop), r = Ri(t, n, s);\n                    for (const t of r)a.push({\n                        source: t,\n                        target: e,\n                        start: {\n                            [i]: ia(l, s, \"start\", Math.max)\n                        },\n                        end: {\n                            [i]: ia(l, s, \"end\", Math.min)\n                        }\n                    });\n                }\n            }\n            return a;\n        }(i, s, n);\n        for (const { source: e, target: l, start: h, end: c } of r){\n            const { style: { backgroundColor: r = o } = {} } = e, d = !0 !== s;\n            t.save(), t.fillStyle = r, ga(t, a, d && ta(n, h, c)), t.beginPath();\n            const u = !!i.pathSegment(t, e);\n            let f;\n            if (d) {\n                u ? t.closePath() : pa(t, s, c, n);\n                const e = !!s.pathSegment(t, l, {\n                    move: u,\n                    reverse: !0\n                });\n                f = u && e, f || pa(t, s, h, n);\n            }\n            t.closePath(), t.fill(f ? \"evenodd\" : \"nonzero\"), t.restore();\n        }\n    }\n    function ga(t, e, i) {\n        const { top: s, bottom: n } = e.chart.chartArea, { property: o, start: a, end: r } = i || {};\n        \"x\" === o && (t.beginPath(), t.rect(a, s, r - a, n - s), t.clip());\n    }\n    function pa(t, e, i, s) {\n        const n = e.interpolate(i, s);\n        n && t.lineTo(n.x, n.y);\n    }\n    var ma = {\n        id: \"filler\",\n        afterDatasetsUpdate (t, e, i) {\n            const s = (t.data.datasets || []).length, n = [];\n            let o, a, r, l;\n            for(a = 0; a < s; ++a)o = t.getDatasetMeta(a), r = o.dataset, l = null, r && r.options && r instanceof no && (l = {\n                visible: t.isDatasetVisible(a),\n                index: a,\n                fill: aa(r, a, s),\n                chart: t,\n                axis: o.controller.options.indexAxis,\n                scale: o.vScale,\n                line: r\n            }), o.$filler = l, n.push(l);\n            for(a = 0; a < s; ++a)l = n[a], l && !1 !== l.fill && (l.fill = oa(n, a, i.propagate));\n        },\n        beforeDraw (t, e, i) {\n            const s = \"beforeDraw\" === i.drawTime, n = t.getSortedVisibleDatasetMetas(), o = t.chartArea;\n            for(let e = n.length - 1; e >= 0; --e){\n                const i = n[e].$filler;\n                i && (i.line.updateControlPoints(o, i.axis), s && i.fill && da(t.ctx, i, o));\n            }\n        },\n        beforeDatasetsDraw (t, e, i) {\n            if (\"beforeDatasetsDraw\" !== i.drawTime) return;\n            const s = t.getSortedVisibleDatasetMetas();\n            for(let e = s.length - 1; e >= 0; --e){\n                const i = s[e].$filler;\n                na(i) && da(t.ctx, i, t.chartArea);\n            }\n        },\n        beforeDatasetDraw (t, e, i) {\n            const s = e.meta.$filler;\n            na(s) && \"beforeDatasetDraw\" === i.drawTime && da(t.ctx, s, t.chartArea);\n        },\n        defaults: {\n            propagate: !0,\n            drawTime: \"beforeDatasetDraw\"\n        }\n    };\n    const ba = (t, e)=>{\n        let { boxHeight: i = e, boxWidth: s = e } = t;\n        return t.usePointStyle && (i = Math.min(i, e), s = t.pointStyleWidth || Math.min(s, e)), {\n            boxWidth: s,\n            boxHeight: i,\n            itemHeight: Math.max(e, i)\n        };\n    };\n    class xa extends Hs {\n        constructor(t){\n            super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e, i) {\n            this.maxWidth = t, this.maxHeight = e, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();\n        }\n        setDimensions() {\n            this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);\n        }\n        buildLabels() {\n            const t = this.options.labels || {};\n            let e = d(t.generateLabels, [\n                this.chart\n            ], this) || [];\n            t.filter && (e = e.filter((e)=>t.filter(e, this.chart.data))), t.sort && (e = e.sort((e, i)=>t.sort(e, i, this.chart.data))), this.options.reverse && e.reverse(), this.legendItems = e;\n        }\n        fit() {\n            const { options: t, ctx: e } = this;\n            if (!t.display) return void (this.width = this.height = 0);\n            const i = t.labels, s = Si(i.font), n = s.size, o = this._computeTitleHeight(), { boxWidth: a, itemHeight: r } = ba(i, n);\n            let l, h;\n            e.font = s.string, this.isHorizontal() ? (l = this.maxWidth, h = this._fitRows(o, n, a, r) + 10) : (h = this.maxHeight, l = this._fitCols(o, s, a, r) + 10), this.width = Math.min(l, t.maxWidth || this.maxWidth), this.height = Math.min(h, t.maxHeight || this.maxHeight);\n        }\n        _fitRows(t, e, i, s) {\n            const { ctx: n, maxWidth: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.lineWidths = [\n                0\n            ], h = s + a;\n            let c = t;\n            n.textAlign = \"left\", n.textBaseline = \"middle\";\n            let d = -1, u = -h;\n            return this.legendItems.forEach((t, f)=>{\n                const g = i + e / 2 + n.measureText(t.text).width;\n                (0 === f || l[l.length - 1] + g + 2 * a > o) && (c += h, l[l.length - (f > 0 ? 0 : 1)] = 0, u += h, d++), r[f] = {\n                    left: 0,\n                    top: u,\n                    row: d,\n                    width: g,\n                    height: s\n                }, l[l.length - 1] += g + a;\n            }), c;\n        }\n        _fitCols(t, e, i, s) {\n            const { ctx: n, maxHeight: o, options: { labels: { padding: a } } } = this, r = this.legendHitBoxes = [], l = this.columnSizes = [], h = o - t;\n            let c = a, d = 0, u = 0, f = 0, g = 0;\n            return this.legendItems.forEach((t, o)=>{\n                const { itemWidth: p, itemHeight: m } = function(t, e, i, s, n) {\n                    const o = function(t, e, i, s) {\n                        let n = t.text;\n                        n && \"string\" != typeof n && (n = n.reduce((t, e)=>t.length > e.length ? t : e));\n                        return e + i.size / 2 + s.measureText(n).width;\n                    }(s, t, e, i), a = function(t, e, i) {\n                        let s = t;\n                        \"string\" != typeof e.text && (s = _a(e, i));\n                        return s;\n                    }(n, s, e.lineHeight);\n                    return {\n                        itemWidth: o,\n                        itemHeight: a\n                    };\n                }(i, e, n, t, s);\n                o > 0 && u + m + 2 * a > h && (c += d + a, l.push({\n                    width: d,\n                    height: u\n                }), f += d + a, g++, d = u = 0), r[o] = {\n                    left: f,\n                    top: u,\n                    col: g,\n                    width: p,\n                    height: m\n                }, d = Math.max(d, p), u += m + a;\n            }), c += d, l.push({\n                width: d,\n                height: u\n            }), c;\n        }\n        adjustHitBoxes() {\n            if (!this.options.display) return;\n            const t = this._computeTitleHeight(), { legendHitBoxes: e, options: { align: i, labels: { padding: s }, rtl: n } } = this, o = Oi(n, this.left, this.width);\n            if (this.isHorizontal()) {\n                let n = 0, a = ft(i, this.left + s, this.right - this.lineWidths[n]);\n                for (const r of e)n !== r.row && (n = r.row, a = ft(i, this.left + s, this.right - this.lineWidths[n])), r.top += this.top + t + s, r.left = o.leftForLtr(o.x(a), r.width), a += r.width + s;\n            } else {\n                let n = 0, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height);\n                for (const r of e)r.col !== n && (n = r.col, a = ft(i, this.top + t + s, this.bottom - this.columnSizes[n].height)), r.top = a, r.left += this.left + s, r.left = o.leftForLtr(o.x(r.left), r.width), a += r.height + s;\n            }\n        }\n        isHorizontal() {\n            return \"top\" === this.options.position || \"bottom\" === this.options.position;\n        }\n        draw() {\n            if (this.options.display) {\n                const t = this.ctx;\n                Ie(t, this), this._draw(), ze(t);\n            }\n        }\n        _draw() {\n            const { options: t, columnSizes: e, lineWidths: i, ctx: s } = this, { align: n, labels: o } = t, a = ue.color, r = Oi(t.rtl, this.left, this.width), h = Si(o.font), { padding: c } = o, d = h.size, u = d / 2;\n            let f;\n            this.drawTitle(), s.textAlign = r.textAlign(\"left\"), s.textBaseline = \"middle\", s.lineWidth = .5, s.font = h.string;\n            const { boxWidth: g, boxHeight: p, itemHeight: m } = ba(o, d), b = this.isHorizontal(), x = this._computeTitleHeight();\n            f = b ? {\n                x: ft(n, this.left + c, this.right - i[0]),\n                y: this.top + c + x,\n                line: 0\n            } : {\n                x: this.left + c,\n                y: ft(n, this.top + x + c, this.bottom - e[0].height),\n                line: 0\n            }, Ai(this.ctx, t.textDirection);\n            const _ = m + c;\n            this.legendItems.forEach((y, v)=>{\n                s.strokeStyle = y.fontColor, s.fillStyle = y.fontColor;\n                const M = s.measureText(y.text).width, w = r.textAlign(y.textAlign || (y.textAlign = o.textAlign)), k = g + u + M;\n                let S = f.x, P = f.y;\n                r.setWidth(this.width), b ? v > 0 && S + k + c > this.right && (P = f.y += _, f.line++, S = f.x = ft(n, this.left + c, this.right - i[f.line])) : v > 0 && P + _ > this.bottom && (S = f.x = S + e[f.line].width + c, f.line++, P = f.y = ft(n, this.top + x + c, this.bottom - e[f.line].height));\n                if (function(t, e, i) {\n                    if (isNaN(g) || g <= 0 || isNaN(p) || p < 0) return;\n                    s.save();\n                    const n = l(i.lineWidth, 1);\n                    if (s.fillStyle = l(i.fillStyle, a), s.lineCap = l(i.lineCap, \"butt\"), s.lineDashOffset = l(i.lineDashOffset, 0), s.lineJoin = l(i.lineJoin, \"miter\"), s.lineWidth = n, s.strokeStyle = l(i.strokeStyle, a), s.setLineDash(l(i.lineDash, [])), o.usePointStyle) {\n                        const a = {\n                            radius: p * Math.SQRT2 / 2,\n                            pointStyle: i.pointStyle,\n                            rotation: i.rotation,\n                            borderWidth: n\n                        }, l = r.xPlus(t, g / 2);\n                        Ee(s, a, l, e + u, o.pointStyleWidth && g);\n                    } else {\n                        const o = e + Math.max((d - p) / 2, 0), a = r.leftForLtr(t, g), l = wi(i.borderRadius);\n                        s.beginPath(), Object.values(l).some((t)=>0 !== t) ? He(s, {\n                            x: a,\n                            y: o,\n                            w: g,\n                            h: p,\n                            radius: l\n                        }) : s.rect(a, o, g, p), s.fill(), 0 !== n && s.stroke();\n                    }\n                    s.restore();\n                }(r.x(S), P, y), S = gt(w, S + g + u, b ? S + k : this.right, t.rtl), function(t, e, i) {\n                    Ne(s, i.text, t, e + m / 2, h, {\n                        strikethrough: i.hidden,\n                        textAlign: r.textAlign(i.textAlign)\n                    });\n                }(r.x(S), P, y), b) f.x += k + c;\n                else if (\"string\" != typeof y.text) {\n                    const t = h.lineHeight;\n                    f.y += _a(y, t) + c;\n                } else f.y += _;\n            }), Ti(this.ctx, t.textDirection);\n        }\n        drawTitle() {\n            const t = this.options, e = t.title, i = Si(e.font), s = ki(e.padding);\n            if (!e.display) return;\n            const n = Oi(t.rtl, this.left, this.width), o = this.ctx, a = e.position, r = i.size / 2, l = s.top + r;\n            let h, c = this.left, d = this.width;\n            if (this.isHorizontal()) d = Math.max(...this.lineWidths), h = this.top + l, c = ft(t.align, c, this.right - d);\n            else {\n                const e = this.columnSizes.reduce((t, e)=>Math.max(t, e.height), 0);\n                h = l + ft(t.align, this.top, this.bottom - e - t.labels.padding - this._computeTitleHeight());\n            }\n            const u = ft(a, c, c + d);\n            o.textAlign = n.textAlign(ut(a)), o.textBaseline = \"middle\", o.strokeStyle = e.color, o.fillStyle = e.color, o.font = i.string, Ne(o, e.text, u, h, i);\n        }\n        _computeTitleHeight() {\n            const t = this.options.title, e = Si(t.font), i = ki(t.padding);\n            return t.display ? e.lineHeight + i.height : 0;\n        }\n        _getLegendItemAt(t, e) {\n            let i, s, n;\n            if (tt(t, this.left, this.right) && tt(e, this.top, this.bottom)) {\n                for(n = this.legendHitBoxes, i = 0; i < n.length; ++i)if (s = n[i], tt(t, s.left, s.left + s.width) && tt(e, s.top, s.top + s.height)) return this.legendItems[i];\n            }\n            return null;\n        }\n        handleEvent(t) {\n            const e = this.options;\n            if (!function(t, e) {\n                if ((\"mousemove\" === t || \"mouseout\" === t) && (e.onHover || e.onLeave)) return !0;\n                if (e.onClick && (\"click\" === t || \"mouseup\" === t)) return !0;\n                return !1;\n            }(t.type, e)) return;\n            const i = this._getLegendItemAt(t.x, t.y);\n            if (\"mousemove\" === t.type || \"mouseout\" === t.type) {\n                const o = this._hoveredItem, a = (n = i, null !== (s = o) && null !== n && s.datasetIndex === n.datasetIndex && s.index === n.index);\n                o && !a && d(e.onLeave, [\n                    t,\n                    o,\n                    this\n                ], this), this._hoveredItem = i, i && !a && d(e.onHover, [\n                    t,\n                    i,\n                    this\n                ], this);\n            } else i && d(e.onClick, [\n                t,\n                i,\n                this\n            ], this);\n            var s, n;\n        }\n    }\n    function _a(t, e) {\n        return e * (t.text ? t.text.length : 0);\n    }\n    var ya = {\n        id: \"legend\",\n        _element: xa,\n        start (t, e, i) {\n            const s = t.legend = new xa({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, t.legend), delete t.legend;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.legend;\n            as.configure(t, s, i), s.options = i;\n        },\n        afterUpdate (t) {\n            const e = t.legend;\n            e.buildLabels(), e.adjustHitBoxes();\n        },\n        afterEvent (t, e) {\n            e.replay || t.legend.handleEvent(e.event);\n        },\n        defaults: {\n            display: !0,\n            position: \"top\",\n            align: \"center\",\n            fullSize: !0,\n            reverse: !1,\n            weight: 1e3,\n            onClick (t, e, i) {\n                const s = e.datasetIndex, n = i.chart;\n                n.isDatasetVisible(s) ? (n.hide(s), e.hidden = !0) : (n.show(s), e.hidden = !1);\n            },\n            onHover: null,\n            onLeave: null,\n            labels: {\n                color: (t)=>t.chart.options.color,\n                boxWidth: 40,\n                padding: 10,\n                generateLabels (t) {\n                    const e = t.data.datasets, { labels: { usePointStyle: i, pointStyle: s, textAlign: n, color: o, useBorderRadius: a, borderRadius: r } } = t.legend.options;\n                    return t._getSortedDatasetMetas().map((t)=>{\n                        const l = t.controller.getStyle(i ? 0 : void 0), h = ki(l.borderWidth);\n                        return {\n                            text: e[t.index].label,\n                            fillStyle: l.backgroundColor,\n                            fontColor: o,\n                            hidden: !t.visible,\n                            lineCap: l.borderCapStyle,\n                            lineDash: l.borderDash,\n                            lineDashOffset: l.borderDashOffset,\n                            lineJoin: l.borderJoinStyle,\n                            lineWidth: (h.width + h.height) / 4,\n                            strokeStyle: l.borderColor,\n                            pointStyle: s || l.pointStyle,\n                            rotation: l.rotation,\n                            textAlign: n || l.textAlign,\n                            borderRadius: a && (r || l.borderRadius),\n                            datasetIndex: t.index\n                        };\n                    }, this);\n                }\n            },\n            title: {\n                color: (t)=>t.chart.options.color,\n                display: !1,\n                position: \"center\",\n                text: \"\"\n            }\n        },\n        descriptors: {\n            _scriptable: (t)=>!t.startsWith(\"on\"),\n            labels: {\n                _scriptable: (t)=>![\n                        \"generateLabels\",\n                        \"filter\",\n                        \"sort\"\n                    ].includes(t)\n            }\n        }\n    };\n    class va extends Hs {\n        constructor(t){\n            super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;\n        }\n        update(t, e) {\n            const i = this.options;\n            if (this.left = 0, this.top = 0, !i.display) return void (this.width = this.height = this.right = this.bottom = 0);\n            this.width = this.right = t, this.height = this.bottom = e;\n            const s = n(i.text) ? i.text.length : 1;\n            this._padding = ki(i.padding);\n            const o = s * Si(i.font).lineHeight + this._padding.height;\n            this.isHorizontal() ? this.height = o : this.width = o;\n        }\n        isHorizontal() {\n            const t = this.options.position;\n            return \"top\" === t || \"bottom\" === t;\n        }\n        _drawArgs(t) {\n            const { top: e, left: i, bottom: s, right: n, options: o } = this, a = o.align;\n            let r, l, h, c = 0;\n            return this.isHorizontal() ? (l = ft(a, i, n), h = e + t, r = n - i) : (\"left\" === o.position ? (l = i + t, h = ft(a, s, e), c = -0.5 * C) : (l = n - t, h = ft(a, e, s), c = .5 * C), r = s - e), {\n                titleX: l,\n                titleY: h,\n                maxWidth: r,\n                rotation: c\n            };\n        }\n        draw() {\n            const t = this.ctx, e = this.options;\n            if (!e.display) return;\n            const i = Si(e.font), s = i.lineHeight / 2 + this._padding.top, { titleX: n, titleY: o, maxWidth: a, rotation: r } = this._drawArgs(s);\n            Ne(t, e.text, 0, 0, i, {\n                color: e.color,\n                maxWidth: a,\n                rotation: r,\n                textAlign: ut(e.align),\n                textBaseline: \"middle\",\n                translation: [\n                    n,\n                    o\n                ]\n            });\n        }\n    }\n    var Ma = {\n        id: \"title\",\n        _element: va,\n        start (t, e, i) {\n            !function(t, e) {\n                const i = new va({\n                    ctx: t.ctx,\n                    options: e,\n                    chart: t\n                });\n                as.configure(t, i, e), as.addBox(t, i), t.titleBlock = i;\n            }(t, i);\n        },\n        stop (t) {\n            const e = t.titleBlock;\n            as.removeBox(t, e), delete t.titleBlock;\n        },\n        beforeUpdate (t, e, i) {\n            const s = t.titleBlock;\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"bold\"\n            },\n            fullSize: !0,\n            padding: 10,\n            position: \"top\",\n            text: \"\",\n            weight: 2e3\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const wa = new WeakMap;\n    var ka = {\n        id: \"subtitle\",\n        start (t, e, i) {\n            const s = new va({\n                ctx: t.ctx,\n                options: i,\n                chart: t\n            });\n            as.configure(t, s, i), as.addBox(t, s), wa.set(t, s);\n        },\n        stop (t) {\n            as.removeBox(t, wa.get(t)), wa.delete(t);\n        },\n        beforeUpdate (t, e, i) {\n            const s = wa.get(t);\n            as.configure(t, s, i), s.options = i;\n        },\n        defaults: {\n            align: \"center\",\n            display: !1,\n            font: {\n                weight: \"normal\"\n            },\n            fullSize: !0,\n            padding: 0,\n            position: \"top\",\n            text: \"\",\n            weight: 1500\n        },\n        defaultRoutes: {\n            color: \"color\"\n        },\n        descriptors: {\n            _scriptable: !0,\n            _indexable: !1\n        }\n    };\n    const Sa = {\n        average (t) {\n            if (!t.length) return !1;\n            let e, i, s = 0, n = 0, o = 0;\n            for(e = 0, i = t.length; e < i; ++e){\n                const i = t[e].element;\n                if (i && i.hasValue()) {\n                    const t = i.tooltipPosition();\n                    s += t.x, n += t.y, ++o;\n                }\n            }\n            return {\n                x: s / o,\n                y: n / o\n            };\n        },\n        nearest (t, e) {\n            if (!t.length) return !1;\n            let i, s, n, o = e.x, a = e.y, r = Number.POSITIVE_INFINITY;\n            for(i = 0, s = t.length; i < s; ++i){\n                const s = t[i].element;\n                if (s && s.hasValue()) {\n                    const t = q(e, s.getCenterPoint());\n                    t < r && (r = t, n = s);\n                }\n            }\n            if (n) {\n                const t = n.tooltipPosition();\n                o = t.x, a = t.y;\n            }\n            return {\n                x: o,\n                y: a\n            };\n        }\n    };\n    function Pa(t, e) {\n        return e && (n(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t;\n    }\n    function Da(t) {\n        return (\"string\" == typeof t || t instanceof String) && t.indexOf(\"\\n\") > -1 ? t.split(\"\\n\") : t;\n    }\n    function Ca(t, e) {\n        const { element: i, datasetIndex: s, index: n } = e, o = t.getDatasetMeta(s).controller, { label: a, value: r } = o.getLabelAndValue(n);\n        return {\n            chart: t,\n            label: a,\n            parsed: o.getParsed(n),\n            raw: t.data.datasets[s].data[n],\n            formattedValue: r,\n            dataset: o.getDataset(),\n            dataIndex: n,\n            datasetIndex: s,\n            element: i\n        };\n    }\n    function Oa(t, e) {\n        const i = t.chart.ctx, { body: s, footer: n, title: o } = t, { boxWidth: a, boxHeight: r } = e, l = Si(e.bodyFont), h = Si(e.titleFont), c = Si(e.footerFont), d = o.length, f = n.length, g = s.length, p = ki(e.padding);\n        let m = p.height, b = 0, x = s.reduce((t, e)=>t + e.before.length + e.lines.length + e.after.length, 0);\n        if (x += t.beforeBody.length + t.afterBody.length, d && (m += d * h.lineHeight + (d - 1) * e.titleSpacing + e.titleMarginBottom), x) m += g * (e.displayColors ? Math.max(r, l.lineHeight) : l.lineHeight) + (x - g) * l.lineHeight + (x - 1) * e.bodySpacing;\n        f && (m += e.footerMarginTop + f * c.lineHeight + (f - 1) * e.footerSpacing);\n        let _ = 0;\n        const y = function(t) {\n            b = Math.max(b, i.measureText(t).width + _);\n        };\n        return i.save(), i.font = h.string, u(t.title, y), i.font = l.string, u(t.beforeBody.concat(t.afterBody), y), _ = e.displayColors ? a + 2 + e.boxPadding : 0, u(s, (t)=>{\n            u(t.before, y), u(t.lines, y), u(t.after, y);\n        }), _ = 0, i.font = c.string, u(t.footer, y), i.restore(), b += p.width, {\n            width: b,\n            height: m\n        };\n    }\n    function Aa(t, e, i, s) {\n        const { x: n, width: o } = i, { width: a, chartArea: { left: r, right: l } } = t;\n        let h = \"center\";\n        return \"center\" === s ? h = n <= (r + l) / 2 ? \"left\" : \"right\" : n <= o / 2 ? h = \"left\" : n >= a - o / 2 && (h = \"right\"), function(t, e, i, s) {\n            const { x: n, width: o } = s, a = i.caretSize + i.caretPadding;\n            return \"left\" === t && n + o + a > e.width || \"right\" === t && n - o - a < 0 || void 0;\n        }(h, t, e, i) && (h = \"center\"), h;\n    }\n    function Ta(t, e, i) {\n        const s = i.yAlign || e.yAlign || function(t, e) {\n            const { y: i, height: s } = e;\n            return i < s / 2 ? \"top\" : i > t.height - s / 2 ? \"bottom\" : \"center\";\n        }(t, i);\n        return {\n            xAlign: i.xAlign || e.xAlign || Aa(t, e, i, s),\n            yAlign: s\n        };\n    }\n    function La(t, e, i, s) {\n        const { caretSize: n, caretPadding: o, cornerRadius: a } = t, { xAlign: r, yAlign: l } = i, h = n + o, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(a);\n        let g = function(t, e) {\n            let { x: i, width: s } = t;\n            return \"right\" === e ? i -= s : \"center\" === e && (i -= s / 2), i;\n        }(e, r);\n        const p = function(t, e, i) {\n            let { y: s, height: n } = t;\n            return \"top\" === e ? s += i : s -= \"bottom\" === e ? n + i : n / 2, s;\n        }(e, l, h);\n        return \"center\" === l ? \"left\" === r ? g += h : \"right\" === r && (g -= h) : \"left\" === r ? g -= Math.max(c, u) + n : \"right\" === r && (g += Math.max(d, f) + n), {\n            x: J(g, 0, s.width - e.width),\n            y: J(p, 0, s.height - e.height)\n        };\n    }\n    function Ea(t, e, i) {\n        const s = ki(i.padding);\n        return \"center\" === e ? t.x + t.width / 2 : \"right\" === e ? t.x + t.width - s.right : t.x + s.left;\n    }\n    function Ra(t) {\n        return Pa([], Da(t));\n    }\n    function Ia(t, e) {\n        const i = e && e.dataset && e.dataset.tooltip && e.dataset.tooltip.callbacks;\n        return i ? t.override(i) : t;\n    }\n    const za = {\n        beforeTitle: e,\n        title (t) {\n            if (t.length > 0) {\n                const e = t[0], i = e.chart.data.labels, s = i ? i.length : 0;\n                if (this && this.options && \"dataset\" === this.options.mode) return e.dataset.label || \"\";\n                if (e.label) return e.label;\n                if (s > 0 && e.dataIndex < s) return i[e.dataIndex];\n            }\n            return \"\";\n        },\n        afterTitle: e,\n        beforeBody: e,\n        beforeLabel: e,\n        label (t) {\n            if (this && this.options && \"dataset\" === this.options.mode) return t.label + \": \" + t.formattedValue || t.formattedValue;\n            let e = t.dataset.label || \"\";\n            e && (e += \": \");\n            const i = t.formattedValue;\n            return s(i) || (e += i), e;\n        },\n        labelColor (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                borderColor: e.borderColor,\n                backgroundColor: e.backgroundColor,\n                borderWidth: e.borderWidth,\n                borderDash: e.borderDash,\n                borderDashOffset: e.borderDashOffset,\n                borderRadius: 0\n            };\n        },\n        labelTextColor () {\n            return this.options.bodyColor;\n        },\n        labelPointStyle (t) {\n            const e = t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);\n            return {\n                pointStyle: e.pointStyle,\n                rotation: e.rotation\n            };\n        },\n        afterLabel: e,\n        afterBody: e,\n        beforeFooter: e,\n        footer: e,\n        afterFooter: e\n    };\n    function Fa(t, e, i, s) {\n        const n = t[e].call(i, s);\n        return void 0 === n ? za[e].call(i, s) : n;\n    }\n    class Va extends Hs {\n        static positioners = Sa;\n        constructor(t){\n            super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;\n        }\n        initialize(t) {\n            this.options = t, this._cachedAnimations = void 0, this.$context = void 0;\n        }\n        _resolveAnimations() {\n            const t = this._cachedAnimations;\n            if (t) return t;\n            const e = this.chart, i = this.options.setContext(this.getContext()), s = i.enabled && e.options.animation && i.animations, n = new Os(this.chart, s);\n            return s._cacheable && (this._cachedAnimations = Object.freeze(n)), n;\n        }\n        getContext() {\n            var t, e, i;\n            return this.$context || (this.$context = (t = this.chart.getContext(), e = this, i = this._tooltipItems, Ci(t, {\n                tooltip: e,\n                tooltipItems: i,\n                type: \"tooltip\"\n            })));\n        }\n        getTitle(t, e) {\n            const { callbacks: i } = e, s = Fa(i, \"beforeTitle\", this, t), n = Fa(i, \"title\", this, t), o = Fa(i, \"afterTitle\", this, t);\n            let a = [];\n            return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a;\n        }\n        getBeforeBody(t, e) {\n            return Ra(Fa(e.callbacks, \"beforeBody\", this, t));\n        }\n        getBody(t, e) {\n            const { callbacks: i } = e, s = [];\n            return u(t, (t)=>{\n                const e = {\n                    before: [],\n                    lines: [],\n                    after: []\n                }, n = Ia(i, t);\n                Pa(e.before, Da(Fa(n, \"beforeLabel\", this, t))), Pa(e.lines, Fa(n, \"label\", this, t)), Pa(e.after, Da(Fa(n, \"afterLabel\", this, t))), s.push(e);\n            }), s;\n        }\n        getAfterBody(t, e) {\n            return Ra(Fa(e.callbacks, \"afterBody\", this, t));\n        }\n        getFooter(t, e) {\n            const { callbacks: i } = e, s = Fa(i, \"beforeFooter\", this, t), n = Fa(i, \"footer\", this, t), o = Fa(i, \"afterFooter\", this, t);\n            let a = [];\n            return a = Pa(a, Da(s)), a = Pa(a, Da(n)), a = Pa(a, Da(o)), a;\n        }\n        _createItems(t) {\n            const e = this._active, i = this.chart.data, s = [], n = [], o = [];\n            let a, r, l = [];\n            for(a = 0, r = e.length; a < r; ++a)l.push(Ca(this.chart, e[a]));\n            return t.filter && (l = l.filter((e, s, n)=>t.filter(e, s, n, i))), t.itemSort && (l = l.sort((e, s)=>t.itemSort(e, s, i))), u(l, (e)=>{\n                const i = Ia(t.callbacks, e);\n                s.push(Fa(i, \"labelColor\", this, e)), n.push(Fa(i, \"labelPointStyle\", this, e)), o.push(Fa(i, \"labelTextColor\", this, e));\n            }), this.labelColors = s, this.labelPointStyles = n, this.labelTextColors = o, this.dataPoints = l, l;\n        }\n        update(t, e) {\n            const i = this.options.setContext(this.getContext()), s = this._active;\n            let n, o = [];\n            if (s.length) {\n                const t = Sa[i.position].call(this, s, this._eventPosition);\n                o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);\n                const e = this._size = Oa(this, i), a = Object.assign({}, t, e), r = Ta(this.chart, i, a), l = La(i, a, r, this.chart);\n                this.xAlign = r.xAlign, this.yAlign = r.yAlign, n = {\n                    opacity: 1,\n                    x: l.x,\n                    y: l.y,\n                    width: e.width,\n                    height: e.height,\n                    caretX: t.x,\n                    caretY: t.y\n                };\n            } else 0 !== this.opacity && (n = {\n                opacity: 0\n            });\n            this._tooltipItems = o, this.$context = void 0, n && this._resolveAnimations().update(this, n), t && i.external && i.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay: e\n            });\n        }\n        drawCaret(t, e, i, s) {\n            const n = this.getCaretPosition(t, i, s);\n            e.lineTo(n.x1, n.y1), e.lineTo(n.x2, n.y2), e.lineTo(n.x3, n.y3);\n        }\n        getCaretPosition(t, e, i) {\n            const { xAlign: s, yAlign: n } = this, { caretSize: o, cornerRadius: a } = i, { topLeft: r, topRight: l, bottomLeft: h, bottomRight: c } = wi(a), { x: d, y: u } = t, { width: f, height: g } = e;\n            let p, m, b, x, _, y;\n            return \"center\" === n ? (_ = u + g / 2, \"left\" === s ? (p = d, m = p - o, x = _ + o, y = _ - o) : (p = d + f, m = p + o, x = _ - o, y = _ + o), b = p) : (m = \"left\" === s ? d + Math.max(r, h) + o : \"right\" === s ? d + f - Math.max(l, c) - o : this.caretX, \"top\" === n ? (x = u, _ = x - o, p = m - o, b = m + o) : (x = u + g, _ = x + o, p = m + o, b = m - o), y = x), {\n                x1: p,\n                x2: m,\n                x3: b,\n                y1: x,\n                y2: _,\n                y3: y\n            };\n        }\n        drawTitle(t, e, i) {\n            const s = this.title, n = s.length;\n            let o, a, r;\n            if (n) {\n                const l = Oi(i.rtl, this.x, this.width);\n                for(t.x = Ea(this, i.titleAlign, i), e.textAlign = l.textAlign(i.titleAlign), e.textBaseline = \"middle\", o = Si(i.titleFont), a = i.titleSpacing, e.fillStyle = i.titleColor, e.font = o.string, r = 0; r < n; ++r)e.fillText(s[r], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + a, r + 1 === n && (t.y += i.titleMarginBottom - a);\n            }\n        }\n        _drawColorBox(t, e, i, s, n) {\n            const a = this.labelColors[i], r = this.labelPointStyles[i], { boxHeight: l, boxWidth: h } = n, c = Si(n.bodyFont), d = Ea(this, \"left\", n), u = s.x(d), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, g = e.y + f;\n            if (n.usePointStyle) {\n                const e = {\n                    radius: Math.min(h, l) / 2,\n                    pointStyle: r.pointStyle,\n                    rotation: r.rotation,\n                    borderWidth: 1\n                }, i = s.leftForLtr(u, h) + h / 2, o = g + l / 2;\n                t.strokeStyle = n.multiKeyBackground, t.fillStyle = n.multiKeyBackground, Le(t, e, i, o), t.strokeStyle = a.borderColor, t.fillStyle = a.backgroundColor, Le(t, e, i, o);\n            } else {\n                t.lineWidth = o(a.borderWidth) ? Math.max(...Object.values(a.borderWidth)) : a.borderWidth || 1, t.strokeStyle = a.borderColor, t.setLineDash(a.borderDash || []), t.lineDashOffset = a.borderDashOffset || 0;\n                const e = s.leftForLtr(u, h), i = s.leftForLtr(s.xPlus(u, 1), h - 2), r = wi(a.borderRadius);\n                Object.values(r).some((t)=>0 !== t) ? (t.beginPath(), t.fillStyle = n.multiKeyBackground, He(t, {\n                    x: e,\n                    y: g,\n                    w: h,\n                    h: l,\n                    radius: r\n                }), t.fill(), t.stroke(), t.fillStyle = a.backgroundColor, t.beginPath(), He(t, {\n                    x: i,\n                    y: g + 1,\n                    w: h - 2,\n                    h: l - 2,\n                    radius: r\n                }), t.fill()) : (t.fillStyle = n.multiKeyBackground, t.fillRect(e, g, h, l), t.strokeRect(e, g, h, l), t.fillStyle = a.backgroundColor, t.fillRect(i, g + 1, h - 2, l - 2));\n            }\n            t.fillStyle = this.labelTextColors[i];\n        }\n        drawBody(t, e, i) {\n            const { body: s } = this, { bodySpacing: n, bodyAlign: o, displayColors: a, boxHeight: r, boxWidth: l, boxPadding: h } = i, c = Si(i.bodyFont);\n            let d = c.lineHeight, f = 0;\n            const g = Oi(i.rtl, this.x, this.width), p = function(i) {\n                e.fillText(i, g.x(t.x + f), t.y + d / 2), t.y += d + n;\n            }, m = g.textAlign(o);\n            let b, x, _, y, v, M, w;\n            for(e.textAlign = o, e.textBaseline = \"middle\", e.font = c.string, t.x = Ea(this, m, i), e.fillStyle = i.bodyColor, u(this.beforeBody, p), f = a && \"right\" !== m ? \"center\" === o ? l / 2 + h : l + 2 + h : 0, y = 0, M = s.length; y < M; ++y){\n                for(b = s[y], x = this.labelTextColors[y], e.fillStyle = x, u(b.before, p), _ = b.lines, a && _.length && (this._drawColorBox(e, t, y, g, i), d = Math.max(c.lineHeight, r)), v = 0, w = _.length; v < w; ++v)p(_[v]), d = c.lineHeight;\n                u(b.after, p);\n            }\n            f = 0, d = c.lineHeight, u(this.afterBody, p), t.y -= n;\n        }\n        drawFooter(t, e, i) {\n            const s = this.footer, n = s.length;\n            let o, a;\n            if (n) {\n                const r = Oi(i.rtl, this.x, this.width);\n                for(t.x = Ea(this, i.footerAlign, i), t.y += i.footerMarginTop, e.textAlign = r.textAlign(i.footerAlign), e.textBaseline = \"middle\", o = Si(i.footerFont), e.fillStyle = i.footerColor, e.font = o.string, a = 0; a < n; ++a)e.fillText(s[a], r.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;\n            }\n        }\n        drawBackground(t, e, i, s) {\n            const { xAlign: n, yAlign: o } = this, { x: a, y: r } = t, { width: l, height: h } = i, { topLeft: c, topRight: d, bottomLeft: u, bottomRight: f } = wi(s.cornerRadius);\n            e.fillStyle = s.backgroundColor, e.strokeStyle = s.borderColor, e.lineWidth = s.borderWidth, e.beginPath(), e.moveTo(a + c, r), \"top\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + l - d, r), e.quadraticCurveTo(a + l, r, a + l, r + d), \"center\" === o && \"right\" === n && this.drawCaret(t, e, i, s), e.lineTo(a + l, r + h - f), e.quadraticCurveTo(a + l, r + h, a + l - f, r + h), \"bottom\" === o && this.drawCaret(t, e, i, s), e.lineTo(a + u, r + h), e.quadraticCurveTo(a, r + h, a, r + h - u), \"center\" === o && \"left\" === n && this.drawCaret(t, e, i, s), e.lineTo(a, r + c), e.quadraticCurveTo(a, r, a + c, r), e.closePath(), e.fill(), s.borderWidth > 0 && e.stroke();\n        }\n        _updateAnimationTarget(t) {\n            const e = this.chart, i = this.$animations, s = i && i.x, n = i && i.y;\n            if (s || n) {\n                const i = Sa[t.position].call(this, this._active, this._eventPosition);\n                if (!i) return;\n                const o = this._size = Oa(this, t), a = Object.assign({}, i, this._size), r = Ta(e, t, a), l = La(t, a, r, e);\n                s._to === l.x && n._to === l.y || (this.xAlign = r.xAlign, this.yAlign = r.yAlign, this.width = o.width, this.height = o.height, this.caretX = i.x, this.caretY = i.y, this._resolveAnimations().update(this, l));\n            }\n        }\n        _willRender() {\n            return !!this.opacity;\n        }\n        draw(t) {\n            const e = this.options.setContext(this.getContext());\n            let i = this.opacity;\n            if (!i) return;\n            this._updateAnimationTarget(e);\n            const s = {\n                width: this.width,\n                height: this.height\n            }, n = {\n                x: this.x,\n                y: this.y\n            };\n            i = Math.abs(i) < .001 ? 0 : i;\n            const o = ki(e.padding), a = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n            e.enabled && a && (t.save(), t.globalAlpha = i, this.drawBackground(n, t, s, e), Ai(t, e.textDirection), n.y += o.top, this.drawTitle(n, t, e), this.drawBody(n, t, e), this.drawFooter(n, t, e), Ti(t, e.textDirection), t.restore());\n        }\n        getActiveElements() {\n            return this._active || [];\n        }\n        setActiveElements(t, e) {\n            const i = this._active, s = t.map(({ datasetIndex: t, index: e })=>{\n                const i = this.chart.getDatasetMeta(t);\n                if (!i) throw new Error(\"Cannot find a dataset at index \" + t);\n                return {\n                    datasetIndex: t,\n                    element: i.data[e],\n                    index: e\n                };\n            }), n = !f(i, s), o = this._positionChanged(s, e);\n            (n || o) && (this._active = s, this._eventPosition = e, this._ignoreReplayEvents = !0, this.update(!0));\n        }\n        handleEvent(t, e, i = !0) {\n            if (e && this._ignoreReplayEvents) return !1;\n            this._ignoreReplayEvents = !1;\n            const s = this.options, n = this._active || [], o = this._getActiveElements(t, n, e, i), a = this._positionChanged(o, t), r = e || !f(o, n) || a;\n            return r && (this._active = o, (s.enabled || s.external) && (this._eventPosition = {\n                x: t.x,\n                y: t.y\n            }, this.update(!0, e))), r;\n        }\n        _getActiveElements(t, e, i, s) {\n            const n = this.options;\n            if (\"mouseout\" === t.type) return [];\n            if (!s) return e.filter((t)=>this.chart.data.datasets[t.datasetIndex] && void 0 !== this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index));\n            const o = this.chart.getElementsAtEventForMode(t, n.mode, n, i);\n            return n.reverse && o.reverse(), o;\n        }\n        _positionChanged(t, e) {\n            const { caretX: i, caretY: s, options: n } = this, o = Sa[n.position].call(this, t, e);\n            return !1 !== o && (i !== o.x || s !== o.y);\n        }\n    }\n    var Ba = {\n        id: \"tooltip\",\n        _element: Va,\n        positioners: Sa,\n        afterInit (t, e, i) {\n            i && (t.tooltip = new Va({\n                chart: t,\n                options: i\n            }));\n        },\n        beforeUpdate (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        reset (t, e, i) {\n            t.tooltip && t.tooltip.initialize(i);\n        },\n        afterDraw (t) {\n            const e = t.tooltip;\n            if (e && e._willRender()) {\n                const i = {\n                    tooltip: e\n                };\n                if (!1 === t.notifyPlugins(\"beforeTooltipDraw\", {\n                    ...i,\n                    cancelable: !0\n                })) return;\n                e.draw(t.ctx), t.notifyPlugins(\"afterTooltipDraw\", i);\n            }\n        },\n        afterEvent (t, e) {\n            if (t.tooltip) {\n                const i = e.replay;\n                t.tooltip.handleEvent(e.event, i, e.inChartArea) && (e.changed = !0);\n            }\n        },\n        defaults: {\n            enabled: !0,\n            external: null,\n            position: \"average\",\n            backgroundColor: \"rgba(0,0,0,0.8)\",\n            titleColor: \"#fff\",\n            titleFont: {\n                weight: \"bold\"\n            },\n            titleSpacing: 2,\n            titleMarginBottom: 6,\n            titleAlign: \"left\",\n            bodyColor: \"#fff\",\n            bodySpacing: 2,\n            bodyFont: {},\n            bodyAlign: \"left\",\n            footerColor: \"#fff\",\n            footerSpacing: 2,\n            footerMarginTop: 6,\n            footerFont: {\n                weight: \"bold\"\n            },\n            footerAlign: \"left\",\n            padding: 6,\n            caretPadding: 2,\n            caretSize: 5,\n            cornerRadius: 6,\n            boxHeight: (t, e)=>e.bodyFont.size,\n            boxWidth: (t, e)=>e.bodyFont.size,\n            multiKeyBackground: \"#fff\",\n            displayColors: !0,\n            boxPadding: 0,\n            borderColor: \"rgba(0,0,0,0)\",\n            borderWidth: 0,\n            animation: {\n                duration: 400,\n                easing: \"easeOutQuart\"\n            },\n            animations: {\n                numbers: {\n                    type: \"number\",\n                    properties: [\n                        \"x\",\n                        \"y\",\n                        \"width\",\n                        \"height\",\n                        \"caretX\",\n                        \"caretY\"\n                    ]\n                },\n                opacity: {\n                    easing: \"linear\",\n                    duration: 200\n                }\n            },\n            callbacks: za\n        },\n        defaultRoutes: {\n            bodyFont: \"font\",\n            footerFont: \"font\",\n            titleFont: \"font\"\n        },\n        descriptors: {\n            _scriptable: (t)=>\"filter\" !== t && \"itemSort\" !== t && \"external\" !== t,\n            _indexable: !1,\n            callbacks: {\n                _scriptable: !1,\n                _indexable: !1\n            },\n            animation: {\n                _fallback: !1\n            },\n            animations: {\n                _fallback: \"animation\"\n            }\n        },\n        additionalOptionScopes: [\n            \"interaction\"\n        ]\n    };\n    return An.register(Yn, jo, fo, t), An.helpers = {\n        ...Wi\n    }, An._adapters = Rn, An.Animation = Cs, An.Animations = Os, An.animator = xt, An.controllers = en.controllers.items, An.DatasetController = Ns, An.Element = Hs, An.elements = fo, An.Interaction = Xi, An.layouts = as, An.platforms = Ss, An.Scale = Js, An.Ticks = ae, Object.assign(An, Yn, jo, fo, t, Ss), An.Chart = An, \"undefined\" != typeof window && (window.Chart = An), An;\n});\n\n//# sourceMappingURL=index.ed39b8c1.js.map\n","/*!\n * Chart.js v4.4.1\n * https://www.chartjs.org\n * (c) 2023 Chart.js Contributors\n * Released under the MIT License\n */\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).Chart=e()}(this,(function(){\"use strict\";var t=Object.freeze({__proto__:null,get Colors(){return Go},get Decimation(){return Qo},get Filler(){return ma},get Legend(){return ya},get SubTitle(){return ka},get Title(){return Ma},get Tooltip(){return Ba}});function e(){}const i=(()=>{let t=0;return()=>t++})();function s(t){return null==t}function n(t){if(Array.isArray&&Array.isArray(t))return!0;const e=Object.prototype.toString.call(t);return\"[object\"===e.slice(0,7)&&\"Array]\"===e.slice(-6)}function o(t){return null!==t&&\"[object Object]\"===Object.prototype.toString.call(t)}function a(t){return(\"number\"==typeof t||t instanceof Number)&&isFinite(+t)}function r(t,e){return a(t)?t:e}function l(t,e){return void 0===t?e:t}const h=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100:+t/e,c=(t,e)=>\"string\"==typeof t&&t.endsWith(\"%\")?parseFloat(t)/100*e:+t;function d(t,e,i){if(t&&\"function\"==typeof t.call)return t.apply(i,e)}function u(t,e,i,s){let a,r,l;if(n(t))if(r=t.length,s)for(a=r-1;a>=0;a--)e.call(i,t[a],a);else for(a=0;a<r;a++)e.call(i,t[a],a);else if(o(t))for(l=Object.keys(t),r=l.length,a=0;a<r;a++)e.call(i,t[l[a]],l[a])}function f(t,e){let i,s,n,o;if(!t||!e||t.length!==e.length)return!1;for(i=0,s=t.length;i<s;++i)if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)return!1;return!0}function g(t){if(n(t))return t.map(g);if(o(t)){const e=Object.create(null),i=Object.keys(t),s=i.length;let n=0;for(;n<s;++n)e[i[n]]=g(t[i[n]]);return e}return t}function p(t){return-1===[\"__proto__\",\"prototype\",\"constructor\"].indexOf(t)}function m(t,e,i,s){if(!p(t))return;const n=e[t],a=i[t];o(n)&&o(a)?b(n,a,s):e[t]=g(a)}function b(t,e,i){const s=n(e)?e:[e],a=s.length;if(!o(t))return t;const r=(i=i||{}).merger||m;let l;for(let e=0;e<a;++e){if(l=s[e],!o(l))continue;const n=Object.keys(l);for(let e=0,s=n.length;e<s;++e)r(n[e],t,l,i)}return t}function x(t,e){return b(t,e,{merger:_})}function _(t,e,i){if(!p(t))return;const s=e[t],n=i[t];o(s)&&o(n)?x(s,n):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=g(n))}const y={\"\":t=>t,x:t=>t.x,y:t=>t.y};function v(t){const e=t.split(\".\"),i=[];let s=\"\";for(const t of e)s+=t,s.endsWith(\"\\\\\")?s=s.slice(0,-1)+\".\":(i.push(s),s=\"\");return i}function M(t,e){const i=y[e]||(y[e]=function(t){const e=v(t);return t=>{for(const i of e){if(\"\"===i)break;t=t&&t[i]}return t}}(e));return i(t)}function w(t){return t.charAt(0).toUpperCase()+t.slice(1)}const k=t=>void 0!==t,S=t=>\"function\"==typeof t,P=(t,e)=>{if(t.size!==e.size)return!1;for(const i of t)if(!e.has(i))return!1;return!0};function D(t){return\"mouseup\"===t.type||\"click\"===t.type||\"contextmenu\"===t.type}const C=Math.PI,O=2*C,A=O+C,T=Number.POSITIVE_INFINITY,L=C/180,E=C/2,R=C/4,I=2*C/3,z=Math.log10,F=Math.sign;function V(t,e,i){return Math.abs(t-e)<i}function B(t){const e=Math.round(t);t=V(t,e,t/1e3)?e:t;const i=Math.pow(10,Math.floor(z(t))),s=t/i;return(s<=1?1:s<=2?2:s<=5?5:10)*i}function W(t){const e=[],i=Math.sqrt(t);let s;for(s=1;s<i;s++)t%s==0&&(e.push(s),e.push(t/s));return i===(0|i)&&e.push(i),e.sort(((t,e)=>t-e)).pop(),e}function N(t){return!isNaN(parseFloat(t))&&isFinite(t)}function H(t,e){const i=Math.round(t);return i-e<=t&&i+e>=t}function j(t,e,i){let s,n,o;for(s=0,n=t.length;s<n;s++)o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}function $(t){return t*(C/180)}function Y(t){return t*(180/C)}function U(t){if(!a(t))return;let e=1,i=0;for(;Math.round(t*e)/e!==t;)e*=10,i++;return i}function X(t,e){const i=e.x-t.x,s=e.y-t.y,n=Math.sqrt(i*i+s*s);let o=Math.atan2(s,i);return o<-.5*C&&(o+=O),{angle:o,distance:n}}function q(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function K(t,e){return(t-e+A)%O-C}function G(t){return(t%O+O)%O}function Z(t,e,i,s){const n=G(t),o=G(e),a=G(i),r=G(o-n),l=G(a-n),h=G(n-o),c=G(n-a);return n===o||n===a||s&&o===a||r>l&&h<c}function J(t,e,i){return Math.max(e,Math.min(i,t))}function Q(t){return J(t,-32768,32767)}function tt(t,e,i,s=1e-6){return t>=Math.min(e,i)-s&&t<=Math.max(e,i)+s}function et(t,e,i){i=i||(i=>t[i]<e);let s,n=t.length-1,o=0;for(;n-o>1;)s=o+n>>1,i(s)?o=s:n=s;return{lo:o,hi:n}}const it=(t,e,i,s)=>et(t,i,s?s=>{const n=t[s][e];return n<i||n===i&&t[s+1][e]===i}:s=>t[s][e]<i),st=(t,e,i)=>et(t,i,(s=>t[s][e]>=i));function nt(t,e,i){let s=0,n=t.length;for(;s<n&&t[s]<e;)s++;for(;n>s&&t[n-1]>i;)n--;return s>0||n<t.length?t.slice(s,n):t}const ot=[\"push\",\"pop\",\"shift\",\"splice\",\"unshift\"];function at(t,e){t._chartjs?t._chartjs.listeners.push(e):(Object.defineProperty(t,\"_chartjs\",{configurable:!0,enumerable:!1,value:{listeners:[e]}}),ot.forEach((e=>{const i=\"_onData\"+w(e),s=t[e];Object.defineProperty(t,e,{configurable:!0,enumerable:!1,value(...e){const n=s.apply(this,e);return t._chartjs.listeners.forEach((t=>{\"function\"==typeof t[i]&&t[i](...e)})),n}})})))}function rt(t,e){const i=t._chartjs;if(!i)return;const s=i.listeners,n=s.indexOf(e);-1!==n&&s.splice(n,1),s.length>0||(ot.forEach((e=>{delete t[e]})),delete t._chartjs)}function lt(t){const e=new Set(t);return e.size===t.length?t:Array.from(e)}const ht=\"undefined\"==typeof window?function(t){return t()}:window.requestAnimationFrame;function ct(t,e){let i=[],s=!1;return function(...n){i=n,s||(s=!0,ht.call(window,(()=>{s=!1,t.apply(e,i)})))}}function dt(t,e){let i;return function(...s){return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}}const ut=t=>\"start\"===t?\"left\":\"end\"===t?\"right\":\"center\",ft=(t,e,i)=>\"start\"===t?e:\"end\"===t?i:(e+i)/2,gt=(t,e,i,s)=>t===(s?\"left\":\"right\")?i:\"center\"===t?(e+i)/2:e;function pt(t,e,i){const s=e.length;let n=0,o=s;if(t._sorted){const{iScale:a,_parsed:r}=t,l=a.axis,{min:h,max:c,minDefined:d,maxDefined:u}=a.getUserBounds();d&&(n=J(Math.min(it(r,l,h).lo,i?s:it(e,l,a.getPixelForValue(h)).lo),0,s-1)),o=u?J(Math.max(it(r,a.axis,c,!0).hi+1,i?0:it(e,l,a.getPixelForValue(c),!0).hi+1),n,s)-n:s-n}return{start:n,count:o}}function mt(t){const{xScale:e,yScale:i,_scaleRanges:s}=t,n={xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};if(!s)return t._scaleRanges=n,!0;const o=s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;return Object.assign(s,n),o}class bt{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,s){const n=e.listeners[s],o=e.duration;n.forEach((s=>s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)})))}_refresh(){this._request||(this._running=!0,this._request=ht.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(t=Date.now()){let e=0;this._charts.forEach(((i,s)=>{if(!i.running||!i.items.length)return;const n=i.items;let o,a=n.length-1,r=!1;for(;a>=0;--a)o=n[a],o._active?(o._total>i.duration&&(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());r&&(s.draw(),this._notify(s,i,t,\"progress\")),n.length||(i.running=!1,this._notify(s,i,t,\"complete\"),i.initial=!1),e+=n.length})),this._lastDate=t,0===e&&(this._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){e&&e.length&&this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);e&&(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce(((t,e)=>Math.max(t,e._duration)),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!!(e&&e.running&&e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let s=i.length-1;for(;s>=0;--s)i[s].cancel();e.items=[],this._notify(t,e,Date.now(),\"complete\")}remove(t){return this._charts.delete(t)}}var xt=new bt;\n/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */function _t(t){return t+.5|0}const yt=(t,e,i)=>Math.max(Math.min(t,i),e);function vt(t){return yt(_t(2.55*t),0,255)}function Mt(t){return yt(_t(255*t),0,255)}function wt(t){return yt(_t(t/2.55)/100,0,1)}function kt(t){return yt(_t(100*t),0,100)}const St={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},Pt=[...\"0123456789ABCDEF\"],Dt=t=>Pt[15&t],Ct=t=>Pt[(240&t)>>4]+Pt[15&t],Ot=t=>(240&t)>>4==(15&t);function At(t){var e=(t=>Ot(t.r)&&Ot(t.g)&&Ot(t.b)&&Ot(t.a))(t)?Dt:Ct;return t?\"#\"+e(t.r)+e(t.g)+e(t.b)+((t,e)=>t<255?e(t):\"\")(t.a,e):void 0}const Tt=/^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;function Lt(t,e,i){const s=e*Math.min(i,1-i),n=(e,n=(e+t/30)%12)=>i-s*Math.max(Math.min(n-3,9-n,1),-1);return[n(0),n(8),n(4)]}function Et(t,e,i){const s=(s,n=(s+t/60)%6)=>i-i*e*Math.max(Math.min(n,4-n,1),0);return[s(5),s(3),s(1)]}function Rt(t,e,i){const s=Lt(t,1,.5);let n;for(e+i>1&&(n=1/(e+i),e*=n,i*=n),n=0;n<3;n++)s[n]*=1-e-i,s[n]+=e;return s}function It(t){const e=t.r/255,i=t.g/255,s=t.b/255,n=Math.max(e,i,s),o=Math.min(e,i,s),a=(n+o)/2;let r,l,h;return n!==o&&(h=n-o,l=a>.5?h/(2-n-o):h/(n+o),r=function(t,e,i,s,n){return t===n?(e-i)/s+(e<i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}(e,i,s,h,n),r=60*r+.5),[0|r,l||0,a]}function zt(t,e,i,s){return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(Mt)}function Ft(t,e,i){return zt(Lt,t,e,i)}function Vt(t){return(t%360+360)%360}function Bt(t){const e=Tt.exec(t);let i,s=255;if(!e)return;e[5]!==i&&(s=e[6]?vt(+e[5]):Mt(+e[5]));const n=Vt(+e[2]),o=+e[3]/100,a=+e[4]/100;return i=\"hwb\"===e[1]?function(t,e,i){return zt(Rt,t,e,i)}(n,o,a):\"hsv\"===e[1]?function(t,e,i){return zt(Et,t,e,i)}(n,o,a):Ft(n,o,a),{r:i[0],g:i[1],b:i[2],a:s}}const Wt={x:\"dark\",Z:\"light\",Y:\"re\",X:\"blu\",W:\"gr\",V:\"medium\",U:\"slate\",A:\"ee\",T:\"ol\",S:\"or\",B:\"ra\",C:\"lateg\",D:\"ights\",R:\"in\",Q:\"turquois\",E:\"hi\",P:\"ro\",O:\"al\",N:\"le\",M:\"de\",L:\"yello\",F:\"en\",K:\"ch\",G:\"arks\",H:\"ea\",I:\"ightg\",J:\"wh\"},Nt={OiceXe:\"f0f8ff\",antiquewEte:\"faebd7\",aqua:\"ffff\",aquamarRe:\"7fffd4\",azuY:\"f0ffff\",beige:\"f5f5dc\",bisque:\"ffe4c4\",black:\"0\",blanKedOmond:\"ffebcd\",Xe:\"ff\",XeviTet:\"8a2be2\",bPwn:\"a52a2a\",burlywood:\"deb887\",caMtXe:\"5f9ea0\",KartYuse:\"7fff00\",KocTate:\"d2691e\",cSO:\"ff7f50\",cSnflowerXe:\"6495ed\",cSnsilk:\"fff8dc\",crimson:\"dc143c\",cyan:\"ffff\",xXe:\"8b\",xcyan:\"8b8b\",xgTMnPd:\"b8860b\",xWay:\"a9a9a9\",xgYF:\"6400\",xgYy:\"a9a9a9\",xkhaki:\"bdb76b\",xmagFta:\"8b008b\",xTivegYF:\"556b2f\",xSange:\"ff8c00\",xScEd:\"9932cc\",xYd:\"8b0000\",xsOmon:\"e9967a\",xsHgYF:\"8fbc8f\",xUXe:\"483d8b\",xUWay:\"2f4f4f\",xUgYy:\"2f4f4f\",xQe:\"ced1\",xviTet:\"9400d3\",dAppRk:\"ff1493\",dApskyXe:\"bfff\",dimWay:\"696969\",dimgYy:\"696969\",dodgerXe:\"1e90ff\",fiYbrick:\"b22222\",flSOwEte:\"fffaf0\",foYstWAn:\"228b22\",fuKsia:\"ff00ff\",gaRsbSo:\"dcdcdc\",ghostwEte:\"f8f8ff\",gTd:\"ffd700\",gTMnPd:\"daa520\",Way:\"808080\",gYF:\"8000\",gYFLw:\"adff2f\",gYy:\"808080\",honeyMw:\"f0fff0\",hotpRk:\"ff69b4\",RdianYd:\"cd5c5c\",Rdigo:\"4b0082\",ivSy:\"fffff0\",khaki:\"f0e68c\",lavFMr:\"e6e6fa\",lavFMrXsh:\"fff0f5\",lawngYF:\"7cfc00\",NmoncEffon:\"fffacd\",ZXe:\"add8e6\",ZcSO:\"f08080\",Zcyan:\"e0ffff\",ZgTMnPdLw:\"fafad2\",ZWay:\"d3d3d3\",ZgYF:\"90ee90\",ZgYy:\"d3d3d3\",ZpRk:\"ffb6c1\",ZsOmon:\"ffa07a\",ZsHgYF:\"20b2aa\",ZskyXe:\"87cefa\",ZUWay:\"778899\",ZUgYy:\"778899\",ZstAlXe:\"b0c4de\",ZLw:\"ffffe0\",lime:\"ff00\",limegYF:\"32cd32\",lRF:\"faf0e6\",magFta:\"ff00ff\",maPon:\"800000\",VaquamarRe:\"66cdaa\",VXe:\"cd\",VScEd:\"ba55d3\",VpurpN:\"9370db\",VsHgYF:\"3cb371\",VUXe:\"7b68ee\",VsprRggYF:\"fa9a\",VQe:\"48d1cc\",VviTetYd:\"c71585\",midnightXe:\"191970\",mRtcYam:\"f5fffa\",mistyPse:\"ffe4e1\",moccasR:\"ffe4b5\",navajowEte:\"ffdead\",navy:\"80\",Tdlace:\"fdf5e6\",Tive:\"808000\",TivedBb:\"6b8e23\",Sange:\"ffa500\",SangeYd:\"ff4500\",ScEd:\"da70d6\",pOegTMnPd:\"eee8aa\",pOegYF:\"98fb98\",pOeQe:\"afeeee\",pOeviTetYd:\"db7093\",papayawEp:\"ffefd5\",pHKpuff:\"ffdab9\",peru:\"cd853f\",pRk:\"ffc0cb\",plum:\"dda0dd\",powMrXe:\"b0e0e6\",purpN:\"800080\",YbeccapurpN:\"663399\",Yd:\"ff0000\",Psybrown:\"bc8f8f\",PyOXe:\"4169e1\",saddNbPwn:\"8b4513\",sOmon:\"fa8072\",sandybPwn:\"f4a460\",sHgYF:\"2e8b57\",sHshell:\"fff5ee\",siFna:\"a0522d\",silver:\"c0c0c0\",skyXe:\"87ceeb\",UXe:\"6a5acd\",UWay:\"708090\",UgYy:\"708090\",snow:\"fffafa\",sprRggYF:\"ff7f\",stAlXe:\"4682b4\",tan:\"d2b48c\",teO:\"8080\",tEstN:\"d8bfd8\",tomato:\"ff6347\",Qe:\"40e0d0\",viTet:\"ee82ee\",JHt:\"f5deb3\",wEte:\"ffffff\",wEtesmoke:\"f5f5f5\",Lw:\"ffff00\",LwgYF:\"9acd32\"};let Ht;function jt(t){Ht||(Ht=function(){const t={},e=Object.keys(Nt),i=Object.keys(Wt);let s,n,o,a,r;for(s=0;s<e.length;s++){for(a=r=e[s],n=0;n<i.length;n++)o=i[n],r=r.replace(o,Wt[o]);o=parseInt(Nt[a],16),t[r]=[o>>16&255,o>>8&255,255&o]}return t}(),Ht.transparent=[0,0,0,0]);const e=Ht[t.toLowerCase()];return e&&{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}const $t=/^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;const Yt=t=>t<=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,Ut=t=>t<=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);function Xt(t,e,i){if(t){let s=It(t);s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=Ft(s),t.r=s[0],t.g=s[1],t.b=s[2]}}function qt(t,e){return t?Object.assign(e||{},t):t}function Kt(t){var e={r:0,g:0,b:0,a:255};return Array.isArray(t)?t.length>=3&&(e={r:t[0],g:t[1],b:t[2],a:255},t.length>3&&(e.a=Mt(t[3]))):(e=qt(t,{r:0,g:0,b:0,a:1})).a=Mt(e.a),e}function Gt(t){return\"r\"===t.charAt(0)?function(t){const e=$t.exec(t);let i,s,n,o=255;if(e){if(e[7]!==i){const t=+e[7];o=e[8]?vt(t):yt(255*t,0,255)}return i=+e[1],s=+e[3],n=+e[5],i=255&(e[2]?vt(i):yt(i,0,255)),s=255&(e[4]?vt(s):yt(s,0,255)),n=255&(e[6]?vt(n):yt(n,0,255)),{r:i,g:s,b:n,a:o}}}(t):Bt(t)}class Zt{constructor(t){if(t instanceof Zt)return t;const e=typeof t;let i;var s,n,o;\"object\"===e?i=Kt(t):\"string\"===e&&(o=(s=t).length,\"#\"===s[0]&&(4===o||5===o?n={r:255&17*St[s[1]],g:255&17*St[s[2]],b:255&17*St[s[3]],a:5===o?17*St[s[4]]:255}:7!==o&&9!==o||(n={r:St[s[1]]<<4|St[s[2]],g:St[s[3]]<<4|St[s[4]],b:St[s[5]]<<4|St[s[6]],a:9===o?St[s[7]]<<4|St[s[8]]:255})),i=n||jt(t)||Gt(t)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=qt(this._rgb);return t&&(t.a=wt(t.a)),t}set rgb(t){this._rgb=Kt(t)}rgbString(){return this._valid?(t=this._rgb)&&(t.a<255?`rgba(${t.r}, ${t.g}, ${t.b}, ${wt(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;var t}hexString(){return this._valid?At(this._rgb):void 0}hslString(){return this._valid?function(t){if(!t)return;const e=It(t),i=e[0],s=kt(e[1]),n=kt(e[2]);return t.a<255?`hsla(${i}, ${s}%, ${n}%, ${wt(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}(this._rgb):void 0}mix(t,e){if(t){const i=this.rgb,s=t.rgb;let n;const o=e===n?.5:e,a=2*o-1,r=i.a-s.a,l=((a*r==-1?a:(a+r)/(1+a*r))+1)/2;n=1-l,i.r=255&l*i.r+n*s.r+.5,i.g=255&l*i.g+n*s.g+.5,i.b=255&l*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}return this}interpolate(t,e){return t&&(this._rgb=function(t,e,i){const s=Ut(wt(t.r)),n=Ut(wt(t.g)),o=Ut(wt(t.b));return{r:Mt(Yt(s+i*(Ut(wt(e.r))-s))),g:Mt(Yt(n+i*(Ut(wt(e.g))-n))),b:Mt(Yt(o+i*(Ut(wt(e.b))-o))),a:t.a+i*(e.a-t.a)}}(this._rgb,t._rgb,e)),this}clone(){return new Zt(this.rgb)}alpha(t){return this._rgb.a=Mt(t),this}clearer(t){return this._rgb.a*=1-t,this}greyscale(){const t=this._rgb,e=_t(.3*t.r+.59*t.g+.11*t.b);return t.r=t.g=t.b=e,this}opaquer(t){return this._rgb.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return Xt(this._rgb,2,t),this}darken(t){return Xt(this._rgb,2,-t),this}saturate(t){return Xt(this._rgb,1,t),this}desaturate(t){return Xt(this._rgb,1,-t),this}rotate(t){return function(t,e){var i=It(t);i[0]=Vt(i[0]+e),i=Ft(i),t.r=i[0],t.g=i[1],t.b=i[2]}(this._rgb,t),this}}function Jt(t){if(t&&\"object\"==typeof t){const e=t.toString();return\"[object CanvasPattern]\"===e||\"[object CanvasGradient]\"===e}return!1}function Qt(t){return Jt(t)?t:new Zt(t)}function te(t){return Jt(t)?t:new Zt(t).saturate(.5).darken(.1).hexString()}const ee=[\"x\",\"y\",\"borderWidth\",\"radius\",\"tension\"],ie=[\"color\",\"borderColor\",\"backgroundColor\"];const se=new Map;function ne(t,e,i){return function(t,e){e=e||{};const i=t+JSON.stringify(e);let s=se.get(i);return s||(s=new Intl.NumberFormat(t,e),se.set(i,s)),s}(e,i).format(t)}const oe={values:t=>n(t)?t:\"\"+t,numeric(t,e,i){if(0===t)return\"0\";const s=this.chart.options.locale;let n,o=t;if(i.length>1){const e=Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));(e<1e-4||e>1e15)&&(n=\"scientific\"),o=function(t,e){let i=e.length>3?e[2].value-e[1].value:e[1].value-e[0].value;Math.abs(i)>=1&&t!==Math.floor(t)&&(i=t-Math.floor(t));return i}(t,i)}const a=z(Math.abs(o)),r=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),l={notation:n,minimumFractionDigits:r,maximumFractionDigits:r};return Object.assign(l,this.options.ticks.format),ne(t,s,l)},logarithmic(t,e,i){if(0===t)return\"0\";const s=i[e].significand||t/Math.pow(10,Math.floor(z(t)));return[1,2,3,5,10,15].includes(s)||e>.8*i.length?oe.numeric.call(this,t,e,i):\"\"}};var ae={formatters:oe};const re=Object.create(null),le=Object.create(null);function he(t,e){if(!e)return t;const i=e.split(\".\");for(let e=0,s=i.length;e<s;++e){const s=i[e];t=t[s]||(t[s]=Object.create(null))}return t}function ce(t,e,i){return\"string\"==typeof e?b(he(t,e),i):b(he(t,\"\"),e)}class de{constructor(t,e){this.animation=void 0,this.backgroundColor=\"rgba(0,0,0,0.1)\",this.borderColor=\"rgba(0,0,0,0.1)\",this.color=\"#666\",this.datasets={},this.devicePixelRatio=t=>t.chart.platform.getDevicePixelRatio(),this.elements={},this.events=[\"mousemove\",\"mouseout\",\"click\",\"touchstart\",\"touchmove\"],this.font={family:\"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",size:12,style:\"normal\",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(t,e)=>te(e.backgroundColor),this.hoverBorderColor=(t,e)=>te(e.borderColor),this.hoverColor=(t,e)=>te(e.color),this.indexAxis=\"x\",this.interaction={mode:\"nearest\",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}set(t,e){return ce(this,t,e)}get(t){return he(this,t)}describe(t,e){return ce(le,t,e)}override(t,e){return ce(re,t,e)}route(t,e,i,s){const n=he(this,t),a=he(this,i),r=\"_\"+e;Object.defineProperties(n,{[r]:{value:n[e],writable:!0},[e]:{enumerable:!0,get(){const t=this[r],e=a[s];return o(t)?Object.assign({},e,t):l(t,e)},set(t){this[r]=t}}})}apply(t){t.forEach((t=>t(this)))}}var ue=new de({_scriptable:t=>!t.startsWith(\"on\"),_indexable:t=>\"events\"!==t,hover:{_fallback:\"interaction\"},interaction:{_scriptable:!1,_indexable:!1}},[function(t){t.set(\"animation\",{delay:void 0,duration:1e3,easing:\"easeOutQuart\",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe(\"animation\",{_fallback:!1,_indexable:!1,_scriptable:t=>\"onProgress\"!==t&&\"onComplete\"!==t&&\"fn\"!==t}),t.set(\"animations\",{colors:{type:\"color\",properties:ie},numbers:{type:\"number\",properties:ee}}),t.describe(\"animations\",{_fallback:\"animation\"}),t.set(\"transitions\",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:\"transparent\"},visible:{type:\"boolean\",duration:0}}},hide:{animations:{colors:{to:\"transparent\"},visible:{type:\"boolean\",easing:\"linear\",fn:t=>0|t}}}})},function(t){t.set(\"layout\",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(t){t.set(\"scale\",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:\"ticks\",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(t,e)=>e.lineWidth,tickColor:(t,e)=>e.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:\"\",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:\"\",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:ae.formatters.values,minor:{},major:{},align:\"center\",crossAlign:\"near\",showLabelBackdrop:!1,backdropColor:\"rgba(255, 255, 255, 0.75)\",backdropPadding:2}}),t.route(\"scale.ticks\",\"color\",\"\",\"color\"),t.route(\"scale.grid\",\"color\",\"\",\"borderColor\"),t.route(\"scale.border\",\"color\",\"\",\"borderColor\"),t.route(\"scale.title\",\"color\",\"\",\"color\"),t.describe(\"scale\",{_fallback:!1,_scriptable:t=>!t.startsWith(\"before\")&&!t.startsWith(\"after\")&&\"callback\"!==t&&\"parser\"!==t,_indexable:t=>\"borderDash\"!==t&&\"tickBorderDash\"!==t&&\"dash\"!==t}),t.describe(\"scales\",{_fallback:\"scale\"}),t.describe(\"scale.ticks\",{_scriptable:t=>\"backdropPadding\"!==t&&\"callback\"!==t,_indexable:t=>\"backdropPadding\"!==t})}]);function fe(){return\"undefined\"!=typeof window&&\"undefined\"!=typeof document}function ge(t){let e=t.parentNode;return e&&\"[object ShadowRoot]\"===e.toString()&&(e=e.host),e}function pe(t,e,i){let s;return\"string\"==typeof t?(s=parseInt(t,10),-1!==t.indexOf(\"%\")&&(s=s/100*e.parentNode[i])):s=t,s}const me=t=>t.ownerDocument.defaultView.getComputedStyle(t,null);function be(t,e){return me(t).getPropertyValue(e)}const xe=[\"top\",\"right\",\"bottom\",\"left\"];function _e(t,e,i){const s={};i=i?\"-\"+i:\"\";for(let n=0;n<4;n++){const o=xe[n];s[o]=parseFloat(t[e+\"-\"+o+i])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}const ye=(t,e,i)=>(t>0||e>0)&&(!i||!i.shadowRoot);function ve(t,e){if(\"native\"in t)return t;const{canvas:i,currentDevicePixelRatio:s}=e,n=me(i),o=\"border-box\"===n.boxSizing,a=_e(n,\"padding\"),r=_e(n,\"border\",\"width\"),{x:l,y:h,box:c}=function(t,e){const i=t.touches,s=i&&i.length?i[0]:t,{offsetX:n,offsetY:o}=s;let a,r,l=!1;if(ye(n,o,t.target))a=n,r=o;else{const t=e.getBoundingClientRect();a=s.clientX-t.left,r=s.clientY-t.top,l=!0}return{x:a,y:r,box:l}}(t,i),d=a.left+(c&&r.left),u=a.top+(c&&r.top);let{width:f,height:g}=e;return o&&(f-=a.width+r.width,g-=a.height+r.height),{x:Math.round((l-d)/f*i.width/s),y:Math.round((h-u)/g*i.height/s)}}const Me=t=>Math.round(10*t)/10;function we(t,e,i,s){const n=me(t),o=_e(n,\"margin\"),a=pe(n.maxWidth,t,\"clientWidth\")||T,r=pe(n.maxHeight,t,\"clientHeight\")||T,l=function(t,e,i){let s,n;if(void 0===e||void 0===i){const o=ge(t);if(o){const t=o.getBoundingClientRect(),a=me(o),r=_e(a,\"border\",\"width\"),l=_e(a,\"padding\");e=t.width-l.width-r.width,i=t.height-l.height-r.height,s=pe(a.maxWidth,o,\"clientWidth\"),n=pe(a.maxHeight,o,\"clientHeight\")}else e=t.clientWidth,i=t.clientHeight}return{width:e,height:i,maxWidth:s||T,maxHeight:n||T}}(t,e,i);let{width:h,height:c}=l;if(\"content-box\"===n.boxSizing){const t=_e(n,\"border\",\"width\"),e=_e(n,\"padding\");h-=e.width+t.width,c-=e.height+t.height}h=Math.max(0,h-o.width),c=Math.max(0,s?h/s:c-o.height),h=Me(Math.min(h,a,l.maxWidth)),c=Me(Math.min(c,r,l.maxHeight)),h&&!c&&(c=Me(h/2));return(void 0!==e||void 0!==i)&&s&&l.height&&c>l.height&&(c=l.height,h=Me(Math.floor(c*s))),{width:h,height:c}}function ke(t,e,i){const s=e||1,n=Math.floor(t.height*s),o=Math.floor(t.width*s);t.height=Math.floor(t.height),t.width=Math.floor(t.width);const a=t.canvas;return a.style&&(i||!a.style.height&&!a.style.width)&&(a.style.height=`${t.height}px`,a.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||a.height!==n||a.width!==o)&&(t.currentDevicePixelRatio=s,a.height=n,a.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}const Se=function(){let t=!1;try{const e={get passive(){return t=!0,!1}};fe()&&(window.addEventListener(\"test\",null,e),window.removeEventListener(\"test\",null,e))}catch(t){}return t}();function Pe(t,e){const i=be(t,e),s=i&&i.match(/^(\\d+)(\\.\\d+)?px$/);return s?+s[1]:void 0}function De(t){return!t||s(t.size)||s(t.family)?null:(t.style?t.style+\" \":\"\")+(t.weight?t.weight+\" \":\"\")+t.size+\"px \"+t.family}function Ce(t,e,i,s,n){let o=e[n];return o||(o=e[n]=t.measureText(n).width,i.push(n)),o>s&&(s=o),s}function Oe(t,e,i,s){let o=(s=s||{}).data=s.data||{},a=s.garbageCollect=s.garbageCollect||[];s.font!==e&&(o=s.data={},a=s.garbageCollect=[],s.font=e),t.save(),t.font=e;let r=0;const l=i.length;let h,c,d,u,f;for(h=0;h<l;h++)if(u=i[h],null==u||n(u)){if(n(u))for(c=0,d=u.length;c<d;c++)f=u[c],null==f||n(f)||(r=Ce(t,o,a,r,f))}else r=Ce(t,o,a,r,u);t.restore();const g=a.length/2;if(g>i.length){for(h=0;h<g;h++)delete o[a[h]];a.splice(0,g)}return r}function Ae(t,e,i){const s=t.currentDevicePixelRatio,n=0!==i?Math.max(i/2,.5):0;return Math.round((e-n)*s)/s+n}function Te(t,e){(e=e||t.getContext(\"2d\")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore()}function Le(t,e,i,s){Ee(t,e,i,s,null)}function Ee(t,e,i,s,n){let o,a,r,l,h,c,d,u;const f=e.pointStyle,g=e.rotation,p=e.radius;let m=(g||0)*L;if(f&&\"object\"==typeof f&&(o=f.toString(),\"[object HTMLImageElement]\"===o||\"[object HTMLCanvasElement]\"===o))return t.save(),t.translate(i,s),t.rotate(m),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();if(!(isNaN(p)||p<=0)){switch(t.beginPath(),f){default:n?t.ellipse(i,s,n/2,p,0,0,O):t.arc(i,s,p,0,O),t.closePath();break;case\"triangle\":c=n?n/2:p,t.moveTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),m+=I,t.lineTo(i+Math.sin(m)*c,s-Math.cos(m)*p),t.closePath();break;case\"rectRounded\":h=.516*p,l=p-h,a=Math.cos(m+R)*l,d=Math.cos(m+R)*(n?n/2-h:l),r=Math.sin(m+R)*l,u=Math.sin(m+R)*(n?n/2-h:l),t.arc(i-d,s-r,h,m-C,m-E),t.arc(i+u,s-a,h,m-E,m),t.arc(i+d,s+r,h,m,m+E),t.arc(i-u,s+a,h,m+E,m+C),t.closePath();break;case\"rect\":if(!g){l=Math.SQRT1_2*p,c=n?n/2:l,t.rect(i-c,s-l,2*c,2*l);break}m+=R;case\"rectRot\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+u,s-a),t.lineTo(i+d,s+r),t.lineTo(i-u,s+a),t.closePath();break;case\"crossRot\":m+=R;case\"cross\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"star\":d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a),m+=R,d=Math.cos(m)*(n?n/2:p),a=Math.cos(m)*p,r=Math.sin(m)*p,u=Math.sin(m)*(n?n/2:p),t.moveTo(i-d,s-r),t.lineTo(i+d,s+r),t.moveTo(i+u,s-a),t.lineTo(i-u,s+a);break;case\"line\":a=n?n/2:Math.cos(m)*p,r=Math.sin(m)*p,t.moveTo(i-a,s-r),t.lineTo(i+a,s+r);break;case\"dash\":t.moveTo(i,s),t.lineTo(i+Math.cos(m)*(n?n/2:p),s+Math.sin(m)*p);break;case!1:t.closePath()}t.fill(),e.borderWidth>0&&t.stroke()}}function Re(t,e,i){return i=i||.5,!e||t&&t.x>e.left-i&&t.x<e.right+i&&t.y>e.top-i&&t.y<e.bottom+i}function Ie(t,e){t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}function ze(t){t.restore()}function Fe(t,e,i,s,n){if(!e)return t.lineTo(i.x,i.y);if(\"middle\"===n){const s=(e.x+i.x)/2;t.lineTo(s,e.y),t.lineTo(s,i.y)}else\"after\"===n!=!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);t.lineTo(i.x,i.y)}function Ve(t,e,i,s){if(!e)return t.lineTo(i.x,i.y);t.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}function Be(t,e,i,s,n){if(n.strikethrough||n.underline){const o=t.measureText(s),a=e-o.actualBoundingBoxLeft,r=e+o.actualBoundingBoxRight,l=i-o.actualBoundingBoxAscent,h=i+o.actualBoundingBoxDescent,c=n.strikethrough?(l+h)/2:h;t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(a,c),t.lineTo(r,c),t.stroke()}}function We(t,e){const i=t.fillStyle;t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}function Ne(t,e,i,o,a,r={}){const l=n(e)?e:[e],h=r.strokeWidth>0&&\"\"!==r.strokeColor;let c,d;for(t.save(),t.font=a.string,function(t,e){e.translation&&t.translate(e.translation[0],e.translation[1]),s(e.rotation)||t.rotate(e.rotation),e.color&&(t.fillStyle=e.color),e.textAlign&&(t.textAlign=e.textAlign),e.textBaseline&&(t.textBaseline=e.textBaseline)}(t,r),c=0;c<l.length;++c)d=l[c],r.backdrop&&We(t,r.backdrop),h&&(r.strokeColor&&(t.strokeStyle=r.strokeColor),s(r.strokeWidth)||(t.lineWidth=r.strokeWidth),t.strokeText(d,i,o,r.maxWidth)),t.fillText(d,i,o,r.maxWidth),Be(t,i,o,d,r),o+=Number(a.lineHeight);t.restore()}function He(t,e){const{x:i,y:s,w:n,h:o,radius:a}=e;t.arc(i+a.topLeft,s+a.topLeft,a.topLeft,1.5*C,C,!0),t.lineTo(i,s+o-a.bottomLeft),t.arc(i+a.bottomLeft,s+o-a.bottomLeft,a.bottomLeft,C,E,!0),t.lineTo(i+n-a.bottomRight,s+o),t.arc(i+n-a.bottomRight,s+o-a.bottomRight,a.bottomRight,E,0,!0),t.lineTo(i+n,s+a.topRight),t.arc(i+n-a.topRight,s+a.topRight,a.topRight,0,-E,!0),t.lineTo(i+a.topLeft,s)}function je(t,e=[\"\"],i,s,n=(()=>t[0])){const o=i||t;void 0===s&&(s=ti(\"_fallback\",t));const a={[Symbol.toStringTag]:\"Object\",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:i=>je([i,...t],e,o,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete e._keys,delete t[0][i],!0),get:(i,s)=>qe(i,s,(()=>function(t,e,i,s){let n;for(const o of e)if(n=ti(Ue(o,t),i),void 0!==n)return Xe(t,n)?Je(i,s,t,n):n}(s,e,t,i))),getOwnPropertyDescriptor:(t,e)=>Reflect.getOwnPropertyDescriptor(t._scopes[0],e),getPrototypeOf:()=>Reflect.getPrototypeOf(t[0]),has:(t,e)=>ei(t).includes(e),ownKeys:t=>ei(t),set(t,e,i){const s=t._storage||(t._storage=n());return t[e]=s[e]=i,delete t._keys,!0}})}function $e(t,e,i,s){const a={_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ye(t,s),setContext:e=>$e(t,e,i,s),override:n=>$e(t.override(n),e,i,s)};return new Proxy(a,{deleteProperty:(e,i)=>(delete e[i],delete t[i],!0),get:(t,e,i)=>qe(t,e,(()=>function(t,e,i){const{_proxy:s,_context:a,_subProxy:r,_descriptors:l}=t;let h=s[e];S(h)&&l.isScriptable(e)&&(h=function(t,e,i,s){const{_proxy:n,_context:o,_subProxy:a,_stack:r}=i;if(r.has(t))throw new Error(\"Recursion detected: \"+Array.from(r).join(\"->\")+\"->\"+t);r.add(t);let l=e(o,a||s);r.delete(t),Xe(t,l)&&(l=Je(n._scopes,n,t,l));return l}(e,h,t,i));n(h)&&h.length&&(h=function(t,e,i,s){const{_proxy:n,_context:a,_subProxy:r,_descriptors:l}=i;if(void 0!==a.index&&s(t))return e[a.index%e.length];if(o(e[0])){const i=e,s=n._scopes.filter((t=>t!==i));e=[];for(const o of i){const i=Je(s,n,t,o);e.push($e(i,a,r&&r[t],l))}}return e}(e,h,t,l.isIndexable));Xe(e,h)&&(h=$e(h,a,r&&r[e],l));return h}(t,e,i))),getOwnPropertyDescriptor:(e,i)=>e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),getPrototypeOf:()=>Reflect.getPrototypeOf(t),has:(e,i)=>Reflect.has(t,i),ownKeys:()=>Reflect.ownKeys(t),set:(e,i,s)=>(t[i]=s,delete e[i],!0)})}function Ye(t,e={scriptable:!0,indexable:!0}){const{_scriptable:i=e.scriptable,_indexable:s=e.indexable,_allKeys:n=e.allKeys}=t;return{allKeys:n,scriptable:i,indexable:s,isScriptable:S(i)?i:()=>i,isIndexable:S(s)?s:()=>s}}const Ue=(t,e)=>t?t+w(e):e,Xe=(t,e)=>o(e)&&\"adapters\"!==t&&(null===Object.getPrototypeOf(e)||e.constructor===Object);function qe(t,e,i){if(Object.prototype.hasOwnProperty.call(t,e))return t[e];const s=i();return t[e]=s,s}function Ke(t,e,i){return S(t)?t(e,i):t}const Ge=(t,e)=>!0===t?e:\"string\"==typeof t?M(e,t):void 0;function Ze(t,e,i,s,n){for(const o of e){const e=Ge(i,o);if(e){t.add(e);const o=Ke(e._fallback,i,n);if(void 0!==o&&o!==i&&o!==s)return o}else if(!1===e&&void 0!==s&&i!==s)return null}return!1}function Je(t,e,i,s){const a=e._rootScopes,r=Ke(e._fallback,i,s),l=[...t,...a],h=new Set;h.add(s);let c=Qe(h,l,i,r||i,s);return null!==c&&((void 0===r||r===i||(c=Qe(h,l,r,c,s),null!==c))&&je(Array.from(h),[\"\"],a,r,(()=>function(t,e,i){const s=t._getTarget();e in s||(s[e]={});const a=s[e];if(n(a)&&o(i))return i;return a||{}}(e,i,s))))}function Qe(t,e,i,s,n){for(;i;)i=Ze(t,e,i,s,n);return i}function ti(t,e){for(const i of e){if(!i)continue;const e=i[t];if(void 0!==e)return e}}function ei(t){let e=t._keys;return e||(e=t._keys=function(t){const e=new Set;for(const i of t)for(const t of Object.keys(i).filter((t=>!t.startsWith(\"_\"))))e.add(t);return Array.from(e)}(t._scopes)),e}function ii(t,e,i,s){const{iScale:n}=t,{key:o=\"r\"}=this._parsing,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={r:n.parse(M(c,o),h)};return a}const si=Number.EPSILON||1e-14,ni=(t,e)=>e<t.length&&!t[e].skip&&t[e],oi=t=>\"x\"===t?\"y\":\"x\";function ai(t,e,i,s){const n=t.skip?e:t,o=e,a=i.skip?e:i,r=q(o,n),l=q(a,o);let h=r/(r+l),c=l/(r+l);h=isNaN(h)?0:h,c=isNaN(c)?0:c;const d=s*h,u=s*c;return{previous:{x:o.x-d*(a.x-n.x),y:o.y-d*(a.y-n.y)},next:{x:o.x+u*(a.x-n.x),y:o.y+u*(a.y-n.y)}}}function ri(t,e=\"x\"){const i=oi(e),s=t.length,n=Array(s).fill(0),o=Array(s);let a,r,l,h=ni(t,0);for(a=0;a<s;++a)if(r=l,l=h,h=ni(t,a+1),l){if(h){const t=h[e]-l[e];n[a]=0!==t?(h[i]-l[i])/t:0}o[a]=r?h?F(n[a-1])!==F(n[a])?0:(n[a-1]+n[a])/2:n[a-1]:n[a]}!function(t,e,i){const s=t.length;let n,o,a,r,l,h=ni(t,0);for(let c=0;c<s-1;++c)l=h,h=ni(t,c+1),l&&h&&(V(e[c],0,si)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],r=Math.pow(n,2)+Math.pow(o,2),r<=9||(a=3/Math.sqrt(r),i[c]=n*a*e[c],i[c+1]=o*a*e[c])))}(t,n,o),function(t,e,i=\"x\"){const s=oi(i),n=t.length;let o,a,r,l=ni(t,0);for(let h=0;h<n;++h){if(a=r,r=l,l=ni(t,h+1),!r)continue;const n=r[i],c=r[s];a&&(o=(n-a[i])/3,r[`cp1${i}`]=n-o,r[`cp1${s}`]=c-o*e[h]),l&&(o=(l[i]-n)/3,r[`cp2${i}`]=n+o,r[`cp2${s}`]=c+o*e[h])}}(t,o,e)}function li(t,e,i){return Math.max(Math.min(t,i),e)}function hi(t,e,i,s,n){let o,a,r,l;if(e.spanGaps&&(t=t.filter((t=>!t.skip))),\"monotone\"===e.cubicInterpolationMode)ri(t,n);else{let i=s?t[t.length-1]:t[0];for(o=0,a=t.length;o<a;++o)r=t[o],l=ai(i,r,t[Math.min(o+1,a-(s?0:1))%a],e.tension),r.cp1x=l.previous.x,r.cp1y=l.previous.y,r.cp2x=l.next.x,r.cp2y=l.next.y,i=r}e.capBezierPoints&&function(t,e){let i,s,n,o,a,r=Re(t[0],e);for(i=0,s=t.length;i<s;++i)a=o,o=r,r=i<s-1&&Re(t[i+1],e),o&&(n=t[i],a&&(n.cp1x=li(n.cp1x,e.left,e.right),n.cp1y=li(n.cp1y,e.top,e.bottom)),r&&(n.cp2x=li(n.cp2x,e.left,e.right),n.cp2y=li(n.cp2y,e.top,e.bottom)))}(t,i)}const ci=t=>0===t||1===t,di=(t,e,i)=>-Math.pow(2,10*(t-=1))*Math.sin((t-e)*O/i),ui=(t,e,i)=>Math.pow(2,-10*t)*Math.sin((t-e)*O/i)+1,fi={linear:t=>t,easeInQuad:t=>t*t,easeOutQuad:t=>-t*(t-2),easeInOutQuad:t=>(t/=.5)<1?.5*t*t:-.5*(--t*(t-2)-1),easeInCubic:t=>t*t*t,easeOutCubic:t=>(t-=1)*t*t+1,easeInOutCubic:t=>(t/=.5)<1?.5*t*t*t:.5*((t-=2)*t*t+2),easeInQuart:t=>t*t*t*t,easeOutQuart:t=>-((t-=1)*t*t*t-1),easeInOutQuart:t=>(t/=.5)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),easeInQuint:t=>t*t*t*t*t,easeOutQuint:t=>(t-=1)*t*t*t*t+1,easeInOutQuint:t=>(t/=.5)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),easeInSine:t=>1-Math.cos(t*E),easeOutSine:t=>Math.sin(t*E),easeInOutSine:t=>-.5*(Math.cos(C*t)-1),easeInExpo:t=>0===t?0:Math.pow(2,10*(t-1)),easeOutExpo:t=>1===t?1:1-Math.pow(2,-10*t),easeInOutExpo:t=>ci(t)?t:t<.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),easeInCirc:t=>t>=1?t:-(Math.sqrt(1-t*t)-1),easeOutCirc:t=>Math.sqrt(1-(t-=1)*t),easeInOutCirc:t=>(t/=.5)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),easeInElastic:t=>ci(t)?t:di(t,.075,.3),easeOutElastic:t=>ci(t)?t:ui(t,.075,.3),easeInOutElastic(t){const e=.1125;return ci(t)?t:t<.5?.5*di(2*t,e,.45):.5+.5*ui(2*t-1,e,.45)},easeInBack(t){const e=1.70158;return t*t*((e+1)*t-e)},easeOutBack(t){const e=1.70158;return(t-=1)*t*((e+1)*t+e)+1},easeInOutBack(t){let e=1.70158;return(t/=.5)<1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)},easeInBounce:t=>1-fi.easeOutBounce(1-t),easeOutBounce(t){const e=7.5625,i=2.75;return t<1/i?e*t*t:t<2/i?e*(t-=1.5/i)*t+.75:t<2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375},easeInOutBounce:t=>t<.5?.5*fi.easeInBounce(2*t):.5*fi.easeOutBounce(2*t-1)+.5};function gi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}function pi(t,e,i,s){return{x:t.x+i*(e.x-t.x),y:\"middle\"===s?i<.5?t.y:e.y:\"after\"===s?i<1?t.y:e.y:i>0?e.y:t.y}}function mi(t,e,i,s){const n={x:t.cp2x,y:t.cp2y},o={x:e.cp1x,y:e.cp1y},a=gi(t,n,i),r=gi(n,o,i),l=gi(o,e,i),h=gi(a,r,i),c=gi(r,l,i);return gi(h,c,i)}const bi=/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/,xi=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function _i(t,e){const i=(\"\"+t).match(bi);if(!i||\"normal\"===i[1])return 1.2*e;switch(t=+i[2],i[3]){case\"px\":return t;case\"%\":t/=100}return e*t}const yi=t=>+t||0;function vi(t,e){const i={},s=o(e),n=s?Object.keys(e):e,a=o(t)?s?i=>l(t[i],t[e[i]]):e=>t[e]:()=>t;for(const t of n)i[t]=yi(a(t));return i}function Mi(t){return vi(t,{top:\"y\",right:\"x\",bottom:\"y\",left:\"x\"})}function wi(t){return vi(t,[\"topLeft\",\"topRight\",\"bottomLeft\",\"bottomRight\"])}function ki(t){const e=Mi(t);return e.width=e.left+e.right,e.height=e.top+e.bottom,e}function Si(t,e){t=t||{},e=e||ue.font;let i=l(t.size,e.size);\"string\"==typeof i&&(i=parseInt(i,10));let s=l(t.style,e.style);s&&!(\"\"+s).match(xi)&&(console.warn('Invalid font style specified: \"'+s+'\"'),s=void 0);const n={family:l(t.family,e.family),lineHeight:_i(l(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:l(t.weight,e.weight),string:\"\"};return n.string=De(n),n}function Pi(t,e,i,s){let o,a,r,l=!0;for(o=0,a=t.length;o<a;++o)if(r=t[o],void 0!==r&&(void 0!==e&&\"function\"==typeof r&&(r=r(e),l=!1),void 0!==i&&n(r)&&(r=r[i%r.length],l=!1),void 0!==r))return s&&!l&&(s.cacheable=!1),r}function Di(t,e,i){const{min:s,max:n}=t,o=c(e,(n-s)/2),a=(t,e)=>i&&0===t?0:t+e;return{min:a(s,-Math.abs(o)),max:a(n,o)}}function Ci(t,e){return Object.assign(Object.create(t),e)}function Oi(t,e,i){return t?function(t,e){return{x:i=>t+t+e-i,setWidth(t){e=t},textAlign:t=>\"center\"===t?t:\"right\"===t?\"left\":\"right\",xPlus:(t,e)=>t-e,leftForLtr:(t,e)=>t-e}}(e,i):{x:t=>t,setWidth(t){},textAlign:t=>t,xPlus:(t,e)=>t+e,leftForLtr:(t,e)=>t}}function Ai(t,e){let i,s;\"ltr\"!==e&&\"rtl\"!==e||(i=t.canvas.style,s=[i.getPropertyValue(\"direction\"),i.getPropertyPriority(\"direction\")],i.setProperty(\"direction\",e,\"important\"),t.prevTextDirection=s)}function Ti(t,e){void 0!==e&&(delete t.prevTextDirection,t.canvas.style.setProperty(\"direction\",e[0],e[1]))}function Li(t){return\"angle\"===t?{between:Z,compare:K,normalize:G}:{between:tt,compare:(t,e)=>t-e,normalize:t=>t}}function Ei({start:t,end:e,count:i,loop:s,style:n}){return{start:t%i,end:e%i,loop:s&&(e-t+1)%i==0,style:n}}function Ri(t,e,i){if(!i)return[t];const{property:s,start:n,end:o}=i,a=e.length,{compare:r,between:l,normalize:h}=Li(s),{start:c,end:d,loop:u,style:f}=function(t,e,i){const{property:s,start:n,end:o}=i,{between:a,normalize:r}=Li(s),l=e.length;let h,c,{start:d,end:u,loop:f}=t;if(f){for(d+=l,u+=l,h=0,c=l;h<c&&a(r(e[d%l][s]),n,o);++h)d--,u--;d%=l,u%=l}return u<d&&(u+=l),{start:d,end:u,loop:f,style:t.style}}(t,e,i),g=[];let p,m,b,x=!1,_=null;const y=()=>x||l(n,b,p)&&0!==r(n,b),v=()=>!x||0===r(o,p)||l(o,b,p);for(let t=c,i=c;t<=d;++t)m=e[t%a],m.skip||(p=h(m[s]),p!==b&&(x=l(p,n,o),null===_&&y()&&(_=0===r(p,n)?t:i),null!==_&&v()&&(g.push(Ei({start:_,end:t,loop:u,count:a,style:f})),_=null),i=t,b=p));return null!==_&&g.push(Ei({start:_,end:d,loop:u,count:a,style:f})),g}function Ii(t,e){const i=[],s=t.segments;for(let n=0;n<s.length;n++){const o=Ri(s[n],t.points,e);o.length&&i.push(...o)}return i}function zi(t,e){const i=t.points,s=t.options.spanGaps,n=i.length;if(!n)return[];const o=!!t._loop,{start:a,end:r}=function(t,e,i,s){let n=0,o=e-1;if(i&&!s)for(;n<e&&!t[n].skip;)n++;for(;n<e&&t[n].skip;)n++;for(n%=e,i&&(o+=n);o>n&&t[o%e].skip;)o--;return o%=e,{start:n,end:o}}(i,n,o,s);if(!0===s)return Fi(t,[{start:a,end:r,loop:o}],i,e);return Fi(t,function(t,e,i,s){const n=t.length,o=[];let a,r=e,l=t[e];for(a=e+1;a<=i;++a){const i=t[a%n];i.skip||i.stop?l.skip||(s=!1,o.push({start:e%n,end:(a-1)%n,loop:s}),e=r=i.stop?a:null):(r=a,l.skip&&(e=a)),l=i}return null!==r&&o.push({start:e%n,end:r%n,loop:s}),o}(i,a,r<a?r+n:r,!!t._fullLoop&&0===a&&r===n-1),i,e)}function Fi(t,e,i,s){return s&&s.setContext&&i?function(t,e,i,s){const n=t._chart.getContext(),o=Vi(t.options),{_datasetIndex:a,options:{spanGaps:r}}=t,l=i.length,h=[];let c=o,d=e[0].start,u=d;function f(t,e,s,n){const o=r?-1:1;if(t!==e){for(t+=l;i[t%l].skip;)t-=o;for(;i[e%l].skip;)e+=o;t%l!=e%l&&(h.push({start:t%l,end:e%l,loop:s,style:n}),c=n,d=e%l)}}for(const t of e){d=r?d:t.start;let e,o=i[d%l];for(u=d+1;u<=t.end;u++){const r=i[u%l];e=Vi(s.setContext(Ci(n,{type:\"segment\",p0:o,p1:r,p0DataIndex:(u-1)%l,p1DataIndex:u%l,datasetIndex:a}))),Bi(e,c)&&f(d,u-1,t.loop,c),o=r,c=e}d<u-1&&f(d,u-1,t.loop,c)}return h}(t,e,i,s):e}function Vi(t){return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}function Bi(t,e){if(!e)return!1;const i=[],s=function(t,e){return Jt(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e};return JSON.stringify(t,s)!==JSON.stringify(e,s)}var Wi=Object.freeze({__proto__:null,HALF_PI:E,INFINITY:T,PI:C,PITAU:A,QUARTER_PI:R,RAD_PER_DEG:L,TAU:O,TWO_THIRDS_PI:I,_addGrace:Di,_alignPixel:Ae,_alignStartEnd:ft,_angleBetween:Z,_angleDiff:K,_arrayUnique:lt,_attachContext:$e,_bezierCurveTo:Ve,_bezierInterpolation:mi,_boundSegment:Ri,_boundSegments:Ii,_capitalize:w,_computeSegments:zi,_createResolver:je,_decimalPlaces:U,_deprecated:function(t,e,i,s){void 0!==e&&console.warn(t+': \"'+i+'\" is deprecated. Please use \"'+s+'\" instead')},_descriptors:Ye,_elementsEqual:f,_factorize:W,_filterBetween:nt,_getParentNode:ge,_getStartAndCountOfVisiblePoints:pt,_int16Range:Q,_isBetween:tt,_isClickEvent:D,_isDomSupported:fe,_isPointInArea:Re,_limitValue:J,_longestText:Oe,_lookup:et,_lookupByKey:it,_measureText:Ce,_merger:m,_mergerIf:_,_normalizeAngle:G,_parseObjectDataRadialScale:ii,_pointInLine:gi,_readValueToProps:vi,_rlookupByKey:st,_scaleRangesChanged:mt,_setMinAndMaxByKey:j,_splitKey:v,_steppedInterpolation:pi,_steppedLineTo:Fe,_textX:gt,_toLeftRightCenter:ut,_updateBezierControlPoints:hi,addRoundedRectPath:He,almostEquals:V,almostWhole:H,callback:d,clearCanvas:Te,clipArea:Ie,clone:g,color:Qt,createContext:Ci,debounce:dt,defined:k,distanceBetweenPoints:q,drawPoint:Le,drawPointLegend:Ee,each:u,easingEffects:fi,finiteOrDefault:r,fontString:function(t,e,i){return e+\" \"+t+\"px \"+i},formatNumber:ne,getAngleFromPoint:X,getHoverColor:te,getMaximumSize:we,getRelativePosition:ve,getRtlAdapter:Oi,getStyle:be,isArray:n,isFinite:a,isFunction:S,isNullOrUndef:s,isNumber:N,isObject:o,isPatternOrGradient:Jt,listenArrayEvents:at,log10:z,merge:b,mergeIf:x,niceNum:B,noop:e,overrideTextDirection:Ai,readUsedSize:Pe,renderText:Ne,requestAnimFrame:ht,resolve:Pi,resolveObjectKey:M,restoreTextDirection:Ti,retinaScale:ke,setsEqual:P,sign:F,splineCurve:ai,splineCurveMonotone:ri,supportsEventListenerOptions:Se,throttled:ct,toDegrees:Y,toDimension:c,toFont:Si,toFontString:De,toLineHeight:_i,toPadding:ki,toPercentage:h,toRadians:$,toTRBL:Mi,toTRBLCorners:wi,uid:i,unclipArea:ze,unlistenArrayEvents:rt,valueOrDefault:l});function Ni(t,e,i,s){const{controller:n,data:o,_sorted:a}=t,r=n._cachedMeta.iScale;if(r&&e===r.axis&&\"r\"!==e&&a&&o.length){const t=r._reversePixels?st:it;if(!s)return t(o,e,i);if(n._sharedOptions){const s=o[0],n=\"function\"==typeof s.getRange&&s.getRange(e);if(n){const s=t(o,e,i-n),a=t(o,e,i+n);return{lo:s.lo,hi:a.hi}}}}return{lo:0,hi:o.length-1}}function Hi(t,e,i,s,n){const o=t.getSortedVisibleDatasetMetas(),a=i[e];for(let t=0,i=o.length;t<i;++t){const{index:i,data:r}=o[t],{lo:l,hi:h}=Ni(o[t],e,a,n);for(let t=l;t<=h;++t){const e=r[t];e.skip||s(e,i,t)}}}function ji(t,e,i,s,n){const o=[];if(!n&&!t.isPointInArea(e))return o;return Hi(t,i,e,(function(i,a,r){(n||Re(i,t.chartArea,0))&&i.inRange(e.x,e.y,s)&&o.push({element:i,datasetIndex:a,index:r})}),!0),o}function $i(t,e,i,s,n,o){let a=[];const r=function(t){const e=-1!==t.indexOf(\"x\"),i=-1!==t.indexOf(\"y\");return function(t,s){const n=e?Math.abs(t.x-s.x):0,o=i?Math.abs(t.y-s.y):0;return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}}(i);let l=Number.POSITIVE_INFINITY;return Hi(t,i,e,(function(i,h,c){const d=i.inRange(e.x,e.y,n);if(s&&!d)return;const u=i.getCenterPoint(n);if(!(!!o||t.isPointInArea(u))&&!d)return;const f=r(e,u);f<l?(a=[{element:i,datasetIndex:h,index:c}],l=f):f===l&&a.push({element:i,datasetIndex:h,index:c})})),a}function Yi(t,e,i,s,n,o){return o||t.isPointInArea(e)?\"r\"!==i||s?$i(t,e,i,s,n,o):function(t,e,i,s){let n=[];return Hi(t,i,e,(function(t,i,o){const{startAngle:a,endAngle:r}=t.getProps([\"startAngle\",\"endAngle\"],s),{angle:l}=X(t,{x:e.x,y:e.y});Z(l,a,r)&&n.push({element:t,datasetIndex:i,index:o})})),n}(t,e,i,n):[]}function Ui(t,e,i,s,n){const o=[],a=\"x\"===i?\"inXRange\":\"inYRange\";let r=!1;return Hi(t,i,e,((t,s,l)=>{t[a](e[i],n)&&(o.push({element:t,datasetIndex:s,index:l}),r=r||t.inRange(e.x,e.y,n))})),s&&!r?[]:o}var Xi={evaluateInteractionItems:Hi,modes:{index(t,e,i,s){const n=ve(e,t),o=i.axis||\"x\",a=i.includeInvisible||!1,r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a),l=[];return r.length?(t.getSortedVisibleDatasetMetas().forEach((t=>{const e=r[0].index,i=t.data[e];i&&!i.skip&&l.push({element:i,datasetIndex:t.index,index:e})})),l):[]},dataset(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;let r=i.intersect?ji(t,n,o,s,a):Yi(t,n,o,!1,s,a);if(r.length>0){const e=r[0].datasetIndex,i=t.getDatasetMeta(e).data;r=[];for(let t=0;t<i.length;++t)r.push({element:i[t],datasetIndex:e,index:t})}return r},point:(t,e,i,s)=>ji(t,ve(e,t),i.axis||\"xy\",s,i.includeInvisible||!1),nearest(t,e,i,s){const n=ve(e,t),o=i.axis||\"xy\",a=i.includeInvisible||!1;return Yi(t,n,o,i.intersect,s,a)},x:(t,e,i,s)=>Ui(t,ve(e,t),\"x\",i.intersect,s),y:(t,e,i,s)=>Ui(t,ve(e,t),\"y\",i.intersect,s)}};const qi=[\"left\",\"top\",\"right\",\"bottom\"];function Ki(t,e){return t.filter((t=>t.pos===e))}function Gi(t,e){return t.filter((t=>-1===qi.indexOf(t.pos)&&t.box.axis===e))}function Zi(t,e){return t.sort(((t,i)=>{const s=e?i:t,n=e?t:i;return s.weight===n.weight?s.index-n.index:s.weight-n.weight}))}function Ji(t,e){const i=function(t){const e={};for(const i of t){const{stack:t,pos:s,stackWeight:n}=i;if(!t||!qi.includes(s))continue;const o=e[t]||(e[t]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=n}return e}(t),{vBoxMaxWidth:s,hBoxMaxHeight:n}=e;let o,a,r;for(o=0,a=t.length;o<a;++o){r=t[o];const{fullSize:a}=r.box,l=i[r.stack],h=l&&r.stackWeight/l.weight;r.horizontal?(r.width=h?h*s:a&&e.availableWidth,r.height=n):(r.width=s,r.height=h?h*n:a&&e.availableHeight)}return i}function Qi(t,e,i,s){return Math.max(t[i],e[i])+Math.max(t[s],e[s])}function ts(t,e){t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}function es(t,e,i,s){const{pos:n,box:a}=i,r=t.maxPadding;if(!o(n)){i.size&&(t[n]-=i.size);const e=s[i.stack]||{size:0,count:1};e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[n]+=i.size}a.getPadding&&ts(r,a.getPadding());const l=Math.max(0,e.outerWidth-Qi(r,t,\"left\",\"right\")),h=Math.max(0,e.outerHeight-Qi(r,t,\"top\",\"bottom\")),c=l!==t.w,d=h!==t.h;return t.w=l,t.h=h,i.horizontal?{same:c,other:d}:{same:d,other:c}}function is(t,e){const i=e.maxPadding;function s(t){const s={left:0,top:0,right:0,bottom:0};return t.forEach((t=>{s[t]=Math.max(e[t],i[t])})),s}return s(t?[\"left\",\"right\"]:[\"top\",\"bottom\"])}function ss(t,e,i,s){const n=[];let o,a,r,l,h,c;for(o=0,a=t.length,h=0;o<a;++o){r=t[o],l=r.box,l.update(r.width||e.w,r.height||e.h,is(r.horizontal,e));const{same:a,other:d}=es(e,i,r,s);h|=a&&n.length,c=c||d,l.fullSize||n.push(r)}return h&&ss(n,e,i,s)||c}function ns(t,e,i,s,n){t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}function os(t,e,i,s){const n=i.padding;let{x:o,y:a}=e;for(const r of t){const t=r.box,l=s[r.stack]||{count:1,placed:0,weight:1},h=r.stackWeight/l.weight||1;if(r.horizontal){const s=e.w*h,o=l.size||t.height;k(l.start)&&(a=l.start),t.fullSize?ns(t,n.left,a,i.outerWidth-n.right-n.left,o):ns(t,e.left+l.placed,a,s,o),l.start=a,l.placed+=s,a=t.bottom}else{const s=e.h*h,a=l.size||t.width;k(l.start)&&(o=l.start),t.fullSize?ns(t,o,n.top,a,i.outerHeight-n.bottom-n.top):ns(t,o,e.top+l.placed,a,s),l.start=o,l.placed+=s,o=t.right}}e.x=o,e.y=a}var as={addBox(t,e){t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||\"top\",e.weight=e.weight||0,e._layers=e._layers||function(){return[{z:0,draw(t){e.draw(t)}}]},t.boxes.push(e)},removeBox(t,e){const i=t.boxes?t.boxes.indexOf(e):-1;-1!==i&&t.boxes.splice(i,1)},configure(t,e,i){e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight},update(t,e,i,s){if(!t)return;const n=ki(t.options.layout.padding),o=Math.max(e-n.width,0),a=Math.max(i-n.height,0),r=function(t){const e=function(t){const e=[];let i,s,n,o,a,r;for(i=0,s=(t||[]).length;i<s;++i)n=t[i],({position:o,options:{stack:a,stackWeight:r=1}}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&&o+a,stackWeight:r});return e}(t),i=Zi(e.filter((t=>t.box.fullSize)),!0),s=Zi(Ki(e,\"left\"),!0),n=Zi(Ki(e,\"right\")),o=Zi(Ki(e,\"top\"),!0),a=Zi(Ki(e,\"bottom\")),r=Gi(e,\"x\"),l=Gi(e,\"y\");return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(l).concat(a).concat(r),chartArea:Ki(e,\"chartArea\"),vertical:s.concat(n).concat(l),horizontal:o.concat(a).concat(r)}}(t.boxes),l=r.vertical,h=r.horizontal;u(t.boxes,(t=>{\"function\"==typeof t.beforeLayout&&t.beforeLayout()}));const c=l.reduce(((t,e)=>e.box.options&&!1===e.box.options.display?t:t+1),0)||1,d=Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:a,vBoxMaxWidth:o/2/c,hBoxMaxHeight:a/2}),f=Object.assign({},n);ts(f,ki(s));const g=Object.assign({maxPadding:f,w:o,h:a,x:n.left,y:n.top},n),p=Ji(l.concat(h),d);ss(r.fullSize,g,d,p),ss(l,g,d,p),ss(h,g,d,p)&&ss(l,g,d,p),function(t){const e=t.maxPadding;function i(i){const s=Math.max(e[i]-t[i],0);return t[i]+=s,s}t.y+=i(\"top\"),t.x+=i(\"left\"),i(\"right\"),i(\"bottom\")}(g),os(r.leftAndTop,g,d,p),g.x+=g.w,g.y+=g.h,os(r.rightAndBottom,g,d,p),t.chartArea={left:g.left,top:g.top,right:g.left+g.w,bottom:g.top+g.h,height:g.h,width:g.w},u(r.chartArea,(e=>{const i=e.box;Object.assign(i,t.chartArea),i.update(g.w,g.h,{left:0,top:0,right:0,bottom:0})}))}};class rs{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,i,s){return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}isAttached(t){return!0}updateConfig(t){}}class ls extends rs{acquireContext(t){return t&&t.getContext&&t.getContext(\"2d\")||null}updateConfig(t){t.options.animation=!1}}const hs=\"$chartjs\",cs={touchstart:\"mousedown\",touchmove:\"mousemove\",touchend:\"mouseup\",pointerenter:\"mouseenter\",pointerdown:\"mousedown\",pointermove:\"mousemove\",pointerup:\"mouseup\",pointerleave:\"mouseout\",pointerout:\"mouseout\"},ds=t=>null===t||\"\"===t;const us=!!Se&&{passive:!0};function fs(t,e,i){t.canvas.removeEventListener(e,i,us)}function gs(t,e){for(const i of t)if(i===e||i.contains(e))return!0}function ps(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.addedNodes,s),e=e&&!gs(i.removedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}function ms(t,e,i){const s=t.canvas,n=new MutationObserver((t=>{let e=!1;for(const i of t)e=e||gs(i.removedNodes,s),e=e&&!gs(i.addedNodes,s);e&&i()}));return n.observe(document,{childList:!0,subtree:!0}),n}const bs=new Map;let xs=0;function _s(){const t=window.devicePixelRatio;t!==xs&&(xs=t,bs.forEach(((e,i)=>{i.currentDevicePixelRatio!==t&&e()})))}function ys(t,e,i){const s=t.canvas,n=s&&ge(s);if(!n)return;const o=ct(((t,e)=>{const s=n.clientWidth;i(t,e),s<n.clientWidth&&i()}),window),a=new ResizeObserver((t=>{const e=t[0],i=e.contentRect.width,s=e.contentRect.height;0===i&&0===s||o(i,s)}));return a.observe(n),function(t,e){bs.size||window.addEventListener(\"resize\",_s),bs.set(t,e)}(t,o),a}function vs(t,e,i){i&&i.disconnect(),\"resize\"===e&&function(t){bs.delete(t),bs.size||window.removeEventListener(\"resize\",_s)}(t)}function Ms(t,e,i){const s=t.canvas,n=ct((e=>{null!==t.ctx&&i(function(t,e){const i=cs[t.type]||t.type,{x:s,y:n}=ve(t,e);return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}(e,t))}),t);return function(t,e,i){t.addEventListener(e,i,us)}(s,e,n),n}class ws extends rs{acquireContext(t,e){const i=t&&t.getContext&&t.getContext(\"2d\");return i&&i.canvas===t?(function(t,e){const i=t.style,s=t.getAttribute(\"height\"),n=t.getAttribute(\"width\");if(t[hs]={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||\"block\",i.boxSizing=i.boxSizing||\"border-box\",ds(n)){const e=Pe(t,\"width\");void 0!==e&&(t.width=e)}if(ds(s))if(\"\"===t.style.height)t.height=t.width/(e||2);else{const e=Pe(t,\"height\");void 0!==e&&(t.height=e)}}(t,e),i):null}releaseContext(t){const e=t.canvas;if(!e[hs])return!1;const i=e[hs].initial;[\"height\",\"width\"].forEach((t=>{const n=i[t];s(n)?e.removeAttribute(t):e.setAttribute(t,n)}));const n=i.style||{};return Object.keys(n).forEach((t=>{e.style[t]=n[t]})),e.width=e.width,delete e[hs],!0}addEventListener(t,e,i){this.removeEventListener(t,e);const s=t.$proxies||(t.$proxies={}),n={attach:ps,detach:ms,resize:ys}[e]||Ms;s[e]=n(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),s=i[e];if(!s)return;({attach:vs,detach:vs,resize:vs}[e]||fs)(t,e,s),i[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,i,s){return we(t,e,i,s)}isAttached(t){const e=ge(t);return!(!e||!e.isConnected)}}function ks(t){return!fe()||\"undefined\"!=typeof OffscreenCanvas&&t instanceof OffscreenCanvas?ls:ws}var Ss=Object.freeze({__proto__:null,BasePlatform:rs,BasicPlatform:ls,DomPlatform:ws,_detectPlatform:ks});const Ps=\"transparent\",Ds={boolean:(t,e,i)=>i>.5?e:t,color(t,e,i){const s=Qt(t||Ps),n=s.valid&&Qt(e||Ps);return n&&n.valid?n.mix(s,i).hexString():e},number:(t,e,i)=>t+(e-t)*i};class Cs{constructor(t,e,i,s){const n=e[i];s=Pi([t.to,s,n,t.from]);const o=Pi([t.from,n,s]);this._active=!0,this._fn=t.fn||Ds[t.type||typeof o],this._easing=fi[t.easing]||fi.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(!1);const s=this._target[this._prop],n=i-this._start,o=this._duration-n;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Pi([t.to,e,s,t.from]),this._from=Pi([t.from,s,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,s=this._prop,n=this._from,o=this._loop,a=this._to;let r;if(this._active=n!==a&&(o||e<i),!this._active)return this._target[s]=a,void this._notify(!0);e<0?this._target[s]=n:(r=e/i%2,r=o&&r>1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}wait(){const t=this._promises||(this._promises=[]);return new Promise(((e,i)=>{t.push({res:e,rej:i})}))}_notify(t){const e=t?\"res\":\"rej\",i=this._promises||[];for(let t=0;t<i.length;t++)i[t][e]()}}class Os{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!o(t))return;const e=Object.keys(ue.animation),i=this._properties;Object.getOwnPropertyNames(t).forEach((s=>{const a=t[s];if(!o(a))return;const r={};for(const t of e)r[t]=a[t];(n(a.properties)&&a.properties||[s]).forEach((t=>{t!==s&&i.has(t)||i.set(t,r)}))}))}_animateOptions(t,e){const i=e.options,s=function(t,e){if(!e)return;let i=t.options;if(!i)return void(t.options=e);i.$shared&&(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));return i}(t,i);if(!s)return[];const n=this._createAnimations(s,i);return i.$shared&&function(t,e){const i=[],s=Object.keys(e);for(let e=0;e<s.length;e++){const n=t[s[e]];n&&n.active()&&i.push(n.wait())}return Promise.all(i)}(t.options.$animations,i).then((()=>{t.options=i}),(()=>{})),n}_createAnimations(t,e){const i=this._properties,s=[],n=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let r;for(r=o.length-1;r>=0;--r){const l=o[r];if(\"$\"===l.charAt(0))continue;if(\"options\"===l){s.push(...this._animateOptions(t,e));continue}const h=e[l];let c=n[l];const d=i.get(l);if(c){if(d&&c.active()){c.update(d,h,a);continue}c.cancel()}d&&d.duration?(n[l]=c=new Cs(d,t,l,h),s.push(c)):t[l]=h}return s}update(t,e){if(0===this._properties.size)return void Object.assign(t,e);const i=this._createAnimations(t,e);return i.length?(xt.add(this._chart,i),!0):void 0}}function As(t,e){const i=t&&t.options||{},s=i.reverse,n=void 0===i.min?e:0,o=void 0===i.max?e:0;return{start:s?o:n,end:s?n:o}}function Ts(t,e){const i=[],s=t._getSortedDatasetMetas(e);let n,o;for(n=0,o=s.length;n<o;++n)i.push(s[n].index);return i}function Ls(t,e,i,s={}){const n=t.keys,o=\"single\"===s.mode;let r,l,h,c;if(null!==e){for(r=0,l=n.length;r<l;++r){if(h=+n[r],h===i){if(s.all)continue;break}c=t.values[h],a(c)&&(o||0===e||F(e)===F(c))&&(e+=c)}return e}}function Es(t,e){const i=t&&t.options.stacked;return i||void 0===i&&void 0!==e.stack}function Rs(t,e,i){const s=t[e]||(t[e]={});return s[i]||(s[i]={})}function Is(t,e,i,s){for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=t[n.index];if(i&&e>0||!i&&e<0)return n.index}return null}function zs(t,e){const{chart:i,_cachedMeta:s}=t,n=i._stacks||(i._stacks={}),{iScale:o,vScale:a,index:r}=s,l=o.axis,h=a.axis,c=function(t,e,i){return`${t.id}.${e.id}.${i.stack||i.type}`}(o,a,s),d=e.length;let u;for(let t=0;t<d;++t){const i=e[t],{[l]:o,[h]:d}=i;u=(i._stacks||(i._stacks={}))[h]=Rs(n,c,o),u[r]=d,u._top=Is(u,a,!0,s.type),u._bottom=Is(u,a,!1,s.type);(u._visualValues||(u._visualValues={}))[r]=d}}function Fs(t,e){const i=t.scales;return Object.keys(i).filter((t=>i[t].axis===e)).shift()}function Vs(t,e){const i=t.controller.index,s=t.vScale&&t.vScale.axis;if(s){e=e||t._parsed;for(const t of e){const e=t._stacks;if(!e||void 0===e[s]||void 0===e[s][i])return;delete e[s][i],void 0!==e[s]._visualValues&&void 0!==e[s]._visualValues[i]&&delete e[s]._visualValues[i]}}}const Bs=t=>\"reset\"===t||\"none\"===t,Ws=(t,e)=>e?t:Object.assign({},t);class Ns{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=Es(t.vScale,t),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled(\"filler\")&&console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\")}updateIndex(t){this.index!==t&&Vs(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,i=this.getDataset(),s=(t,e,i,s)=>\"x\"===t?e:\"r\"===t?s:i,n=e.xAxisID=l(i.xAxisID,Fs(t,\"x\")),o=e.yAxisID=l(i.yAxisID,Fs(t,\"y\")),a=e.rAxisID=l(i.rAxisID,Fs(t,\"r\")),r=e.indexAxis,h=e.iAxisID=s(r,n,o,a),c=e.vAxisID=s(r,o,n,a);e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(c)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update(\"reset\")}_destroy(){const t=this._cachedMeta;this._data&&rt(this._data,this),t._stacked&&Vs(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),i=this._data;if(o(e))this._data=function(t){const e=Object.keys(t),i=new Array(e.length);let s,n,o;for(s=0,n=e.length;s<n;++s)o=e[s],i[s]={x:o,y:t[o]};return i}(e);else if(i!==e){if(i){rt(i,this);const t=this._cachedMeta;Vs(t),t._parsed=[]}e&&Object.isExtensible(e)&&at(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,i=this.getDataset();let s=!1;this._dataCheck();const n=e._stacked;e._stacked=Es(e.vScale,e),e.stack!==i.stack&&(s=!0,Vs(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&&zs(this,e._parsed)}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),i=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:i,_data:s}=this,{iScale:a,_stacked:r}=i,l=a.axis;let h,c,d,u=0===t&&e===s.length||i._sorted,f=t>0&&i._parsed[t-1];if(!1===this._parsing)i._parsed=s,i._sorted=!0,d=s;else{d=n(s[t])?this.parseArrayData(i,s,t,e):o(s[t])?this.parseObjectData(i,s,t,e):this.parsePrimitiveData(i,s,t,e);const a=()=>null===c[l]||f&&c[l]<f[l];for(h=0;h<e;++h)i._parsed[h+t]=c=d[h],u&&(a()&&(u=!1),f=c);i._sorted=u}r&&zs(this,d)}parsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=t,a=n.axis,r=o.axis,l=n.getLabels(),h=n===o,c=new Array(s);let d,u,f;for(d=0,u=s;d<u;++d)f=d+i,c[d]={[a]:h||n.parse(l[f],f),[r]:o.parse(e[f],f)};return c}parseArrayData(t,e,i,s){const{xScale:n,yScale:o}=t,a=new Array(s);let r,l,h,c;for(r=0,l=s;r<l;++r)h=r+i,c=e[h],a[r]={x:n.parse(c[0],h),y:o.parse(c[1],h)};return a}parseObjectData(t,e,i,s){const{xScale:n,yScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=new Array(s);let h,c,d,u;for(h=0,c=s;h<c;++h)d=h+i,u=e[d],l[h]={x:n.parse(M(u,a),d),y:o.parse(M(u,r),d)};return l}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,i){const s=this.chart,n=this._cachedMeta,o=e[t.axis];return Ls({keys:Ts(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}updateRangeFromParsed(t,e,i,s){const n=i[e.axis];let o=null===n?NaN:n;const a=s&&i._stacks[e.axis];s&&a&&(s.values=a,o=Ls(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const i=this._cachedMeta,s=i._parsed,n=i._sorted&&t===i.iScale,o=s.length,r=this._getOtherScale(t),l=((t,e,i)=>t&&!e.hidden&&e._stacked&&{keys:Ts(i,!0),values:null})(e,i,this.chart),h={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:c,max:d}=function(t){const{min:e,max:i,minDefined:s,maxDefined:n}=t.getUserBounds();return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}(r);let u,f;function g(){f=s[u];const e=f[r.axis];return!a(f[t.axis])||c>e||d<e}for(u=0;u<o&&(g()||(this.updateRangeFromParsed(h,t,f,l),!n));++u);if(n)for(u=o-1;u>=0;--u)if(!g()){this.updateRangeFromParsed(h,t,f,l);break}return h}getAllParsedValues(t){const e=this._cachedMeta._parsed,i=[];let s,n,o;for(s=0,n=e.length;s<n;++s)o=e[s][t.axis],a(o)&&i.push(o);return i}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,i=e.iScale,s=e.vScale,n=this.getParsed(t);return{label:i?\"\"+i.getLabelForValue(n[i.axis]):\"\",value:s?\"\"+s.getLabelForValue(n[s.axis]):\"\"}}_update(t){const e=this._cachedMeta;this.update(t||\"default\"),e._clip=function(t){let e,i,s,n;return o(t)?(e=t.top,i=t.right,s=t.bottom,n=t.left):e=i=s=n=t,{top:e,right:i,bottom:s,left:n,disabled:!1===t}}(l(this.options.clip,function(t,e,i){if(!1===i)return!1;const s=As(t,i),n=As(e,i);return{top:n.end,right:s.end,bottom:n.start,left:s.start}}(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,i=this._cachedMeta,s=i.data||[],n=e.chartArea,o=[],a=this._drawStart||0,r=this._drawCount||s.length-a,l=this.options.drawActiveElementsOnTop;let h;for(i.dataset&&i.dataset.draw(t,n,a,r),h=a;h<a+r;++h){const e=s[h];e.hidden||(e.active&&l?o.push(e):e.draw(t,n))}for(h=0;h<o.length;++h)o[h].draw(t,n)}getStyle(t,e){const i=e?\"active\":\"default\";return void 0===t&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}getContext(t,e,i){const s=this.getDataset();let n;if(t>=0&&t<this._cachedMeta.data.length){const e=this._cachedMeta.data[t];n=e.$context||(e.$context=function(t,e,i){return Ci(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:\"default\",type:\"data\"})}(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}else n=this.$context||(this.$context=function(t,e){return Ci(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:\"default\",type:\"dataset\"})}(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;return n.active=!!e,n.mode=i,n}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e=\"default\",i){const s=\"active\"===e,n=this._cachedDataOpts,o=t+\"-\"+e,a=n[o],r=this.enableOptionSharing&&k(i);if(a)return Ws(a,r);const l=this.chart.config,h=l.datasetElementScopeKeys(this._type,t),c=s?[`${t}Hover`,\"hover\",t,\"\"]:[t,\"\"],d=l.getOptionScopes(this.getDataset(),h),u=Object.keys(ue.elements[t]),f=l.resolveNamedOptions(d,u,(()=>this.getContext(i,s,e)),c);return f.$shared&&(f.$shared=r,n[o]=Object.freeze(Ws(f,r))),f}_resolveAnimations(t,e,i){const s=this.chart,n=this._cachedDataOpts,o=`animation-${e}`,a=n[o];if(a)return a;let r;if(!1!==s.options.animation){const s=this.chart.config,n=s.datasetAnimationScopeKeys(this._type,e),o=s.getOptionScopes(this.getDataset(),n);r=s.createResolver(o,this.getContext(t,i,e))}const l=new Os(s,r&&r.animations);return r&&r._cacheable&&(n[o]=Object.freeze(l)),l}getSharedOptions(t){if(t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||Bs(t)||this.chart._animationsDisabled}_getSharedOptions(t,e){const i=this.resolveDataElementOptions(t,e),s=this._sharedOptions,n=this.getSharedOptions(i),o=this.includeOptions(e,n)||n!==s;return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}updateElement(t,e,i,s){Bs(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}updateSharedOptions(t,e,i){t&&!Bs(e)&&this._resolveAnimations(void 0,e).update(t,i)}_setStyle(t,e,i,s){t.active=s;const n=this.getStyle(e,s);this._resolveAnimations(e,i,s).update(t,{options:!s&&this.getSharedOptions(n)||n})}removeHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!1)}setHoverStyle(t,e,i){this._setStyle(t,i,\"active\",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,\"active\",!0)}_resyncElements(t){const e=this._data,i=this._cachedMeta.data;for(const[t,e,i]of this._syncList)this[t](e,i);this._syncList=[];const s=i.length,n=e.length,o=Math.min(n,s);o&&this.parse(0,o),n>s?this._insertElements(s,n-s,t):n<s&&this._removeElements(n,s-n)}_insertElements(t,e,i=!0){const s=this._cachedMeta,n=s.data,o=t+e;let a;const r=t=>{for(t.length+=e,a=t.length-1;a>=o;a--)t[a]=t[a-e]};for(r(n),a=t;a<o;++a)n[a]=new this.dataElementType;this._parsing&&r(s._parsed),this.parse(t,e),i&&this.updateElements(n,t,e,\"reset\")}updateElements(t,e,i,s){}_removeElements(t,e){const i=this._cachedMeta;if(this._parsing){const s=i._parsed.splice(t,e);i._stacked&&Vs(i,s)}i.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,i,s]=t;this[e](i,s)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync([\"_insertElements\",this.getDataset().data.length-t,t])}_onDataPop(){this._sync([\"_removeElements\",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync([\"_removeElements\",0,1])}_onDataSplice(t,e){e&&this._sync([\"_removeElements\",t,e]);const i=arguments.length-2;i&&this._sync([\"_insertElements\",t,i])}_onDataUnshift(){this._sync([\"_insertElements\",0,arguments.length])}}class Hs{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}hasValue(){return N(this.x)&&N(this.y)}getProps(t,e){const i=this.$animations;if(!e||!i)return this;const s={};return t.forEach((t=>{s[t]=i[t]&&i[t].active()?i[t]._to:this[t]})),s}}function js(t,e){const i=t.options.ticks,n=function(t){const e=t.options.offset,i=t._tickSize(),s=t._length/i+(e?0:1),n=t._maxLength/i;return Math.floor(Math.min(s,n))}(t),o=Math.min(i.maxTicksLimit||n,n),a=i.major.enabled?function(t){const e=[];let i,s;for(i=0,s=t.length;i<s;i++)t[i].major&&e.push(i);return e}(e):[],r=a.length,l=a[0],h=a[r-1],c=[];if(r>o)return function(t,e,i,s){let n,o=0,a=i[0];for(s=Math.ceil(s),n=0;n<t.length;n++)n===a&&(e.push(t[n]),o++,a=i[o*s])}(e,c,a,r/o),c;const d=function(t,e,i){const s=function(t){const e=t.length;let i,s;if(e<2)return!1;for(s=t[0],i=1;i<e;++i)if(t[i]-t[i-1]!==s)return!1;return s}(t),n=e.length/i;if(!s)return Math.max(n,1);const o=W(s);for(let t=0,e=o.length-1;t<e;t++){const e=o[t];if(e>n)return e}return Math.max(n,1)}(a,e,o);if(r>0){let t,i;const n=r>1?Math.round((h-l)/(r-1)):null;for($s(e,c,d,s(n)?0:l-n,l),t=0,i=r-1;t<i;t++)$s(e,c,d,a[t],a[t+1]);return $s(e,c,d,h,s(n)?e.length:h+n),c}return $s(e,c,d),c}function $s(t,e,i,s,n){const o=l(s,0),a=Math.min(l(n,t.length),t.length);let r,h,c,d=0;for(i=Math.ceil(i),n&&(r=n-s,i=r/Math.floor(r/i)),c=o;c<0;)d++,c=Math.round(o+d*i);for(h=Math.max(o,0);h<a;h++)h===c&&(e.push(t[h]),d++,c=Math.round(o+d*i))}const Ys=(t,e,i)=>\"top\"===e||\"left\"===e?t[e]+i:t[e]-i,Us=(t,e)=>Math.min(e||t,t);function Xs(t,e){const i=[],s=t.length/e,n=t.length;let o=0;for(;o<n;o+=s)i.push(t[Math.floor(o)]);return i}function qs(t,e,i){const s=t.ticks.length,n=Math.min(e,s-1),o=t._startPixel,a=t._endPixel,r=1e-6;let l,h=t.getPixelForTick(n);if(!(i&&(l=1===s?Math.max(h-o,a-h):0===e?(t.getPixelForTick(1)-h)/2:(h-t.getPixelForTick(n-1))/2,h+=n<e?l:-l,h<o-r||h>a+r)))return h}function Ks(t){return t.drawTicks?t.tickLength:0}function Gs(t,e){if(!t.display)return 0;const i=Si(t.font,e),s=ki(t.padding);return(n(t.text)?t.text.length:1)*i.lineHeight+s.height}function Zs(t,e,i){let s=ut(t);return(i&&\"right\"!==e||!i&&\"right\"===e)&&(s=(t=>\"left\"===t?\"right\":\"right\"===t?\"left\":t)(s)),s}class Js extends Hs{constructor(t){super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=this;return t=r(t,Number.POSITIVE_INFINITY),e=r(e,Number.NEGATIVE_INFINITY),i=r(i,Number.POSITIVE_INFINITY),s=r(s,Number.NEGATIVE_INFINITY),{min:r(t,i),max:r(e,s),minDefined:a(t),maxDefined:a(e)}}getMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=this.getUserBounds();if(n&&o)return{min:i,max:s};const a=this.getMatchingVisibleMetas();for(let r=0,l=a.length;r<l;++r)e=a[r].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));return i=o&&i>s?s:i,s=n&&i>s?i:s,{min:r(i,r(s,i)),max:r(s,r(i,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}getLabelItems(t=this.chart.chartArea){return this._labelItems||(this._labelItems=this._computeLabelItems(t))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){d(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=Di(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const r=a<this.ticks.length;this._convertTicksToLabels(r?Xs(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||\"auto\"===o.source)&&(this.ticks=js(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),r&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t,e,i=this.options.reverse;this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}afterUpdate(){d(this.options.afterUpdate,[this])}beforeSetDimensions(){d(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){d(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),d(this.options[t],[this])}beforeDataLimits(){this._callHooks(\"beforeDataLimits\")}determineDataLimits(){}afterDataLimits(){this._callHooks(\"afterDataLimits\")}beforeBuildTicks(){this._callHooks(\"beforeBuildTicks\")}buildTicks(){return[]}afterBuildTicks(){this._callHooks(\"afterBuildTicks\")}beforeTickToLabelConversion(){d(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let i,s,n;for(i=0,s=t.length;i<s;i++)n=t[i],n.label=d(e.callback,[n.value,i,t],this)}afterTickToLabelConversion(){d(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){d(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=Us(this.ticks.length,t.ticks.maxTicksLimit),s=e.minRotation||0,n=e.maxRotation;let o,a,r,l=s;if(!this._isVisible()||!e.display||s>=n||i<=1||!this.isHorizontal())return void(this.labelRotation=s);const h=this._getLabelSizes(),c=h.widest.width,d=h.highest.height,u=J(this.chart.width-c,0,this.maxWidth);o=t.offset?this.maxWidth/i:u/(i-1),c+6>o&&(o=u/(i-(t.offset?.5:1)),a=this.maxHeight-Ks(t.grid)-e.padding-Gs(t.title,this.chart.options.font),r=Math.sqrt(c*c+d*d),l=Y(Math.min(Math.asin(J((h.highest.height+6)/o,-1,1)),Math.asin(J(a/r,-1,1))-Math.asin(J(d/r,-1,1)))),l=Math.max(s,Math.min(n,l))),this.labelRotation=l}afterCalculateLabelRotation(){d(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){d(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:s,grid:n}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const o=Gs(s,e.options.font);if(a?(t.width=this.maxWidth,t.height=Ks(n)+o):(t.height=this.maxHeight,t.width=Ks(n)+o),i.display&&this.ticks.length){const{first:e,last:s,widest:n,highest:o}=this._getLabelSizes(),r=2*i.padding,l=$(this.labelRotation),h=Math.cos(l),c=Math.sin(l);if(a){const e=i.mirror?0:c*n.width+h*o.height;t.height=Math.min(this.maxHeight,t.height+e+r)}else{const e=i.mirror?0:h*n.width+c*o.height;t.width=Math.min(this.maxWidth,t.width+e+r)}this._calculatePadding(e,s,c,h)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=this.options,r=0!==this.labelRotation,l=\"top\"!==a&&\"x\"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left,h=this.right-this.getPixelForTick(this.ticks.length-1);let c=0,d=0;r?l?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):\"start\"===n?d=e.width:\"end\"===n?c=t.width:\"inner\"!==n&&(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-h+o)*this.width/(this.width-h),0)}else{let i=e.height/2,s=t.height/2;\"start\"===n?(i=0,s=t.height):\"end\"===n&&(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){d(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return\"top\"===e||\"bottom\"===e||\"x\"===t}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){let e,i;for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e<i;e++)s(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=Xs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}return t}_computeLabelSizes(t,e,i){const{ctx:o,_longestTextCache:a}=this,r=[],l=[],h=Math.floor(e/Us(e,i));let c,d,f,g,p,m,b,x,_,y,v,M=0,w=0;for(c=0;c<e;c+=h){if(g=t[c].label,p=this._resolveTickFontOptions(c),o.font=m=p.string,b=a[m]=a[m]||{data:{},gc:[]},x=p.lineHeight,_=y=0,s(g)||n(g)){if(n(g))for(d=0,f=g.length;d<f;++d)v=g[d],s(v)||n(v)||(_=Ce(o,b.data,b.gc,_,v),y+=x)}else _=Ce(o,b.data,b.gc,_,g),y=x;r.push(_),l.push(y),M=Math.max(_,M),w=Math.max(y,w)}!function(t,e){u(t,(t=>{const i=t.gc,s=i.length/2;let n;if(s>e){for(n=0;n<s;++n)delete t.data[i[n]];i.splice(0,s)}}))}(a,e);const k=r.indexOf(M),S=l.indexOf(w),P=t=>({width:r[t]||0,height:l[t]||0});return{first:P(0),last:P(e-1),widest:P(k),highest:P(S),widths:r,heights:l}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return Q(this._alignToPixels?Ae(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const i=e[t];return i.$context||(i.$context=function(t,e,i){return Ci(t,{tick:i,index:e,type:\"tick\"})}(this.getContext(),t,i))}return this.$context||(this.$context=Ci(this.chart.getContext(),{scale:this,type:\"scale\"}))}_tickSize(){const t=this.options.ticks,e=$(this.labelRotation),i=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),n=this._getLabelSizes(),o=t.autoSkipPadding||0,a=n?n.widest.width+o:0,r=n?n.highest.height+o:0;return this.isHorizontal()?r*i>a*s?a/i:r/s:r*s<a*i?r/i:a/s}_isVisible(){const t=this.options.display;return\"auto\"!==t?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,s=this.options,{grid:n,position:a,border:r}=s,h=n.offset,c=this.isHorizontal(),d=this.ticks.length+(h?1:0),u=Ks(n),f=[],g=r.setContext(this.getContext()),p=g.display?g.width:0,m=p/2,b=function(t){return Ae(i,t,p)};let x,_,y,v,M,w,k,S,P,D,C,O;if(\"top\"===a)x=b(this.bottom),w=this.bottom-u,S=x-m,D=b(t.top)+m,O=t.bottom;else if(\"bottom\"===a)x=b(this.top),D=t.top,O=b(t.bottom)-m,w=x+m,S=this.top+u;else if(\"left\"===a)x=b(this.right),M=this.right-u,k=x-m,P=b(t.left)+m,C=t.right;else if(\"right\"===a)x=b(this.left),P=t.left,C=b(t.right)-m,M=x+m,k=this.left+u;else if(\"x\"===e){if(\"center\"===a)x=b((t.top+t.bottom)/2+.5);else if(o(a)){const t=Object.keys(a)[0],e=a[t];x=b(this.chart.scales[t].getPixelForValue(e))}D=t.top,O=t.bottom,w=x+m,S=w+u}else if(\"y\"===e){if(\"center\"===a)x=b((t.left+t.right)/2);else if(o(a)){const t=Object.keys(a)[0],e=a[t];x=b(this.chart.scales[t].getPixelForValue(e))}M=x-m,k=M-u,P=t.left,C=t.right}const A=l(s.ticks.maxTicksLimit,d),T=Math.max(1,Math.ceil(d/A));for(_=0;_<d;_+=T){const t=this.getContext(_),e=n.setContext(t),s=r.setContext(t),o=e.lineWidth,a=e.color,l=s.dash||[],d=s.dashOffset,u=e.tickWidth,g=e.tickColor,p=e.tickBorderDash||[],m=e.tickBorderDashOffset;y=qs(this,_,h),void 0!==y&&(v=Ae(i,y,o),c?M=k=P=C=v:w=S=D=O=v,f.push({tx1:M,ty1:w,tx2:k,ty2:S,x1:P,y1:D,x2:C,y2:O,width:o,color:a,borderDash:l,borderDashOffset:d,tickWidth:u,tickColor:g,tickBorderDash:p,tickBorderDashOffset:m}))}return this._ticksLength=d,this._borderValue=x,f}_computeLabelItems(t){const e=this.axis,i=this.options,{position:s,ticks:a}=i,r=this.isHorizontal(),l=this.ticks,{align:h,crossAlign:c,padding:d,mirror:u}=a,f=Ks(i.grid),g=f+d,p=u?-d:g,m=-$(this.labelRotation),b=[];let x,_,y,v,M,w,k,S,P,D,C,O,A=\"middle\";if(\"top\"===s)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if(\"bottom\"===s)w=this.top+p,k=this._getXAxisLabelAlignment();else if(\"left\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"right\"===s){const t=this._getYAxisLabelAlignment(f);k=t.textAlign,M=t.x}else if(\"x\"===e){if(\"center\"===s)w=(t.top+t.bottom)/2+g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];w=this.chart.scales[t].getPixelForValue(e)+g}k=this._getXAxisLabelAlignment()}else if(\"y\"===e){if(\"center\"===s)M=(t.left+t.right)/2-g;else if(o(s)){const t=Object.keys(s)[0],e=s[t];M=this.chart.scales[t].getPixelForValue(e)}k=this._getYAxisLabelAlignment(f).textAlign}\"y\"===e&&(\"start\"===h?A=\"top\":\"end\"===h&&(A=\"bottom\"));const T=this._getLabelSizes();for(x=0,_=l.length;x<_;++x){y=l[x],v=y.label;const t=a.setContext(this.getContext(x));S=this.getPixelForTick(x)+a.labelOffset,P=this._resolveTickFontOptions(x),D=P.lineHeight,C=n(v)?v.length:1;const e=C/2,i=t.color,o=t.textStrokeColor,h=t.textStrokeWidth;let d,f=k;if(r?(M=S,\"inner\"===k&&(f=x===_-1?this.options.reverse?\"left\":\"right\":0===x?this.options.reverse?\"right\":\"left\":\"center\"),O=\"top\"===s?\"near\"===c||0!==m?-C*D+D/2:\"center\"===c?-T.highest.height/2-e*D+D:-T.highest.height+D/2:\"near\"===c||0!==m?D/2:\"center\"===c?T.highest.height/2-e*D:T.highest.height-C*D,u&&(O*=-1),0===m||t.showLabelBackdrop||(M+=D/2*Math.sin(m))):(w=S,O=(1-C)*D/2),t.showLabelBackdrop){const e=ki(t.backdropPadding),i=T.heights[x],s=T.widths[x];let n=O-e.top,o=0-e.left;switch(A){case\"middle\":n-=i/2;break;case\"bottom\":n-=i}switch(k){case\"center\":o-=s/2;break;case\"right\":o-=s;break;case\"inner\":x===_-1?o-=s:x>0&&(o-=s/2)}d={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}b.push({label:v,font:P,textOffset:O,options:{rotation:m,color:i,strokeColor:o,strokeWidth:h,textAlign:f,textBaseline:A,translation:[M,w],backdrop:d}})}return b}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-$(this.labelRotation))return\"top\"===t?\"left\":\"right\";let i=\"center\";return\"start\"===e.align?i=\"left\":\"end\"===e.align?i=\"right\":\"inner\"===e.align&&(i=\"inner\"),i}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=this.options,o=t+n,a=this._getLabelSizes().widest.width;let r,l;return\"left\"===e?s?(l=this.right+n,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l+=a)):(l=this.right-o,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l=this.left)):\"right\"===e?s?(l=this.left+n,\"near\"===i?r=\"right\":\"center\"===i?(r=\"center\",l-=a/2):(r=\"left\",l-=a)):(l=this.left+o,\"near\"===i?r=\"left\":\"center\"===i?(r=\"center\",l+=a/2):(r=\"right\",l=this.right)):r=\"right\",{textAlign:r,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;return\"left\"===e||\"right\"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:\"top\"===e||\"bottom\"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const i=this.ticks.findIndex((e=>e.value===t));if(i>=0){return e.setContext(this.getContext(i)).lineWidth}return 0}drawGrid(t){const e=this.options.grid,i=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let n,o;const a=(t,e,s)=>{s.width&&s.color&&(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())};if(e.display)for(n=0,o=s.length;n<o;++n){const t=s[n];e.drawOnChartArea&&a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&&a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=this,n=i.setContext(this.getContext()),o=i.display?n.width:0;if(!o)return;const a=s.setContext(this.getContext(0)).lineWidth,r=this._borderValue;let l,h,c,d;this.isHorizontal()?(l=Ae(t,this.left,o)-o/2,h=Ae(t,this.right,a)+a/2,c=d=r):(c=Ae(t,this.top,o)-o/2,d=Ae(t,this.bottom,a)+a/2,l=h=r),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(l,c),e.lineTo(h,d),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const e=this.ctx,i=this._computeLabelArea();i&&Ie(e,i);const s=this.getLabelItems(t);for(const t of s){const i=t.options,s=t.font;Ne(e,t.label,0,t.textOffset,s,i)}i&&ze(e)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=this;if(!i.display)return;const a=Si(i.font),r=ki(i.padding),l=i.align;let h=a.lineHeight/2;\"bottom\"===e||\"center\"===e||o(e)?(h+=r.bottom,n(i.text)&&(h+=a.lineHeight*(i.text.length-1))):h+=r.top;const{titleX:c,titleY:d,maxWidth:u,rotation:f}=function(t,e,i,s){const{top:n,left:a,bottom:r,right:l,chart:h}=t,{chartArea:c,scales:d}=h;let u,f,g,p=0;const m=r-n,b=l-a;if(t.isHorizontal()){if(f=ft(s,a,l),o(i)){const t=Object.keys(i)[0],s=i[t];g=d[t].getPixelForValue(s)+m-e}else g=\"center\"===i?(c.bottom+c.top)/2+m-e:Ys(t,i,e);u=l-a}else{if(o(i)){const t=Object.keys(i)[0],s=i[t];f=d[t].getPixelForValue(s)-b+e}else f=\"center\"===i?(c.left+c.right)/2-b+e:Ys(t,i,e);g=ft(s,r,n),p=\"left\"===i?-E:E}return{titleX:f,titleY:g,maxWidth:u,rotation:p}}(this,h,e,l);Ne(t,i.text,0,0,a,{color:i.color,maxWidth:u,rotation:f,textAlign:Zs(l,e,s),textBaseline:\"middle\",translation:[c,d]})}draw(t){this._isVisible()&&(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,i=l(t.grid&&t.grid.z,-1),s=l(t.border&&t.border.z,0);return this._isVisible()&&this.draw===Js.prototype.draw?[{z:i,draw:t=>{this.drawBackground(),this.drawGrid(t),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:e,draw:t=>{this.drawLabels(t)}}]:[{z:e,draw:t=>{this.draw(t)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),i=this.axis+\"AxisID\",s=[];let n,o;for(n=0,o=e.length;n<o;++n){const o=e[n];o[i]!==this.id||t&&o.type!==t||s.push(o)}return s}_resolveTickFontOptions(t){return Si(this.options.ticks.setContext(this.getContext(t)).font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class Qs{constructor(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;(function(t){return\"id\"in t&&\"defaults\"in t})(e)&&(i=this.register(e));const s=this.items,n=t.id,o=this.scope+\".\"+n;if(!n)throw new Error(\"class does not have id: \"+t);return n in s||(s[n]=t,function(t,e,i){const s=b(Object.create(null),[i?ue.get(i):{},ue.get(e),t.defaults]);ue.set(e,s),t.defaultRoutes&&function(t,e){Object.keys(e).forEach((i=>{const s=i.split(\".\"),n=s.pop(),o=[t].concat(s).join(\".\"),a=e[i].split(\".\"),r=a.pop(),l=a.join(\".\");ue.route(o,n,l,r)}))}(e,t.defaultRoutes);t.descriptors&&ue.describe(e,t.descriptors)}(t,o,i),this.override&&ue.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,i=t.id,s=this.scope;i in e&&delete e[i],s&&i in ue[s]&&(delete ue[s][i],this.override&&delete re[i])}}class tn{constructor(){this.controllers=new Qs(Ns,\"datasets\",!0),this.elements=new Qs(Hs,\"elements\"),this.plugins=new Qs(Object,\"plugins\"),this.scales=new Qs(Js,\"scales\"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each(\"register\",t)}remove(...t){this._each(\"unregister\",t)}addControllers(...t){this._each(\"register\",t,this.controllers)}addElements(...t){this._each(\"register\",t,this.elements)}addPlugins(...t){this._each(\"register\",t,this.plugins)}addScales(...t){this._each(\"register\",t,this.scales)}getController(t){return this._get(t,this.controllers,\"controller\")}getElement(t){return this._get(t,this.elements,\"element\")}getPlugin(t){return this._get(t,this.plugins,\"plugin\")}getScale(t){return this._get(t,this.scales,\"scale\")}removeControllers(...t){this._each(\"unregister\",t,this.controllers)}removeElements(...t){this._each(\"unregister\",t,this.elements)}removePlugins(...t){this._each(\"unregister\",t,this.plugins)}removeScales(...t){this._each(\"unregister\",t,this.scales)}_each(t,e,i){[...e].forEach((e=>{const s=i||this._getRegistryForType(e);i||s.isForType(e)||s===this.plugins&&e.id?this._exec(t,s,e):u(e,(e=>{const s=i||this._getRegistryForType(e);this._exec(t,s,e)}))}))}_exec(t,e,i){const s=w(t);d(i[\"before\"+s],[],i),e[t](i),d(i[\"after\"+s],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const s=e.get(t);if(void 0===s)throw new Error('\"'+t+'\" is not a registered '+i+\".\");return s}}var en=new tn;class sn{constructor(){this._init=[]}notify(t,e,i,s){\"beforeInit\"===e&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,\"install\"));const n=s?this._descriptors(t).filter(s):this._descriptors(t),o=this._notify(n,t,e,i);return\"afterDestroy\"===e&&(this._notify(n,t,\"stop\"),this._notify(this._init,t,\"uninstall\")),o}_notify(t,e,i,s){s=s||{};for(const n of t){const t=n.plugin;if(!1===d(t[i],[e,s,n.options],t)&&s.cancelable)return!1}return!0}invalidate(){s(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const i=t&&t.config,s=l(i.options&&i.options.plugins,{}),n=function(t){const e={},i=[],s=Object.keys(en.plugins.items);for(let t=0;t<s.length;t++)i.push(en.getPlugin(s[t]));const n=t.plugins||[];for(let t=0;t<n.length;t++){const s=n[t];-1===i.indexOf(s)&&(i.push(s),e[s.id]=!0)}return{plugins:i,localIds:e}}(i);return!1!==s||e?function(t,{plugins:e,localIds:i},s,n){const o=[],a=t.getContext();for(const r of e){const e=r.id,l=nn(s[e],n);null!==l&&o.push({plugin:r,options:on(t.config,{plugin:r,local:i[e]},l,a)})}return o}(t,n,s,e):[]}_notifyStateChanges(t){const e=this._oldCache||[],i=this._cache,s=(t,e)=>t.filter((t=>!e.some((e=>t.plugin.id===e.plugin.id))));this._notify(s(e,i),t,\"stop\"),this._notify(s(i,e),t,\"start\")}}function nn(t,e){return e||!1!==t?!0===t?{}:t:null}function on(t,{plugin:e,local:i},s,n){const o=t.pluginScopeKeys(e),a=t.getOptionScopes(s,o);return i&&e.defaults&&a.push(e.defaults),t.createResolver(a,n,[\"\"],{scriptable:!1,indexable:!1,allKeys:!0})}function an(t,e){const i=ue.datasets[t]||{};return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||\"x\"}function rn(t){if(\"x\"===t||\"y\"===t||\"r\"===t)return t}function ln(t,...e){if(rn(t))return t;for(const s of e){const e=s.axis||(\"top\"===(i=s.position)||\"bottom\"===i?\"x\":\"left\"===i||\"right\"===i?\"y\":void 0)||t.length>1&&rn(t[0].toLowerCase());if(e)return e}var i;throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}function hn(t,e,i){if(i[e+\"AxisID\"]===t)return{axis:e}}function cn(t,e){const i=re[t.type]||{scales:{}},s=e.scales||{},n=an(t.type,e),a=Object.create(null);return Object.keys(s).forEach((e=>{const r=s[e];if(!o(r))return console.error(`Invalid scale configuration for scale: ${e}`);if(r._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${e}`);const l=ln(e,r,function(t,e){if(e.data&&e.data.datasets){const i=e.data.datasets.filter((e=>e.xAxisID===t||e.yAxisID===t));if(i.length)return hn(t,\"x\",i[0])||hn(t,\"y\",i[0])}return{}}(e,t),ue.scales[r.type]),h=function(t,e){return t===e?\"_index_\":\"_value_\"}(l,n),c=i.scales||{};a[e]=x(Object.create(null),[{axis:l},r,c[l],c[h]])})),t.data.datasets.forEach((i=>{const n=i.type||t.type,o=i.indexAxis||an(n,e),r=(re[n]||{}).scales||{};Object.keys(r).forEach((t=>{const e=function(t,e){let i=t;return\"_index_\"===t?i=e:\"_value_\"===t&&(i=\"x\"===e?\"y\":\"x\"),i}(t,o),n=i[e+\"AxisID\"]||e;a[n]=a[n]||Object.create(null),x(a[n],[{axis:e},s[n],r[t]])}))})),Object.keys(a).forEach((t=>{const e=a[t];x(e,[ue.scales[e.type],ue.scale])})),a}function dn(t){const e=t.options||(t.options={});e.plugins=l(e.plugins,{}),e.scales=cn(t,e)}function un(t){return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}const fn=new Map,gn=new Set;function pn(t,e){let i=fn.get(t);return i||(i=e(),fn.set(t,i),gn.add(i)),i}const mn=(t,e,i)=>{const s=M(e,i);void 0!==s&&t.add(s)};class bn{constructor(t){this._config=function(t){return(t=t||{}).data=un(t.data),dn(t),t}(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=un(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),dn(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return pn(t,(()=>[[`datasets.${t}`,\"\"]]))}datasetAnimationScopeKeys(t,e){return pn(`${t}.transition.${e}`,(()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,\"\"]]))}datasetElementScopeKeys(t,e){return pn(`${t}-${e}`,(()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,\"\"]]))}pluginScopeKeys(t){const e=t.id;return pn(`${this.type}-plugin-${e}`,(()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]]))}_cachedScopes(t,e){const i=this._scopeCache;let s=i.get(t);return s&&!e||(s=new Map,i.set(t,s)),s}getOptionScopes(t,e,i){const{options:s,type:n}=this,o=this._cachedScopes(t,i),a=o.get(e);if(a)return a;const r=new Set;e.forEach((e=>{t&&(r.add(t),e.forEach((e=>mn(r,t,e)))),e.forEach((t=>mn(r,s,t))),e.forEach((t=>mn(r,re[n]||{},t))),e.forEach((t=>mn(r,ue,t))),e.forEach((t=>mn(r,le,t)))}));const l=Array.from(r);return 0===l.length&&l.push(Object.create(null)),gn.has(e)&&o.set(e,l),l}chartOptionScopes(){const{options:t,type:e}=this;return[t,re[e]||{},ue.datasets[e]||{},{type:e},ue,le]}resolveNamedOptions(t,e,i,s=[\"\"]){const o={$shared:!0},{resolver:a,subPrefixes:r}=xn(this._resolverCache,t,s);let l=a;if(function(t,e){const{isScriptable:i,isIndexable:s}=Ye(t);for(const o of e){const e=i(o),a=s(o),r=(a||e)&&t[o];if(e&&(S(r)||_n(r))||a&&n(r))return!0}return!1}(a,e)){o.$shared=!1;l=$e(a,i=S(i)?i():i,this.createResolver(t,i,r))}for(const t of e)o[t]=l[t];return o}createResolver(t,e,i=[\"\"],s){const{resolver:n}=xn(this._resolverCache,t,i);return o(e)?$e(n,e,void 0,s):n}}function xn(t,e,i){let s=t.get(e);s||(s=new Map,t.set(e,s));const n=i.join();let o=s.get(n);if(!o){o={resolver:je(e,i),subPrefixes:i.filter((t=>!t.toLowerCase().includes(\"hover\")))},s.set(n,o)}return o}const _n=t=>o(t)&&Object.getOwnPropertyNames(t).some((e=>S(t[e])));const yn=[\"top\",\"bottom\",\"left\",\"right\",\"chartArea\"];function vn(t,e){return\"top\"===t||\"bottom\"===t||-1===yn.indexOf(t)&&\"x\"===e}function Mn(t,e){return function(i,s){return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}}function wn(t){const e=t.chart,i=e.options.animation;e.notifyPlugins(\"afterRender\"),d(i&&i.onComplete,[t],e)}function kn(t){const e=t.chart,i=e.options.animation;d(i&&i.onProgress,[t],e)}function Sn(t){return fe()&&\"string\"==typeof t?t=document.getElementById(t):t&&t.length&&(t=t[0]),t&&t.canvas&&(t=t.canvas),t}const Pn={},Dn=t=>{const e=Sn(t);return Object.values(Pn).filter((t=>t.canvas===e)).pop()};function Cn(t,e,i){const s=Object.keys(t);for(const n of s){const s=+n;if(s>=e){const o=t[n];delete t[n],(i>0||s>e)&&(t[s+i]=o)}}}function On(t,e,i){return t.options.clip?t[i]:e[i]}class An{static defaults=ue;static instances=Pn;static overrides=re;static registry=en;static version=\"4.4.1\";static getChart=Dn;static register(...t){en.add(...t),Tn()}static unregister(...t){en.remove(...t),Tn()}constructor(t,e){const s=this.config=new bn(e),n=Sn(t),o=Dn(n);if(o)throw new Error(\"Canvas is already in use. Chart with ID '\"+o.id+\"' must be destroyed before the canvas with ID '\"+o.canvas.id+\"' can be reused.\");const a=s.createResolver(s.chartOptionScopes(),this.getContext());this.platform=new(s.platform||ks(n)),this.platform.updateConfig(s);const r=this.platform.acquireContext(n,a.aspectRatio),l=r&&r.canvas,h=l&&l.height,c=l&&l.width;this.id=i(),this.ctx=r,this.canvas=l,this.width=c,this.height=h,this._options=a,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new sn,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=dt((t=>this.update(t)),a.resizeDelay||0),this._dataChanges=[],Pn[this.id]=this,r&&l?(xt.listen(this,\"complete\",wn),xt.listen(this,\"progress\",kn),this._initialize(),this.attached&&this.update()):console.error(\"Failed to create chart: can't acquire context from the given item\")}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:n,_aspectRatio:o}=this;return s(t)?e&&o?o:n?i/n:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}get registry(){return en}_initialize(){return this.notifyPlugins(\"beforeInit\"),this.options.responsive?this.resize():ke(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins(\"afterInit\"),this}clear(){return Te(this.canvas,this.ctx),this}stop(){return xt.stop(this),this}resize(t,e){xt.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const i=this.options,s=this.canvas,n=i.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,t,e,n),a=i.devicePixelRatio||this.platform.getDevicePixelRatio(),r=this.width?\"resize\":\"attach\";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,ke(this,a,!0)&&(this.notifyPlugins(\"resize\",{size:o}),d(i.onResize,[this,o],this),this.attached&&this._doResize(r)&&this.render())}ensureScalesHaveIDs(){u(this.options.scales||{},((t,e)=>{t.id=e}))}buildOrUpdateScales(){const t=this.options,e=t.scales,i=this.scales,s=Object.keys(i).reduce(((t,e)=>(t[e]=!1,t)),{});let n=[];e&&(n=n.concat(Object.keys(e).map((t=>{const i=e[t],s=ln(t,i),n=\"r\"===s,o=\"x\"===s;return{options:i,dposition:n?\"chartArea\":o?\"bottom\":\"left\",dtype:n?\"radialLinear\":o?\"category\":\"linear\"}})))),u(n,(e=>{const n=e.options,o=n.id,a=ln(o,n),r=l(n.type,e.dtype);void 0!==n.position&&vn(n.position,a)===vn(e.dposition)||(n.position=e.dposition),s[o]=!0;let h=null;if(o in i&&i[o].type===r)h=i[o];else{h=new(en.getScale(r))({id:o,type:r,ctx:this.ctx,chart:this}),i[h.id]=h}h.init(n,t)})),u(s,((t,e)=>{t||delete i[e]})),u(i,(t=>{as.configure(this,t,t.options),as.addBox(this,t)}))}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,i=t.length;if(t.sort(((t,e)=>t.index-e.index)),i>e){for(let t=e;t<i;++t)this._destroyDatasetMeta(t);t.splice(e,i-e)}this._sortedMetasets=t.slice(0).sort(Mn(\"order\",\"index\"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach(((t,i)=>{0===e.filter((e=>e===t._dataset)).length&&this._destroyDatasetMeta(i)}))}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let i,s;for(this._removeUnreferencedMetasets(),i=0,s=e.length;i<s;i++){const s=e[i];let n=this.getDatasetMeta(i);const o=s.type||this.config.type;if(n.type&&n.type!==o&&(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||an(o,this.options),n.order=s.order||0,n.index=i,n.label=\"\"+s.label,n.visible=this.isDatasetVisible(i),n.controller)n.controller.updateIndex(i),n.controller.linkScales();else{const e=en.getController(o),{datasetElementType:s,dataElementType:a}=ue.datasets[o];Object.assign(e,{dataElementType:en.getElement(a),datasetElementType:s&&en.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}}return this._updateMetasets(),t}_resetElements(){u(this.data.datasets,((t,e)=>{this.getDatasetMeta(e).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins(\"reset\")}update(t){const e=this.config;e.update();const i=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!i.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins(\"beforeUpdate\",{mode:t,cancelable:!0}))return;const n=this.buildOrUpdateControllers();this.notifyPlugins(\"beforeElementsUpdate\");let o=0;for(let t=0,e=this.data.datasets.length;t<e;t++){const{controller:e}=this.getDatasetMeta(t),i=!s&&-1===n.indexOf(e);e.buildOrUpdateElements(i),o=Math.max(+e.getMaxOverflow(),o)}o=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||u(n,(t=>{t.reset()})),this._updateDatasets(t),this.notifyPlugins(\"afterUpdate\",{mode:t}),this._layers.sort(Mn(\"z\",\"_idx\"));const{_active:a,_lastEvent:r}=this;r?this._eventHandler(r,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){u(this.scales,(t=>{as.removeBox(this,t)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),i=new Set(t.events);P(e,i)&&!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:i,start:s,count:n}of e){Cn(t,s,\"_removeElements\"===i?-n:n)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,i=e=>new Set(t.filter((t=>t[0]===e)).map(((t,e)=>e+\",\"+t.splice(1).join(\",\")))),s=i(0);for(let t=1;t<e;t++)if(!P(s,i(t)))return;return Array.from(s).map((t=>t.split(\",\"))).map((t=>({method:t[1],start:+t[2],count:+t[3]})))}_updateLayout(t){if(!1===this.notifyPlugins(\"beforeLayout\",{cancelable:!0}))return;as.update(this,this.width,this.height,t);const e=this.chartArea,i=e.width<=0||e.height<=0;this._layers=[],u(this.boxes,(t=>{i&&\"chartArea\"===t.position||(t.configure&&t.configure(),this._layers.push(...t._layers()))}),this),this._layers.forEach(((t,e)=>{t._idx=e})),this.notifyPlugins(\"afterLayout\")}_updateDatasets(t){if(!1!==this.notifyPlugins(\"beforeDatasetsUpdate\",{mode:t,cancelable:!0})){for(let t=0,e=this.data.datasets.length;t<e;++t)this.getDatasetMeta(t).controller.configure();for(let e=0,i=this.data.datasets.length;e<i;++e)this._updateDataset(e,S(t)?t({datasetIndex:e}):t);this.notifyPlugins(\"afterDatasetsUpdate\",{mode:t})}}_updateDataset(t,e){const i=this.getDatasetMeta(t),s={meta:i,index:t,mode:e,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetUpdate\",s)&&(i.controller._update(e),s.cancelable=!1,this.notifyPlugins(\"afterDatasetUpdate\",s))}render(){!1!==this.notifyPlugins(\"beforeRender\",{cancelable:!0})&&(xt.has(this)?this.attached&&!xt.running(this)&&xt.start(this):(this.draw(),wn({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:t,height:e}=this._resizeBeforeDraw;this._resize(t,e),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins(\"beforeDraw\",{cancelable:!0}))return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins(\"afterDraw\")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,i=[];let s,n;for(s=0,n=e.length;s<n;++s){const n=e[s];t&&!n.visible||i.push(n)}return i}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins(\"beforeDatasetsDraw\",{cancelable:!0}))return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins(\"afterDatasetsDraw\")}_drawDataset(t){const e=this.ctx,i=t._clip,s=!i.disabled,n=function(t,e){const{xScale:i,yScale:s}=t;return i&&s?{left:On(i,e,\"left\"),right:On(i,e,\"right\"),top:On(s,e,\"top\"),bottom:On(s,e,\"bottom\")}:e}(t,this.chartArea),o={meta:t,index:t.index,cancelable:!0};!1!==this.notifyPlugins(\"beforeDatasetDraw\",o)&&(s&&Ie(e,{left:!1===i.left?0:n.left-i.left,right:!1===i.right?this.width:n.right+i.right,top:!1===i.top?0:n.top-i.top,bottom:!1===i.bottom?this.height:n.bottom+i.bottom}),t.controller.draw(),s&&ze(e),o.cancelable=!1,this.notifyPlugins(\"afterDatasetDraw\",o))}isPointInArea(t){return Re(t,this.chartArea,this._minPadding)}getElementsAtEventForMode(t,e,i,s){const n=Xi.modes[e];return\"function\"==typeof n?n(this,t,i,s):[]}getDatasetMeta(t){const e=this.data.datasets[t],i=this._metasets;let s=i.filter((t=>t&&t._dataset===e)).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}getContext(){return this.$context||(this.$context=Ci(null,{chart:this,type:\"chart\"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const i=this.getDatasetMeta(t);return\"boolean\"==typeof i.hidden?!i.hidden:!e.hidden}setDatasetVisibility(t,e){this.getDatasetMeta(t).hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,i){const s=i?\"show\":\"hide\",n=this.getDatasetMeta(t),o=n.controller._resolveAnimations(void 0,s);k(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((e=>e.datasetIndex===t?s:void 0)))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),xt.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins(\"beforeDestroy\");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Te(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Pn[this.id],this.notifyPlugins(\"afterDestroy\")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(t,e,i)=>{t.offsetX=e,t.offsetY=i,this._eventHandler(t)};u(this.options.events,(t=>i(t,s)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,i=(i,s)=>{e.addEventListener(this,i,s),t[i]=s},s=(i,s)=>{t[i]&&(e.removeEventListener(this,i,s),delete t[i])},n=(t,e)=>{this.canvas&&this.resize(t,e)};let o;const a=()=>{s(\"attach\",a),this.attached=!0,this.resize(),i(\"resize\",n),i(\"detach\",o)};o=()=>{this.attached=!1,s(\"resize\",n),this._stop(),this._resize(0,0),i(\"attach\",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){u(this._listeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._listeners={},u(this._responsiveListeners,((t,e)=>{this.platform.removeEventListener(this,e,t)})),this._responsiveListeners=void 0}updateHoverStyle(t,e,i){const s=i?\"set\":\"remove\";let n,o,a,r;for(\"dataset\"===e&&(n=this.getDatasetMeta(t[0].datasetIndex),n.controller[\"_\"+s+\"DatasetHoverStyle\"]()),a=0,r=t.length;a<r;++a){o=t[a];const e=o&&this.getDatasetMeta(o.datasetIndex).controller;e&&e[s+\"HoverStyle\"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],i=t.map((({datasetIndex:t,index:e})=>{const i=this.getDatasetMeta(t);if(!i)throw new Error(\"No dataset found at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}}));!f(i,e)&&(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}notifyPlugins(t,e,i){return this._plugins.notify(this,t,e,i)}isPluginEnabled(t){return 1===this._plugins._cache.filter((e=>e.plugin.id===t)).length}_updateHoverStyles(t,e,i){const s=this.options.hover,n=(t,e)=>t.filter((t=>!e.some((e=>t.datasetIndex===e.datasetIndex&&t.index===e.index)))),o=n(e,t),a=i?t:n(t,e);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(t,e){const i={event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},s=e=>(e.options.events||this.options.events).includes(t.native.type);if(!1===this.notifyPlugins(\"beforeEvent\",i,s))return;const n=this._handleEvent(t,e,i.inChartArea);return i.cancelable=!1,this.notifyPlugins(\"afterEvent\",i,s),(n||i.changed)&&this.render(),this}_handleEvent(t,e,i){const{_active:s=[],options:n}=this,o=e,a=this._getActiveElements(t,s,i,o),r=D(t),l=function(t,e,i,s){return i&&\"mouseout\"!==t.type?s?e:t:null}(t,this._lastEvent,i,r);i&&(this._lastEvent=null,d(n.onHover,[t,a,this],this),r&&d(n.onClick,[t,a,this],this));const h=!f(a,s);return(h||e)&&(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=l,h}_getActiveElements(t,e,i,s){if(\"mouseout\"===t.type)return[];if(!i)return e;const n=this.options.hover;return this.getElementsAtEventForMode(t,n.mode,n,s)}}function Tn(){return u(An.instances,(t=>t._plugins.invalidate()))}function Ln(){throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\")}class En{static override(t){Object.assign(En.prototype,t)}options;constructor(t){this.options=t||{}}init(){}formats(){return Ln()}parse(){return Ln()}format(){return Ln()}add(){return Ln()}diff(){return Ln()}startOf(){return Ln()}endOf(){return Ln()}}var Rn={_date:En};function In(t){const e=t.iScale,i=function(t,e){if(!t._cache.$bar){const i=t.getMatchingVisibleMetas(e);let s=[];for(let e=0,n=i.length;e<n;e++)s=s.concat(i[e].controller.getAllParsedValues(t));t._cache.$bar=lt(s.sort(((t,e)=>t-e)))}return t._cache.$bar}(e,t.type);let s,n,o,a,r=e._length;const l=()=>{32767!==o&&-32768!==o&&(k(a)&&(r=Math.min(r,Math.abs(o-a)||r)),a=o)};for(s=0,n=i.length;s<n;++s)o=e.getPixelForValue(i[s]),l();for(a=void 0,s=0,n=e.ticks.length;s<n;++s)o=e.getPixelForTick(s),l();return r}function zn(t,e,i,s){return n(t)?function(t,e,i,s){const n=i.parse(t[0],s),o=i.parse(t[1],s),a=Math.min(n,o),r=Math.max(n,o);let l=a,h=r;Math.abs(a)>Math.abs(r)&&(l=r,h=a),e[i.axis]=h,e._custom={barStart:l,barEnd:h,start:n,end:o,min:a,max:r}}(t,e,i,s):e[i.axis]=i.parse(t,s),e}function Fn(t,e,i,s){const n=t.iScale,o=t.vScale,a=n.getLabels(),r=n===o,l=[];let h,c,d,u;for(h=i,c=i+s;h<c;++h)u=e[h],d={},d[n.axis]=r||n.parse(a[h],h),l.push(zn(u,d,o,h));return l}function Vn(t){return t&&void 0!==t.barStart&&void 0!==t.barEnd}function Bn(t,e,i,s){let n=e.borderSkipped;const o={};if(!n)return void(t.borderSkipped=o);if(!0===n)return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:a,end:r,reverse:l,top:h,bottom:c}=function(t){let e,i,s,n,o;return t.horizontal?(e=t.base>t.x,i=\"left\",s=\"right\"):(e=t.base<t.y,i=\"bottom\",s=\"top\"),e?(n=\"end\",o=\"start\"):(n=\"start\",o=\"end\"),{start:i,end:s,reverse:e,top:n,bottom:o}}(t);\"middle\"===n&&i&&(t.enableBorderRadius=!0,(i._top||0)===s?n=h:(i._bottom||0)===s?n=c:(o[Wn(c,a,r,l)]=!0,n=h)),o[Wn(n,a,r,l)]=!0,t.borderSkipped=o}function Wn(t,e,i,s){var n,o,a;return s?(a=i,t=Nn(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=Nn(t,e,i),t}function Nn(t,e,i){return\"start\"===t?e:\"end\"===t?i:t}function Hn(t,{inflateAmount:e},i){t.inflateAmount=\"auto\"===e?1===i?.33:0:e}class jn extends Ns{static id=\"doughnut\";static defaults={datasetElementType:!1,dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:\"number\",properties:[\"circumference\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"startAngle\",\"x\",\"y\",\"offset\",\"borderWidth\",\"spacing\"]}},cutout:\"50%\",rotation:0,circumference:360,radius:\"100%\",spacing:0,indexAxis:\"r\"};static descriptors={_scriptable:t=>\"spacing\"!==t,_indexable:t=>\"spacing\"!==t&&!t.startsWith(\"borderDash\")&&!t.startsWith(\"hoverBorderDash\")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}}};constructor(t,e){super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const i=this.getDataset().data,s=this._cachedMeta;if(!1===this._parsing)s._parsed=i;else{let n,a,r=t=>+i[t];if(o(i[t])){const{key:t=\"value\"}=this._parsing;r=e=>+M(i[e],t)}for(n=t,a=t+e;n<a;++n)s._parsed[n]=r(n)}}_getRotation(){return $(this.options.rotation-90)}_getCircumference(){return $(this.options.circumference)}_getRotationExtents(){let t=O,e=-O;for(let i=0;i<this.chart.data.datasets.length;++i)if(this.chart.isDatasetVisible(i)&&this.chart.getDatasetMeta(i).type===this._type){const s=this.chart.getDatasetMeta(i).controller,n=s._getRotation(),o=s._getCircumference();t=Math.min(t,n),e=Math.max(e,n+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:i}=e,s=this._cachedMeta,n=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,a=Math.max((Math.min(i.width,i.height)-o)/2,0),r=Math.min(h(this.options.cutout,a),1),l=this._getRingWeight(this.index),{circumference:d,rotation:u}=this._getRotationExtents(),{ratioX:f,ratioY:g,offsetX:p,offsetY:m}=function(t,e,i){let s=1,n=1,o=0,a=0;if(e<O){const r=t,l=r+e,h=Math.cos(r),c=Math.sin(r),d=Math.cos(l),u=Math.sin(l),f=(t,e,s)=>Z(t,r,l,!0)?1:Math.max(e,e*i,s,s*i),g=(t,e,s)=>Z(t,r,l,!0)?-1:Math.min(e,e*i,s,s*i),p=f(0,h,d),m=f(E,c,u),b=g(C,h,d),x=g(C+E,c,u);s=(p-b)/2,n=(m-x)/2,o=-(p+b)/2,a=-(m+x)/2}return{ratioX:s,ratioY:n,offsetX:o,offsetY:a}}(u,d,r),b=(i.width-o)/f,x=(i.height-o)/g,_=Math.max(Math.min(b,x)/2,0),y=c(this.options.radius,_),v=(y-Math.max(y*r,0))/this._getVisibleDatasetWeightTotal();this.offsetX=p*y,this.offsetY=m*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*l,0),this.updateElements(n,0,n.length,t)}_circumference(t,e){const i=this.options,s=this._cachedMeta,n=this._getCircumference();return e&&i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/O)}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.chartArea,r=o.options.animation,l=(a.left+a.right)/2,h=(a.top+a.bottom)/2,c=n&&r.animateScale,d=c?0:this.innerRadius,u=c?0:this.outerRadius,{sharedOptions:f,includeOptions:g}=this._getSharedOptions(e,s);let p,m=this._getRotation();for(p=0;p<e;++p)m+=this._circumference(p,n);for(p=e;p<e+i;++p){const e=this._circumference(p,n),i=t[p],o={x:l+this.offsetX,y:h+this.offsetY,startAngle:m,endAngle:m+e,circumference:e,outerRadius:u,innerRadius:d};g&&(o.options=f||this.resolveDataElementOptions(p,i.active?\"active\":s)),m+=e,this.updateElement(i,p,o,s)}}calculateTotal(){const t=this._cachedMeta,e=t.data;let i,s=0;for(i=0;i<e.length;i++){const n=t._parsed[i];null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}return s}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?O*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t],i.options.locale);return{label:s[t]||\"\",value:n}}getMaxBorderWidth(t){let e=0;const i=this.chart;let s,n,o,a,r;if(!t)for(s=0,n=i.data.datasets.length;s<n;++s)if(i.isDatasetVisible(s)){o=i.getDatasetMeta(s),t=o.data,a=o.controller;break}if(!t)return 0;for(s=0,n=t.length;s<n;++s)r=a.resolveDataElementOptions(s),\"inner\"!==r.borderAlign&&(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let i=0,s=t.length;i<s;++i){const t=this.resolveDataElementOptions(i);e=Math.max(e,t.offset||0,t.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e}_getRingWeight(t){return Math.max(l(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class $n extends Ns{static id=\"polarArea\";static defaults={dataElementType:\"arc\",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"]}},indexAxis:\"r\",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(t){const e=t.data;if(e.labels.length&&e.datasets.length){const{labels:{pointStyle:i,color:s}}=t.legend.options;return e.labels.map(((e,n)=>{const o=t.getDatasetMeta(0).controller.getStyle(n);return{text:e,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,fontColor:s,lineWidth:o.borderWidth,pointStyle:i,hidden:!t.getDataVisibility(n),index:n}}))}return[]}},onClick(t,e,i){i.chart.toggleDataVisibility(e.index),i.chart.update()}}},scales:{r:{type:\"radialLinear\",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(t,e){super(t,e),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],n=ne(e._parsed[t].r,i.options.locale);return{label:s[t]||\"\",value:n}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}getMinMax(){const t=this._cachedMeta,e={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return t.data.forEach(((t,i)=>{const s=this.getParsed(i).r;!isNaN(s)&&this.chart.getDataVisibility(i)&&(s<e.min&&(e.min=s),s>e.max&&(e.max=s))})),e}_updateRadius(){const t=this.chart,e=t.chartArea,i=t.options,s=Math.min(e.right-e.left,e.bottom-e.top),n=Math.max(s/2,0),o=(n-Math.max(i.cutoutPercentage?n/100*i.cutoutPercentage:1,0))/t.getVisibleDatasetCount();this.outerRadius=n-o*this.index,this.innerRadius=this.outerRadius-o}updateElements(t,e,i,s){const n=\"reset\"===s,o=this.chart,a=o.options.animation,r=this._cachedMeta.rScale,l=r.xCenter,h=r.yCenter,c=r.getIndexAngle(0)-.5*C;let d,u=c;const f=360/this.countVisibleElements();for(d=0;d<e;++d)u+=this._computeAngle(d,s,f);for(d=e;d<e+i;d++){const e=t[d];let i=u,g=u+this._computeAngle(d,s,f),p=o.getDataVisibility(d)?r.getDistanceFromCenterForValue(this.getParsed(d).r):0;u=g,n&&(a.animateScale&&(p=0),a.animateRotate&&(i=g=c));const m={x:l,y:h,innerRadius:0,outerRadius:p,startAngle:i,endAngle:g,options:this.resolveDataElementOptions(d,e.active?\"active\":s)};this.updateElement(e,d,m,s)}}countVisibleElements(){const t=this._cachedMeta;let e=0;return t.data.forEach(((t,i)=>{!isNaN(this.getParsed(i).r)&&this.chart.getDataVisibility(i)&&e++})),e}_computeAngle(t,e,i){return this.chart.getDataVisibility(t)?$(this.resolveDataElementOptions(t,e).angle||i):0}}var Yn=Object.freeze({__proto__:null,BarController:class extends Ns{static id=\"bar\";static defaults={datasetElementType:!1,dataElementType:\"bar\",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"base\",\"width\",\"height\"]}}};static overrides={scales:{_index_:{type:\"category\",offset:!0,grid:{offset:!0}},_value_:{type:\"linear\",beginAtZero:!0}}};parsePrimitiveData(t,e,i,s){return Fn(t,e,i,s)}parseArrayData(t,e,i,s){return Fn(t,e,i,s)}parseObjectData(t,e,i,s){const{iScale:n,vScale:o}=t,{xAxisKey:a=\"x\",yAxisKey:r=\"y\"}=this._parsing,l=\"x\"===n.axis?a:r,h=\"x\"===o.axis?a:r,c=[];let d,u,f,g;for(d=i,u=i+s;d<u;++d)g=e[d],f={},f[n.axis]=n.parse(M(g,l),d),c.push(zn(M(g,h),f,o,d));return c}updateRangeFromParsed(t,e,i,s){super.updateRangeFromParsed(t,e,i,s);const n=i._custom;n&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:i,vScale:s}=e,n=this.getParsed(t),o=n._custom,a=Vn(o)?\"[\"+o.start+\", \"+o.end+\"]\":\"\"+s.getLabelForValue(n[s.axis]);return{label:\"\"+i.getLabelForValue(n[i.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{index:a,_cachedMeta:{vScale:r}}=this,l=r.getBasePixel(),h=r.isHorizontal(),c=this._getRuler(),{sharedOptions:d,includeOptions:u}=this._getSharedOptions(e,n);for(let f=e;f<e+i;f++){const e=this.getParsed(f),i=o||s(e[r.axis])?{base:l,head:l}:this._calculateBarValuePixels(f),g=this._calculateBarIndexPixels(f,c),p=(e._stacks||{})[r.axis],m={horizontal:h,base:i.base,enableBorderRadius:!p||Vn(e._custom)||a===p._top||a===p._bottom,x:h?i.head:g.center,y:h?g.center:i.head,height:h?g.size:Math.abs(i.size),width:h?Math.abs(i.size):g.size};u&&(m.options=d||this.resolveDataElementOptions(f,t[f].active?\"active\":n));const b=m.options||t[f].options;Bn(m,b,p,a),Hn(m,b,c.ratio),this.updateElement(t[f],f,m,n)}}_getStacks(t,e){const{iScale:i}=this._cachedMeta,n=i.getMatchingVisibleMetas(this._type).filter((t=>t.controller.options.grouped)),o=i.options.stacked,a=[],r=t=>{const i=t.controller.getParsed(e),n=i&&i[t.vScale.axis];if(s(n)||isNaN(n))return!0};for(const i of n)if((void 0===e||!r(i))&&((!1===o||-1===a.indexOf(i.stack)||void 0===o&&void 0===i.stack)&&a.push(i.stack),i.index===t))break;return a.length||a.push(void 0),a}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,i){const s=this._getStacks(t,i),n=void 0!==e?s.indexOf(e):-1;return-1===n?s.length-1:n}_getRuler(){const t=this.options,e=this._cachedMeta,i=e.iScale,s=[];let n,o;for(n=0,o=e.data.length;n<o;++n)s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));const a=t.barThickness;return{min:a||In(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:n},options:{base:o,minBarLength:a}}=this,r=o||0,l=this.getParsed(t),h=l._custom,c=Vn(h);let d,u,f=l[e.axis],g=0,p=i?this.applyStack(e,l,i):f;p!==f&&(g=p-f,p=f),c&&(f=h.barStart,p=h.barEnd-h.barStart,0!==f&&F(f)!==F(h.barEnd)&&(g=0),g+=f);const m=s(o)||c?g:o;let b=e.getPixelForValue(m);if(d=this.chart.getDataVisibility(t)?e.getPixelForValue(g+p):b,u=d-b,Math.abs(u)<a){u=function(t,e,i){return 0!==t?F(t):(e.isHorizontal()?1:-1)*(e.min>=i?1:-1)}(u,e,r)*a,f===r&&(b-=u/2);const t=e.getPixelForDecimal(0),s=e.getPixelForDecimal(1),o=Math.min(t,s),h=Math.max(t,s);b=Math.max(Math.min(b,h),o),d=b+u,i&&!c&&(l._stacks[e.axis]._visualValues[n]=e.getValueForPixel(d)-e.getValueForPixel(b))}if(b===e.getPixelForValue(r)){const t=F(u)*e.getLineWidthForValue(r)/2;b+=t,u-=t}return{size:u,base:b,head:d,center:d+u/2}}_calculateBarIndexPixels(t,e){const i=e.scale,n=this.options,o=n.skipNull,a=l(n.maxBarThickness,1/0);let r,h;if(e.grouped){const i=o?this._getStackCount(t):e.stackCount,l=\"flex\"===n.barThickness?function(t,e,i,s){const n=e.pixels,o=n[t];let a=t>0?n[t-1]:null,r=t<n.length-1?n[t+1]:null;const l=i.categoryPercentage;null===a&&(a=o-(null===r?e.end-e.start:r-o)),null===r&&(r=o+o-a);const h=o-(o-Math.min(a,r))/2*l;return{chunk:Math.abs(r-a)/2*l/s,ratio:i.barPercentage,start:h}}(t,e,n,i):function(t,e,i,n){const o=i.barThickness;let a,r;return s(o)?(a=e.min*i.categoryPercentage,r=i.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}(t,e,n,i),c=this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0);r=l.start+l.chunk*c+l.chunk/2,h=Math.min(a,l.chunk*l.ratio)}else r=i.getPixelForValue(this.getParsed(t)[i.axis],t),h=Math.min(a,e.min*e.ratio);return{base:r-h/2,head:r+h/2,center:r,size:h}}draw(){const t=this._cachedMeta,e=t.vScale,i=t.data,s=i.length;let n=0;for(;n<s;++n)null!==this.getParsed(n)[e.axis]&&i[n].draw(this._ctx)}},BubbleController:class extends Ns{static id=\"bubble\";static defaults={datasetElementType:!1,dataElementType:\"point\",animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"borderWidth\",\"radius\"]}}};static overrides={scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,i,s){const n=super.parsePrimitiveData(t,e,i,s);for(let t=0;t<n.length;t++)n[t]._custom=this.resolveDataElementOptions(t+i).radius;return n}parseArrayData(t,e,i,s){const n=super.parseArrayData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s[2],this.resolveDataElementOptions(t+i).radius)}return n}parseObjectData(t,e,i,s){const n=super.parseObjectData(t,e,i,s);for(let t=0;t<n.length;t++){const s=e[i+t];n[t]._custom=l(s&&s.r&&+s.r,this.resolveDataElementOptions(t+i).radius)}return n}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let i=t.length-1;i>=0;--i)e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y),l=o._custom;return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+(l?\", \"+l:\"\")+\")\"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,i,s){const n=\"reset\"===s,{iScale:o,vScale:a}=this._cachedMeta,{sharedOptions:r,includeOptions:l}=this._getSharedOptions(e,s),h=o.axis,c=a.axis;for(let d=e;d<e+i;d++){const e=t[d],i=!n&&this.getParsed(d),u={},f=u[h]=n?o.getPixelForDecimal(.5):o.getPixelForValue(i[h]),g=u[c]=n?a.getBasePixel():a.getPixelForValue(i[c]);u.skip=isNaN(f)||isNaN(g),l&&(u.options=r||this.resolveDataElementOptions(d,e.active?\"active\":s),n&&(u.options.radius=0)),this.updateElement(e,d,u,s)}}resolveDataElementOptions(t,e){const i=this.getParsed(t);let s=super.resolveDataElementOptions(t,e);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const n=s.radius;return\"active\"!==e&&(s.radius=0),s.radius+=l(i&&i._custom,n),s}},DoughnutController:jn,LineController:class extends Ns{static id=\"line\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:\"category\"},_value_:{type:\"linear\"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:i,data:s=[],_dataset:n}=e,o=this.chart._animationsDisabled;let{start:a,count:r}=pt(e,s,o);this._drawStart=a,this._drawCount=r,mt(e)&&(a=0,r=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;const l=this.resolveDatasetElementOptions(t);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:l},t),this.updateElements(s,a,r,t)}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,{sharedOptions:c,includeOptions:d}=this._getSharedOptions(e,n),u=a.axis,f=r.axis,{spanGaps:g,segment:p}=this.options,m=N(g)?g:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||o||\"none\"===n,x=e+i,_=t.length;let y=e>0&&this.getParsed(e-1);for(let i=0;i<_;++i){const g=t[i],_=b?g:{};if(i<e||i>=x){_.skip=!0;continue}const v=this.getParsed(i),M=s(v[f]),w=_[u]=a.getPixelForValue(v[u],i),k=_[f]=o||M?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,v,l):v[f],i);_.skip=isNaN(w)||isNaN(k)||M,_.stop=i>0&&Math.abs(v[u]-y[u])>m,p&&(_.parsed=v,_.raw=h.data[i]),d&&(_.options=c||this.resolveDataElementOptions(i,g.active?\"active\":n)),b||this.updateElement(g,i,_,n),y=v}}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,i=e.options&&e.options.borderWidth||0,s=t.data||[];if(!s.length)return i;const n=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(i,n,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}},PieController:class extends jn{static id=\"pie\";static defaults={cutout:0,rotation:0,circumference:360,radius:\"100%\"}},PolarAreaController:$n,RadarController:class extends Ns{static id=\"radar\";static defaults={datasetElementType:\"line\",dataElementType:\"point\",indexAxis:\"r\",showLine:!0,elements:{line:{fill:\"start\"}}};static overrides={aspectRatio:1,scales:{r:{type:\"radialLinear\"}}};getLabelAndValue(t){const e=this._cachedMeta.vScale,i=this.getParsed(t);return{label:e.getLabels()[t],value:\"\"+e.getLabelForValue(i[e.axis])}}parseObjectData(t,e,i,s){return ii.bind(this)(t,e,i,s)}update(t){const e=this._cachedMeta,i=e.dataset,s=e.data||[],n=e.iScale.getLabels();if(i.points=s,\"resize\"!==t){const e=this.resolveDatasetElementOptions(t);this.options.showLine||(e.borderWidth=0);const o={_loop:!0,_fullLoop:n.length===s.length,options:e};this.updateElement(i,void 0,o,t)}this.updateElements(s,0,s.length,t)}updateElements(t,e,i,s){const n=this._cachedMeta.rScale,o=\"reset\"===s;for(let a=e;a<e+i;a++){const e=t[a],i=this.resolveDataElementOptions(a,e.active?\"active\":s),r=n.getPointPositionForValue(a,this.getParsed(a).r),l=o?n.xCenter:r.x,h=o?n.yCenter:r.y,c={x:l,y:h,angle:r.angle,skip:isNaN(l)||isNaN(h),options:i};this.updateElement(e,a,c,s)}}},ScatterController:class extends Ns{static id=\"scatter\";static defaults={datasetElementType:!1,dataElementType:\"point\",showLine:!1,fill:!1};static overrides={interaction:{mode:\"point\"},scales:{x:{type:\"linear\"},y:{type:\"linear\"}}};getLabelAndValue(t){const e=this._cachedMeta,i=this.chart.data.labels||[],{xScale:s,yScale:n}=e,o=this.getParsed(t),a=s.getLabelForValue(o.x),r=n.getLabelForValue(o.y);return{label:i[t]||\"\",value:\"(\"+a+\", \"+r+\")\"}}update(t){const e=this._cachedMeta,{data:i=[]}=e,s=this.chart._animationsDisabled;let{start:n,count:o}=pt(e,i,s);if(this._drawStart=n,this._drawCount=o,mt(e)&&(n=0,o=i.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:n,_dataset:o}=e;n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!o._decimated,n.points=i;const a=this.resolveDatasetElementOptions(t);a.segment=this.options.segment,this.updateElement(n,void 0,{animated:!s,options:a},t)}else this.datasetElementType&&(delete e.dataset,this.datasetElementType=!1);this.updateElements(i,n,o,t)}addElements(){const{showLine:t}=this.options;!this.datasetElementType&&t&&(this.datasetElementType=this.chart.registry.getElement(\"line\")),super.addElements()}updateElements(t,e,i,n){const o=\"reset\"===n,{iScale:a,vScale:r,_stacked:l,_dataset:h}=this._cachedMeta,c=this.resolveDataElementOptions(e,n),d=this.getSharedOptions(c),u=this.includeOptions(n,d),f=a.axis,g=r.axis,{spanGaps:p,segment:m}=this.options,b=N(p)?p:Number.POSITIVE_INFINITY,x=this.chart._animationsDisabled||o||\"none\"===n;let _=e>0&&this.getParsed(e-1);for(let c=e;c<e+i;++c){const e=t[c],i=this.getParsed(c),p=x?e:{},y=s(i[g]),v=p[f]=a.getPixelForValue(i[f],c),M=p[g]=o||y?r.getBasePixel():r.getPixelForValue(l?this.applyStack(r,i,l):i[g],c);p.skip=isNaN(v)||isNaN(M)||y,p.stop=c>0&&Math.abs(i[f]-_[f])>b,m&&(p.parsed=i,p.raw=h.data[c]),u&&(p.options=d||this.resolveDataElementOptions(c,e.active?\"active\":n)),x||this.updateElement(e,c,p,n),_=i}this.updateSharedOptions(d,n,c)}getMaxOverflow(){const t=this._cachedMeta,e=t.data||[];if(!this.options.showLine){let t=0;for(let i=e.length-1;i>=0;--i)t=Math.max(t,e[i].size(this.resolveDataElementOptions(i))/2);return t>0&&t}const i=t.dataset,s=i.options&&i.options.borderWidth||0;if(!e.length)return s;const n=e[0].size(this.resolveDataElementOptions(0)),o=e[e.length-1].size(this.resolveDataElementOptions(e.length-1));return Math.max(s,n,o)/2}}});function Un(t,e,i,s){const n=vi(t.options.borderRadius,[\"outerStart\",\"outerEnd\",\"innerStart\",\"innerEnd\"]);const o=(i-e)/2,a=Math.min(o,s*e/2),r=t=>{const e=(i-Math.min(o,t))*s/2;return J(t,0,Math.min(o,e))};return{outerStart:r(n.outerStart),outerEnd:r(n.outerEnd),innerStart:J(n.innerStart,0,a),innerEnd:J(n.innerEnd,0,a)}}function Xn(t,e,i,s){return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}function qn(t,e,i,s,n,o){const{x:a,y:r,startAngle:l,pixelMargin:h,innerRadius:c}=e,d=Math.max(e.outerRadius+s+i-h,0),u=c>0?c+s+i+h:0;let f=0;const g=n-l;if(s){const t=((c>0?c-s:0)+(d>0?d-s:0))/2;f=(g-(0!==t?g*t/(t+s):g))/2}const p=(g-Math.max(.001,g*d-i/C)/d)/2,m=l+p+f,b=n-p-f,{outerStart:x,outerEnd:_,innerStart:y,innerEnd:v}=Un(e,u,d,b-m),M=d-x,w=d-_,k=m+x/M,S=b-_/w,P=u+y,D=u+v,O=m+y/P,A=b-v/D;if(t.beginPath(),o){const e=(k+S)/2;if(t.arc(a,r,d,k,e),t.arc(a,r,d,e,S),_>0){const e=Xn(w,S,a,r);t.arc(e.x,e.y,_,S,b+E)}const i=Xn(D,b,a,r);if(t.lineTo(i.x,i.y),v>0){const e=Xn(D,A,a,r);t.arc(e.x,e.y,v,b+E,A+Math.PI)}const s=(b-v/u+(m+y/u))/2;if(t.arc(a,r,u,b-v/u,s,!0),t.arc(a,r,u,s,m+y/u,!0),y>0){const e=Xn(P,O,a,r);t.arc(e.x,e.y,y,O+Math.PI,m-E)}const n=Xn(M,m,a,r);if(t.lineTo(n.x,n.y),x>0){const e=Xn(M,k,a,r);t.arc(e.x,e.y,x,m-E,k)}}else{t.moveTo(a,r);const e=Math.cos(k)*d+a,i=Math.sin(k)*d+r;t.lineTo(e,i);const s=Math.cos(S)*d+a,n=Math.sin(S)*d+r;t.lineTo(s,n)}t.closePath()}function Kn(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r,options:l}=e,{borderWidth:h,borderJoinStyle:c,borderDash:d,borderDashOffset:u}=l,f=\"inner\"===l.borderAlign;if(!h)return;t.setLineDash(d||[]),t.lineDashOffset=u,f?(t.lineWidth=2*h,t.lineJoin=c||\"round\"):(t.lineWidth=h,t.lineJoin=c||\"bevel\");let g=e.endAngle;if(o){qn(t,e,i,s,g,n);for(let e=0;e<o;++e)t.stroke();isNaN(r)||(g=a+(r%O||O))}f&&function(t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:a,outerRadius:r,innerRadius:l}=e;let h=n/r;t.beginPath(),t.arc(o,a,r,s-h,i+h),l>n?(h=n/l,t.arc(o,a,l,i+h,s-h,!0)):t.arc(o,a,n,i+E,s-E),t.closePath(),t.clip()}(t,e,g),o||(qn(t,e,i,s,g,n),t.stroke())}function Gn(t,e,i=e){t.lineCap=l(i.borderCapStyle,e.borderCapStyle),t.setLineDash(l(i.borderDash,e.borderDash)),t.lineDashOffset=l(i.borderDashOffset,e.borderDashOffset),t.lineJoin=l(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=l(i.borderWidth,e.borderWidth),t.strokeStyle=l(i.borderColor,e.borderColor)}function Zn(t,e,i){t.lineTo(i.x,i.y)}function Jn(t,e,i={}){const s=t.length,{start:n=0,end:o=s-1}=i,{start:a,end:r}=e,l=Math.max(n,a),h=Math.min(o,r),c=n<a&&o<a||n>r&&o>r;return{count:s,start:l,loop:e.loop,ilen:h<l&&!c?s+h-l:h-l}}function Qn(t,e,i,s){const{points:n,options:o}=e,{count:a,start:r,loop:l,ilen:h}=Jn(n,i,s),c=function(t){return t.stepped?Fe:t.tension||\"monotone\"===t.cubicInterpolationMode?Ve:Zn}(o);let d,u,f,{move:g=!0,reverse:p}=s||{};for(d=0;d<=h;++d)u=n[(r+(p?h-d:d))%a],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);return l&&(u=n[(r+(p?h:0))%a],c(t,f,u,p,o.stepped)),!!l}function to(t,e,i,s){const n=e.points,{count:o,start:a,ilen:r}=Jn(n,i,s),{move:l=!0,reverse:h}=s||{};let c,d,u,f,g,p,m=0,b=0;const x=t=>(a+(h?r-t:t))%o,_=()=>{f!==g&&(t.lineTo(m,g),t.lineTo(m,f),t.lineTo(m,p))};for(l&&(d=n[x(0)],t.moveTo(d.x,d.y)),c=0;c<=r;++c){if(d=n[x(c)],d.skip)continue;const e=d.x,i=d.y,s=0|e;s===u?(i<f?f=i:i>g&&(g=i),m=(b*m+e)/++b):(_(),t.lineTo(e,i),u=s,b=0,f=g=i),p=i}_()}function eo(t){const e=t.options,i=e.borderDash&&e.borderDash.length;return!(t._decimated||t._loop||e.tension||\"monotone\"===e.cubicInterpolationMode||e.stepped||i)?to:Qn}const io=\"function\"==typeof Path2D;function so(t,e,i,s){io&&!e.options.segment?function(t,e,i,s){let n=e._path;n||(n=e._path=new Path2D,e.path(n,i,s)&&n.closePath()),Gn(t,e.options),t.stroke(n)}(t,e,i,s):function(t,e,i,s){const{segments:n,options:o}=e,a=eo(e);for(const r of n)Gn(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&&t.closePath(),t.stroke()}(t,e,i,s)}class no extends Hs{static id=\"line\";static defaults={borderCapStyle:\"butt\",borderDash:[],borderDashOffset:0,borderJoinStyle:\"miter\",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:\"default\",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t&&\"fill\"!==t};constructor(t){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const i=this.options;if((i.tension||\"monotone\"===i.cubicInterpolationMode)&&!i.stepped&&!this._pointsUpdated){const s=i.spanGaps?this._loop:this._fullLoop;hi(this._points,i,t,s,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=zi(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,i=t.length;return i&&e[t[i-1].end]}interpolate(t,e){const i=this.options,s=t[e],n=this.points,o=Ii(this,{property:e,start:s,end:s});if(!o.length)return;const a=[],r=function(t){return t.stepped?pi:t.tension||\"monotone\"===t.cubicInterpolationMode?mi:gi}(i);let l,h;for(l=0,h=o.length;l<h;++l){const{start:h,end:c}=o[l],d=n[h],u=n[c];if(d===u){a.push(d);continue}const f=r(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);f[e]=t[e],a.push(f)}return 1===a.length?a[0]:a}pathSegment(t,e,i){return eo(this)(t,this,e,i)}path(t,e,i){const s=this.segments,n=eo(this);let o=this._loop;e=e||0,i=i||this.points.length-e;for(const a of s)o&=n(t,this,a,{start:e,end:e+i-1});return!!o}draw(t,e,i,s){const n=this.options||{};(this.points||[]).length&&n.borderWidth&&(t.save(),so(t,this,i,s),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function oo(t,e,i,s){const n=t.options,{[i]:o}=t.getProps([i],s);return Math.abs(e-o)<n.radius+n.hitRadius}function ao(t,e){const{x:i,y:s,base:n,width:o,height:a}=t.getProps([\"x\",\"y\",\"base\",\"width\",\"height\"],e);let r,l,h,c,d;return t.horizontal?(d=a/2,r=Math.min(i,n),l=Math.max(i,n),h=s-d,c=s+d):(d=o/2,r=i-d,l=i+d,h=Math.min(s,n),c=Math.max(s,n)),{left:r,top:h,right:l,bottom:c}}function ro(t,e,i,s){return t?0:J(e,i,s)}function lo(t){const e=ao(t),i=e.right-e.left,s=e.bottom-e.top,n=function(t,e,i){const s=t.options.borderWidth,n=t.borderSkipped,o=Mi(s);return{t:ro(n.top,o.top,0,i),r:ro(n.right,o.right,0,e),b:ro(n.bottom,o.bottom,0,i),l:ro(n.left,o.left,0,e)}}(t,i/2,s/2),a=function(t,e,i){const{enableBorderRadius:s}=t.getProps([\"enableBorderRadius\"]),n=t.options.borderRadius,a=wi(n),r=Math.min(e,i),l=t.borderSkipped,h=s||o(n);return{topLeft:ro(!h||l.top||l.left,a.topLeft,0,r),topRight:ro(!h||l.top||l.right,a.topRight,0,r),bottomLeft:ro(!h||l.bottom||l.left,a.bottomLeft,0,r),bottomRight:ro(!h||l.bottom||l.right,a.bottomRight,0,r)}}(t,i/2,s/2);return{outer:{x:e.left,y:e.top,w:i,h:s,radius:a},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,a.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(n.b,n.r))}}}}function ho(t,e,i,s){const n=null===e,o=null===i,a=t&&!(n&&o)&&ao(t,s);return a&&(n||tt(e,a.left,a.right))&&(o||tt(i,a.top,a.bottom))}function co(t,e){t.rect(e.x,e.y,e.w,e.h)}function uo(t,e,i={}){const s=t.x!==i.x?-e:0,n=t.y!==i.y?-e:0,o=(t.x+t.w!==i.x+i.w?e:0)-s,a=(t.y+t.h!==i.y+i.h?e:0)-n;return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}var fo=Object.freeze({__proto__:null,ArcElement:class extends Hs{static id=\"arc\";static defaults={borderAlign:\"center\",borderColor:\"#fff\",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0};static defaultRoutes={backgroundColor:\"backgroundColor\"};static descriptors={_scriptable:!0,_indexable:t=>\"borderDash\"!==t};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(t){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.getProps([\"x\",\"y\"],i),{angle:n,distance:o}=X(s,{x:t,y:e}),{startAngle:a,endAngle:r,innerRadius:h,outerRadius:c,circumference:d}=this.getProps([\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\",\"circumference\"],i),u=(this.options.spacing+this.options.borderWidth)/2,f=l(d,r-a)>=O||Z(n,a,r),g=tt(o,h+u,c+u);return f&&g}getCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=this.getProps([\"x\",\"y\",\"startAngle\",\"endAngle\",\"innerRadius\",\"outerRadius\"],t),{offset:r,spacing:l}=this.options,h=(s+n)/2,c=(o+a+l+r)/2;return{x:e+Math.cos(h)*c,y:i+Math.sin(h)*c}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:i}=this,s=(e.offset||0)/4,n=(e.spacing||0)/2,o=e.circular;if(this.pixelMargin=\"inner\"===e.borderAlign?.33:0,this.fullCircles=i>O?Math.floor(i/O):0,0===i||this.innerRadius<0||this.outerRadius<0)return;t.save();const a=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(a)*s,Math.sin(a)*s);const r=s*(1-Math.sin(Math.min(C,i||0)));t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,function(t,e,i,s,n){const{fullCircles:o,startAngle:a,circumference:r}=e;let l=e.endAngle;if(o){qn(t,e,i,s,l,n);for(let e=0;e<o;++e)t.fill();isNaN(r)||(l=a+(r%O||O))}qn(t,e,i,s,l,n),t.fill()}(t,this,r,n,o),Kn(t,this,r,n,o),t.restore()}},BarElement:class extends Hs{static id=\"bar\";static defaults={borderSkipped:\"start\",borderWidth:0,borderRadius:0,inflateAmount:\"auto\",pointStyle:void 0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=this,{inner:n,outer:o}=lo(this),a=(r=o.radius).topLeft||r.topRight||r.bottomLeft||r.bottomRight?He:co;var r;t.save(),o.w===n.w&&o.h===n.h||(t.beginPath(),a(t,uo(o,e,n)),t.clip(),a(t,uo(n,-e,o)),t.fillStyle=i,t.fill(\"evenodd\")),t.beginPath(),a(t,uo(n,e)),t.fillStyle=s,t.fill(),t.restore()}inRange(t,e,i){return ho(this,t,e,i)}inXRange(t,e){return ho(this,t,null,e)}inYRange(t,e){return ho(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=this.getProps([\"x\",\"y\",\"base\",\"horizontal\"],t);return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}getRange(t){return\"x\"===t?this.width/2:this.height/2}},LineElement:no,PointElement:class extends Hs{static id=\"point\";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:\"circle\",radius:3,rotation:0};static defaultRoutes={backgroundColor:\"backgroundColor\",borderColor:\"borderColor\"};constructor(t){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.options,{x:n,y:o}=this.getProps([\"x\",\"y\"],i);return Math.pow(t-n,2)+Math.pow(e-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(t,e){return oo(this,t,\"x\",e)}inYRange(t,e){return oo(this,t,\"y\",e)}getCenterPoint(t){const{x:e,y:i}=this.getProps([\"x\",\"y\"],t);return{x:e,y:i}}size(t){let e=(t=t||this.options||{}).radius||0;e=Math.max(e,e&&t.hoverRadius||0);return 2*(e+(e&&t.borderWidth||0))}draw(t,e){const i=this.options;this.skip||i.radius<.1||!Re(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Le(t,i,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}});function go(t,e,i,s){const n=t.indexOf(e);if(-1===n)return((t,e,i,s)=>(\"string\"==typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&&(i=null),i))(t,e,i,s);return n!==t.lastIndexOf(e)?i:n}function po(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}function mo(t,e,{horizontal:i,minRotation:s}){const n=$(s),o=(i?Math.sin(n):Math.cos(n))||.001,a=.75*e*(\"\"+t).length;return Math.min(e/o,a)}class bo extends Js{constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return s(t)||(\"number\"==typeof t||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:i}=this.getUserBounds();let{min:s,max:n}=this;const o=t=>s=e?s:t,a=t=>n=i?n:t;if(t){const t=F(s),e=F(n);t<0&&e<0?a(0):t>0&&e>0&&o(0)}if(s===n){let e=0===n?1:Math.abs(.05*n);a(n+e),t||o(s-e)}this.min=s,this.max=n}getTickLimit(){const t=this.options.ticks;let e,{maxTicksLimit:i,stepSize:s}=t;return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&&(e=Math.min(i,e)),e}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let i=this.getTickLimit();i=Math.max(2,i);const n=function(t,e){const i=[],{bounds:n,step:o,min:a,max:r,precision:l,count:h,maxTicks:c,maxDigits:d,includeBounds:u}=t,f=o||1,g=c-1,{min:p,max:m}=e,b=!s(a),x=!s(r),_=!s(h),y=(m-p)/(d+1);let v,M,w,k,S=B((m-p)/g/f)*f;if(S<1e-14&&!b&&!x)return[{value:p},{value:m}];k=Math.ceil(m/S)-Math.floor(p/S),k>g&&(S=B(k*S/g/f)*f),s(l)||(v=Math.pow(10,l),S=Math.ceil(S*v)/v),\"ticks\"===n?(M=Math.floor(p/S)*S,w=Math.ceil(m/S)*S):(M=p,w=m),b&&x&&o&&H((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,M=a,w=r):_?(M=b?a:M,w=x?r:w,k=h-1,S=(w-M)/k):(k=(w-M)/S,k=V(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));const P=Math.max(U(S),U(M));v=Math.pow(10,s(l)?P:l),M=Math.round(M*v)/v,w=Math.round(w*v)/v;let D=0;for(b&&(u&&M!==a?(i.push({value:a}),M<a&&D++,V(Math.round((M+D*S)*v)/v,a,mo(a,y,t))&&D++):M<a&&D++);D<k;++D){const t=Math.round((M+D*S)*v)/v;if(x&&t>r)break;i.push({value:t})}return x&&u&&w!==r?i.length&&V(i[i.length-1].value,r,mo(r,y,t))?i[i.length-1].value=r:i.push({value:r}):x&&w!==r||i.push({value:w}),i}({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);return\"ticks\"===t.bounds&&j(n,this,\"value\"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}configure(){const t=this.ticks;let e=this.min,i=this.max;if(super.configure(),this.options.offset&&t.length){const s=(i-e)/Math.max(t.length-1,1)/2;e-=s,i+=s}this._startValue=e,this._endValue=i,this._valueRange=i-e}getLabelForValue(t){return ne(t,this.chart.options.locale,this.options.ticks.format)}}class xo extends bo{static id=\"linear\";static defaults={ticks:{callback:ae.formatters.numeric}};determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?t:0,this.max=a(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,i=$(this.options.ticks.minRotation),s=(t?Math.sin(i):Math.cos(i))||.001,n=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,n.lineHeight/s))}getPixelForValue(t){return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}const _o=t=>Math.floor(z(t)),yo=(t,e)=>Math.pow(10,_o(t)+e);function vo(t){return 1===t/Math.pow(10,_o(t))}function Mo(t,e,i){const s=Math.pow(10,i),n=Math.floor(t/s);return Math.ceil(e/s)-n}function wo(t,{min:e,max:i}){e=r(t.min,e);const s=[],n=_o(e);let o=function(t,e){let i=_o(e-t);for(;Mo(t,e,i)>10;)i++;for(;Mo(t,e,i)<10;)i--;return Math.min(i,_o(t))}(e,i),a=o<0?Math.pow(10,Math.abs(o)):1;const l=Math.pow(10,o),h=n>o?Math.pow(10,n):0,c=Math.round((e-h)*a)/a,d=Math.floor((e-h)/l/10)*l*10;let u=Math.floor((c-d)/Math.pow(10,o)),f=r(t.min,Math.round((h+d+u*Math.pow(10,o))*a)/a);for(;f<i;)s.push({value:f,major:vo(f),significand:u}),u>=10?u=u<15?15:20:u++,u>=20&&(o++,u=2,a=o>=0?1:a),f=Math.round((h+d+u*Math.pow(10,o))*a)/a;const g=r(t.max,f);return s.push({value:g,major:vo(g),significand:u}),s}class ko extends Js{static id=\"logarithmic\";static defaults={ticks:{callback:ae.formatters.logarithmic,major:{enabled:!0}}};constructor(t){super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const i=bo.prototype.parse.apply(this,[t,e]);if(0!==i)return a(i)&&i>0?i:null;this._zero=!0}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=a(t)?Math.max(0,t):null,this.max=a(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!a(this._userMin)&&(this.min=t===yo(this.min,0)?yo(this.min,-1):yo(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let i=this.min,s=this.max;const n=e=>i=t?i:e,o=t=>s=e?s:t;i===s&&(i<=0?(n(1),o(10)):(n(yo(i,-1)),o(yo(s,1)))),i<=0&&n(yo(s,-1)),s<=0&&o(yo(i,1)),this.min=i,this.max=s}buildTicks(){const t=this.options,e=wo({min:this._userMin,max:this._userMax},this);return\"ticks\"===t.bounds&&j(e,this,\"value\"),t.reverse?(e.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),e}getLabelForValue(t){return void 0===t?\"0\":ne(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=z(t),this._valueRange=z(this.max)-z(t)}getPixelForValue(t){return void 0!==t&&0!==t||(t=this.min),null===t||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(z(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}function So(t){const e=t.ticks;if(e.display&&t.display){const t=ki(e.backdropPadding);return l(e.font&&e.font.size,ue.font.size)+t.height}return 0}function Po(t,e,i,s,n){return t===s||t===n?{start:e-i/2,end:e+i/2}:t<s||t>n?{start:e-i,end:e}:{start:e,end:e+i}}function Do(t){const e={l:t.left+t._padding.left,r:t.right-t._padding.right,t:t.top+t._padding.top,b:t.bottom-t._padding.bottom},i=Object.assign({},e),s=[],o=[],a=t._pointLabels.length,r=t.options.pointLabels,l=r.centerPointLabels?C/a:0;for(let u=0;u<a;u++){const a=r.setContext(t.getPointLabelContext(u));o[u]=a.padding;const f=t.getPointPosition(u,t.drawingArea+o[u],l),g=Si(a.font),p=(h=t.ctx,c=g,d=n(d=t._pointLabels[u])?d:[d],{w:Oe(h,c.string,d),h:d.length*c.lineHeight});s[u]=p;const m=G(t.getIndexAngle(u)+l),b=Math.round(Y(m));Co(i,e,m,Po(b,f.x,p.w,0,180),Po(b,f.y,p.h,90,270))}var h,c,d;t.setCenterPoint(e.l-i.l,i.r-e.r,e.t-i.t,i.b-e.b),t._pointLabelItems=function(t,e,i){const s=[],n=t._pointLabels.length,o=t.options,{centerPointLabels:a,display:r}=o.pointLabels,l={extra:So(o)/2,additionalAngle:a?C/n:0};let h;for(let o=0;o<n;o++){l.padding=i[o],l.size=e[o];const n=Oo(t,o,l);s.push(n),\"auto\"===r&&(n.visible=Ao(n,h),n.visible&&(h=n))}return s}(t,s,o)}function Co(t,e,i,s,n){const o=Math.abs(Math.sin(i)),a=Math.abs(Math.cos(i));let r=0,l=0;s.start<e.l?(r=(e.l-s.start)/o,t.l=Math.min(t.l,e.l-r)):s.end>e.r&&(r=(s.end-e.r)/o,t.r=Math.max(t.r,e.r+r)),n.start<e.t?(l=(e.t-n.start)/a,t.t=Math.min(t.t,e.t-l)):n.end>e.b&&(l=(n.end-e.b)/a,t.b=Math.max(t.b,e.b+l))}function Oo(t,e,i){const s=t.drawingArea,{extra:n,additionalAngle:o,padding:a,size:r}=i,l=t.getPointPosition(e,s+n+a,o),h=Math.round(Y(G(l.angle+E))),c=function(t,e,i){90===i||270===i?t-=e/2:(i>270||i<90)&&(t-=e);return t}(l.y,r.h,h),d=function(t){if(0===t||180===t)return\"center\";if(t<180)return\"left\";return\"right\"}(h),u=function(t,e,i){\"right\"===i?t-=e:\"center\"===i&&(t-=e/2);return t}(l.x,r.w,d);return{visible:!0,x:l.x,y:c,textAlign:d,left:u,top:c,right:u+r.w,bottom:c+r.h}}function Ao(t,e){if(!e)return!0;const{left:i,top:s,right:n,bottom:o}=t;return!(Re({x:i,y:s},e)||Re({x:i,y:o},e)||Re({x:n,y:s},e)||Re({x:n,y:o},e))}function To(t,e,i){const{left:n,top:o,right:a,bottom:r}=i,{backdropColor:l}=e;if(!s(l)){const i=wi(e.borderRadius),s=ki(e.backdropPadding);t.fillStyle=l;const h=n-s.left,c=o-s.top,d=a-n+s.width,u=r-o+s.height;Object.values(i).some((t=>0!==t))?(t.beginPath(),He(t,{x:h,y:c,w:d,h:u,radius:i}),t.fill()):t.fillRect(h,c,d,u)}}function Lo(t,e,i,s){const{ctx:n}=t;if(i)n.arc(t.xCenter,t.yCenter,e,0,O);else{let i=t.getPointPosition(0,e);n.moveTo(i.x,i.y);for(let o=1;o<s;o++)i=t.getPointPosition(o,e),n.lineTo(i.x,i.y)}}class Eo extends bo{static id=\"radialLinear\";static defaults={display:!0,animate:!0,position:\"chartArea\",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:ae.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:t=>t,padding:5,centerPointLabels:!1}};static defaultRoutes={\"angleLines.color\":\"borderColor\",\"pointLabels.color\":\"color\",\"ticks.color\":\"color\"};static descriptors={angleLines:{_fallback:\"grid\"}};constructor(t){super(t),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=ki(So(this.options)/2),e=this.width=this.maxWidth-t.width,i=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=a(t)&&!isNaN(t)?t:0,this.max=a(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/So(this.options))}generateTickLabels(t){bo.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map(((t,e)=>{const i=d(this.options.pointLabels.callback,[t,e],this);return i||0===i?i:\"\"})).filter(((t,e)=>this.chart.getDataVisibility(e)))}fit(){const t=this.options;t.display&&t.pointLabels.display?Do(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,i,s){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}getIndexAngle(t){return G(t*(O/(this._pointLabels.length||1))+$(this.options.startAngle||0))}getDistanceFromCenterForValue(t){if(s(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if(s(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const i=e[t];return function(t,e,i){return Ci(t,{label:i,index:e,type:\"pointLabel\"})}(this.getContext(),t,i)}}getPointPosition(t,e,i=0){const s=this.getIndexAngle(t)-E+i;return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:i,right:s,bottom:n}=this._pointLabelItems[t];return{left:e,top:i,right:s,bottom:n}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const i=this.ctx;i.save(),i.beginPath(),Lo(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:i,grid:s,border:n}=e,o=this._pointLabels.length;let a,r,l;if(e.pointLabels.display&&function(t,e){const{ctx:i,options:{pointLabels:s}}=t;for(let n=e-1;n>=0;n--){const e=t._pointLabelItems[n];if(!e.visible)continue;const o=s.setContext(t.getPointLabelContext(n));To(i,o,e);const a=Si(o.font),{x:r,y:l,textAlign:h}=e;Ne(i,t._pointLabels[n],r,l+a.lineHeight/2,a,{color:o.color,textAlign:h,textBaseline:\"middle\"})}}(this,o),s.display&&this.ticks.forEach(((t,e)=>{if(0!==e){r=this.getDistanceFromCenterForValue(t.value);const i=this.getContext(e),a=s.setContext(i),l=n.setContext(i);!function(t,e,i,s,n){const o=t.ctx,a=e.circular,{color:r,lineWidth:l}=e;!a&&!s||!r||!l||i<0||(o.save(),o.strokeStyle=r,o.lineWidth=l,o.setLineDash(n.dash),o.lineDashOffset=n.dashOffset,o.beginPath(),Lo(t,i,a,s),o.closePath(),o.stroke(),o.restore())}(this,a,r,o,l)}})),i.display){for(t.save(),a=o-1;a>=0;a--){const s=i.setContext(this.getPointLabelContext(a)),{color:n,lineWidth:o}=s;o&&n&&(t.lineWidth=o,t.strokeStyle=n,t.setLineDash(s.borderDash),t.lineDashOffset=s.borderDashOffset,r=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(a,r),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,i=e.ticks;if(!i.display)return;const s=this.getIndexAngle(0);let n,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign=\"center\",t.textBaseline=\"middle\",this.ticks.forEach(((s,a)=>{if(0===a&&!e.reverse)return;const r=i.setContext(this.getContext(a)),l=Si(r.font);if(n=this.getDistanceFromCenterForValue(this.ticks[a].value),r.showLabelBackdrop){t.font=l.string,o=t.measureText(s.label).width,t.fillStyle=r.backdropColor;const e=ki(r.backdropPadding);t.fillRect(-o/2-e.left,-n-l.size/2-e.top,o+e.width,l.size+e.height)}Ne(t,s.label,0,-n,l,{color:r.color,strokeColor:r.textStrokeColor,strokeWidth:r.textStrokeWidth})})),t.restore()}drawTitle(){}}const Ro={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Io=Object.keys(Ro);function zo(t,e){return t-e}function Fo(t,e){if(s(e))return null;const i=t._adapter,{parser:n,round:o,isoWeekday:r}=t._parseOpts;let l=e;return\"function\"==typeof n&&(l=n(l)),a(l)||(l=\"string\"==typeof n?i.parse(l,n):i.parse(l)),null===l?null:(o&&(l=\"week\"!==o||!N(r)&&!0!==r?i.startOf(l,o):i.startOf(l,\"isoWeek\",r)),+l)}function Vo(t,e,i,s){const n=Io.length;for(let o=Io.indexOf(t);o<n-1;++o){const t=Ro[Io[o]],n=t.steps?t.steps:Number.MAX_SAFE_INTEGER;if(t.common&&Math.ceil((i-e)/(n*t.size))<=s)return Io[o]}return Io[n-1]}function Bo(t,e,i){if(i){if(i.length){const{lo:s,hi:n}=et(i,e);t[i[s]>=e?i[s]:i[n]]=!0}}else t[e]=!0}function Wo(t,e,i){const s=[],n={},o=e.length;let a,r;for(a=0;a<o;++a)r=e[a],n[r]=a,s.push({value:r,major:!1});return 0!==o&&i?function(t,e,i,s){const n=t._adapter,o=+n.startOf(e[0].value,s),a=e[e.length-1].value;let r,l;for(r=o;r<=a;r=+n.add(r,1,s))l=i[r],l>=0&&(e[l].major=!0);return e}(t,s,n,i):s}class No extends Js{static id=\"time\";static defaults={bounds:\"data\",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:\"millisecond\",displayFormats:{}},ticks:{source:\"auto\",callback:!1,major:{enabled:!1}}};constructor(t){super(t),this._cache={data:[],labels:[],all:[]},this._unit=\"day\",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e={}){const i=t.time||(t.time={}),s=this._adapter=new Rn._date(t.adapters.date);s.init(e),x(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return void 0===t?null:Fo(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,i=t.time.unit||\"day\";let{min:s,max:n,minDefined:o,maxDefined:r}=this.getUserBounds();function l(t){o||isNaN(t.min)||(s=Math.min(s,t.min)),r||isNaN(t.max)||(n=Math.max(n,t.max))}o&&r||(l(this._getLabelBounds()),\"ticks\"===t.bounds&&\"labels\"===t.ticks.source||l(this.getMinMax(!1))),s=a(s)&&!isNaN(s)?s:+e.startOf(Date.now(),i),n=a(n)&&!isNaN(n)?n:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,n-1),this.max=Math.max(s+1,n)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],i=t[t.length-1]),{min:e,max:i}}buildTicks(){const t=this.options,e=t.time,i=t.ticks,s=\"labels\"===i.source?this.getLabelTimestamps():this._generate();\"ticks\"===t.bounds&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const n=this.min,o=nt(s,n,this.max);return this._unit=e.unit||(i.autoSkip?Vo(e.minUnit,this.min,this.max,this._getLabelCapacity(n)):function(t,e,i,s,n){for(let o=Io.length-1;o>=Io.indexOf(i);o--){const i=Io[o];if(Ro[i].common&&t._adapter.diff(n,s,i)>=e-1)return i}return Io[i?Io.indexOf(i):0]}(this,o.length,e.minUnit,this.min,this.max)),this._majorUnit=i.major.enabled&&\"year\"!==this._unit?function(t){for(let e=Io.indexOf(t)+1,i=Io.length;e<i;++e)if(Ro[Io[e]].common)return Io[e]}(this._unit):void 0,this.initOffsets(s),t.reverse&&o.reverse(),Wo(this,o,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((t=>+t.value)))}initOffsets(t=[]){let e,i,s=0,n=0;this.options.offset&&t.length&&(e=this.getDecimalForValue(t[0]),s=1===t.length?1-e:(this.getDecimalForValue(t[1])-e)/2,i=this.getDecimalForValue(t[t.length-1]),n=1===t.length?i:(i-this.getDecimalForValue(t[t.length-2]))/2);const o=t.length<3?.5:.25;s=J(s,0,o),n=J(n,0,o),this._offsets={start:s,end:n,factor:1/(s+1+n)}}_generate(){const t=this._adapter,e=this.min,i=this.max,s=this.options,n=s.time,o=n.unit||Vo(n.minUnit,e,i,this._getLabelCapacity(e)),a=l(s.ticks.stepSize,1),r=\"week\"===o&&n.isoWeekday,h=N(r)||!0===r,c={};let d,u,f=e;if(h&&(f=+t.startOf(f,\"isoWeek\",r)),f=+t.startOf(f,h?\"day\":o),t.diff(i,e,o)>1e5*a)throw new Error(e+\" and \"+i+\" are too far apart with stepSize of \"+a+\" \"+o);const g=\"data\"===s.ticks.source&&this.getDataTimestamps();for(d=f,u=0;d<i;d=+t.add(d,a,o),u++)Bo(c,d,g);return d!==i&&\"ticks\"!==s.bounds&&1!==u||Bo(c,d,g),Object.keys(c).sort(zo).map((t=>+t))}getLabelForValue(t){const e=this._adapter,i=this.options.time;return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}format(t,e){const i=this.options.time.displayFormats,s=this._unit,n=e||i[s];return this._adapter.format(t,n)}_tickFormatFunction(t,e,i,s){const n=this.options,o=n.ticks.callback;if(o)return d(o,[t,e,i],this);const a=n.time.displayFormats,r=this._unit,l=this._majorUnit,h=r&&a[r],c=l&&a[l],u=i[e],f=l&&c&&u&&u.major;return this._adapter.format(t,s||(f?c:h))}generateTickLabels(t){let e,i,s;for(e=0,i=t.length;e<i;++e)s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}getDecimalForValue(t){return null===t?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,i=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+i)*e.factor)}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+i*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,i=this.ctx.measureText(t).width,s=$(this.isHorizontal()?e.maxRotation:e.minRotation),n=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:i*n+a*o,h:i*o+a*n}}_getLabelCapacity(t){const e=this.options.time,i=e.displayFormats,s=i[e.unit]||i.millisecond,n=this._tickFormatFunction(t,0,Wo(this,[t],this._majorUnit),s),o=this._getLabelSize(n),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t,e,i=this._cache.data||[];if(i.length)return i;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(t=0,e=s.length;t<e;++t)i=i.concat(s[t].controller.getAllParsedValues(this));return this._cache.data=this.normalize(i)}getLabelTimestamps(){const t=this._cache.labels||[];let e,i;if(t.length)return t;const s=this.getLabels();for(e=0,i=s.length;e<i;++e)t.push(Fo(this,s[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return lt(t.sort(zo))}}function Ho(t,e,i){let s,n,o,a,r=0,l=t.length-1;i?(e>=t[r].pos&&e<=t[l].pos&&({lo:r,hi:l}=it(t,\"pos\",e)),({pos:s,time:o}=t[r]),({pos:n,time:a}=t[l])):(e>=t[r].time&&e<=t[l].time&&({lo:r,hi:l}=it(t,\"time\",e)),({time:s,pos:o}=t[r]),({time:n,pos:a}=t[l]));const h=n-s;return h?o+(a-o)*(e-s)/h:o}var jo=Object.freeze({__proto__:null,CategoryScale:class extends Js{static id=\"category\";static defaults={ticks:{callback:po}};constructor(t){super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const t=this.getLabels();for(const{index:i,label:s}of e)t[i]===s&&t.splice(i,1);this._addedLabels=[]}super.init(t)}parse(t,e){if(s(t))return null;const i=this.getLabels();return((t,e)=>null===t?null:J(Math.round(t),0,e))(e=isFinite(e)&&i[e]===t?e:go(i,t,l(e,t),this._addedLabels),i.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:i,max:s}=this.getMinMax(!0);\"ticks\"===this.options.bounds&&(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}buildTicks(){const t=this.min,e=this.max,i=this.options.offset,s=[];let n=this.getLabels();n=0===t&&e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);for(let i=t;i<=e;i++)s.push({value:i});return s}getLabelForValue(t){return po.call(this,t)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return\"number\"!=typeof t&&(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}},LinearScale:xo,LogarithmicScale:ko,RadialLinearScale:Eo,TimeScale:No,TimeSeriesScale:class extends No{static id=\"timeseries\";static defaults=No.defaults;constructor(t){super(t),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=Ho(e,this.min),this._tableRange=Ho(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:i}=this,s=[],n=[];let o,a,r,l,h;for(o=0,a=t.length;o<a;++o)l=t[o],l>=e&&l<=i&&s.push(l);if(s.length<2)return[{time:e,pos:0},{time:i,pos:1}];for(o=0,a=s.length;o<a;++o)h=s[o+1],r=s[o-1],l=s[o],Math.round((h+r)/2)!==l&&n.push({time:l,pos:o/(a-1)});return n}_generate(){const t=this.min,e=this.max;let i=super.getDataTimestamps();return i.includes(t)&&i.length||i.splice(0,0,t),i.includes(e)&&1!==i.length||i.push(e),i.sort(((t,e)=>t-e))}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),i=this.getLabelTimestamps();return t=e.length&&i.length?this.normalize(e.concat(i)):e.length?e:i,t=this._cache.all=t,t}getDecimalForValue(t){return(Ho(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return Ho(this._table,i*this._tableRange+this._minPos,!0)}}});const $o=[\"rgb(54, 162, 235)\",\"rgb(255, 99, 132)\",\"rgb(255, 159, 64)\",\"rgb(255, 205, 86)\",\"rgb(75, 192, 192)\",\"rgb(153, 102, 255)\",\"rgb(201, 203, 207)\"],Yo=$o.map((t=>t.replace(\"rgb(\",\"rgba(\").replace(\")\",\", 0.5)\")));function Uo(t){return $o[t%$o.length]}function Xo(t){return Yo[t%Yo.length]}function qo(t){let e=0;return(i,s)=>{const n=t.getDatasetMeta(s).controller;n instanceof jn?e=function(t,e){return t.backgroundColor=t.data.map((()=>Uo(e++))),e}(i,e):n instanceof $n?e=function(t,e){return t.backgroundColor=t.data.map((()=>Xo(e++))),e}(i,e):n&&(e=function(t,e){return t.borderColor=Uo(e),t.backgroundColor=Xo(e),++e}(i,e))}}function Ko(t){let e;for(e in t)if(t[e].borderColor||t[e].backgroundColor)return!0;return!1}var Go={id:\"colors\",defaults:{enabled:!0,forceOverride:!1},beforeLayout(t,e,i){if(!i.enabled)return;const{data:{datasets:s},options:n}=t.config,{elements:o}=n;if(!i.forceOverride&&(Ko(s)||(a=n)&&(a.borderColor||a.backgroundColor)||o&&Ko(o)))return;var a;const r=qo(t);s.forEach(r)}};function Zo(t){if(t._decimated){const e=t._data;delete t._decimated,delete t._data,Object.defineProperty(t,\"data\",{configurable:!0,enumerable:!0,writable:!0,value:e})}}function Jo(t){t.data.datasets.forEach((t=>{Zo(t)}))}var Qo={id:\"decimation\",defaults:{algorithm:\"min-max\",enabled:!1},beforeElementsUpdate:(t,e,i)=>{if(!i.enabled)return void Jo(t);const n=t.width;t.data.datasets.forEach(((e,o)=>{const{_data:a,indexAxis:r}=e,l=t.getDatasetMeta(o),h=a||e.data;if(\"y\"===Pi([r,t.options.indexAxis]))return;if(!l.controller.supportsDecimation)return;const c=t.scales[l.xAxisID];if(\"linear\"!==c.type&&\"time\"!==c.type)return;if(t.options.parsing)return;let{start:d,count:u}=function(t,e){const i=e.length;let s,n=0;const{iScale:o}=t,{min:a,max:r,minDefined:l,maxDefined:h}=o.getUserBounds();return l&&(n=J(it(e,o.axis,a).lo,0,i-1)),s=h?J(it(e,o.axis,r).hi+1,n,i)-n:i-n,{start:n,count:s}}(l,h);if(u<=(i.threshold||4*n))return void Zo(e);let f;switch(s(a)&&(e._data=h,delete e.data,Object.defineProperty(e,\"data\",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(t){this._data=t}})),i.algorithm){case\"lttb\":f=function(t,e,i,s,n){const o=n.samples||s;if(o>=i)return t.slice(e,e+i);const a=[],r=(i-2)/(o-2);let l=0;const h=e+i-1;let c,d,u,f,g,p=e;for(a[l++]=t[p],c=0;c<o-2;c++){let s,n=0,o=0;const h=Math.floor((c+1)*r)+1+e,m=Math.min(Math.floor((c+2)*r)+1,i)+e,b=m-h;for(s=h;s<m;s++)n+=t[s].x,o+=t[s].y;n/=b,o/=b;const x=Math.floor(c*r)+1+e,_=Math.min(Math.floor((c+1)*r)+1,i)+e,{x:y,y:v}=t[p];for(u=f=-1,s=x;s<_;s++)f=.5*Math.abs((y-n)*(t[s].y-v)-(y-t[s].x)*(o-v)),f>u&&(u=f,d=t[s],g=s);a[l++]=d,p=g}return a[l++]=t[h],a}(h,d,u,n,i);break;case\"min-max\":f=function(t,e,i,n){let o,a,r,l,h,c,d,u,f,g,p=0,m=0;const b=[],x=e+i-1,_=t[e].x,y=t[x].x-_;for(o=e;o<e+i;++o){a=t[o],r=(a.x-_)/y*n,l=a.y;const e=0|r;if(e===h)l<f?(f=l,c=o):l>g&&(g=l,d=o),p=(m*p+a.x)/++m;else{const i=o-1;if(!s(c)&&!s(d)){const e=Math.min(c,d),s=Math.max(c,d);e!==u&&e!==i&&b.push({...t[e],x:p}),s!==u&&s!==i&&b.push({...t[s],x:p})}o>0&&i!==u&&b.push(t[i]),b.push(a),h=e,m=0,f=g=l,c=d=u=o}}return b}(h,d,u,n);break;default:throw new Error(`Unsupported decimation algorithm '${i.algorithm}'`)}e._decimated=f}))},destroy(t){Jo(t)}};function ta(t,e,i,s){if(s)return;let n=e[t],o=i[t];return\"angle\"===t&&(n=G(n),o=G(o)),{property:t,start:n,end:o}}function ea(t,e,i){for(;e>t;e--){const t=i[e];if(!isNaN(t.x)&&!isNaN(t.y))break}return e}function ia(t,e,i,s){return t&&e?s(t[i],e[i]):t?t[i]:e?e[i]:0}function sa(t,e){let i=[],s=!1;return n(t)?(s=!0,i=t):i=function(t,e){const{x:i=null,y:s=null}=t||{},n=e.points,o=[];return e.segments.forEach((({start:t,end:e})=>{e=ea(t,e,n);const a=n[t],r=n[e];null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&&(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))})),o}(t,e),i.length?new no({points:i,options:{tension:0},_loop:s,_fullLoop:s}):null}function na(t){return t&&!1!==t.fill}function oa(t,e,i){let s=t[e].fill;const n=[e];let o;if(!i)return s;for(;!1!==s&&-1===n.indexOf(s);){if(!a(s))return s;if(o=t[s],!o)return!1;if(o.visible)return s;n.push(s),s=o.fill}return!1}function aa(t,e,i){const s=function(t){const e=t.options,i=e.fill;let s=l(i&&i.target,i);void 0===s&&(s=!!e.backgroundColor);if(!1===s||null===s)return!1;if(!0===s)return\"origin\";return s}(t);if(o(s))return!isNaN(s.value)&&s;let n=parseFloat(s);return a(n)&&Math.floor(n)===n?function(t,e,i,s){\"-\"!==t&&\"+\"!==t||(i=e+i);if(i===e||i<0||i>=s)return!1;return i}(s[0],e,n,i):[\"origin\",\"start\",\"end\",\"stack\",\"shape\"].indexOf(s)>=0&&s}function ra(t,e,i){const s=[];for(let n=0;n<i.length;n++){const o=i[n],{first:a,last:r,point:l}=la(o,e,\"x\");if(!(!l||a&&r))if(a)s.unshift(l);else if(t.push(l),!r)break}t.push(...s)}function la(t,e,i){const s=t.interpolate(e,i);if(!s)return{};const n=s[i],o=t.segments,a=t.points;let r=!1,l=!1;for(let t=0;t<o.length;t++){const e=o[t],s=a[e.start][i],h=a[e.end][i];if(tt(n,s,h)){r=n===s,l=n===h;break}}return{first:r,last:l,point:s}}class ha{constructor(t){this.x=t.x,this.y=t.y,this.radius=t.radius}pathSegment(t,e,i){const{x:s,y:n,radius:o}=this;return e=e||{start:0,end:O},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}interpolate(t){const{x:e,y:i,radius:s}=this,n=t.angle;return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}}function ca(t){const{chart:e,fill:i,line:s}=t;if(a(i))return function(t,e){const i=t.getDatasetMeta(e),s=i&&t.isDatasetVisible(e);return s?i.dataset:null}(e,i);if(\"stack\"===i)return function(t){const{scale:e,index:i,line:s}=t,n=[],o=s.segments,a=s.points,r=function(t,e){const i=[],s=t.getMatchingVisibleMetas(\"line\");for(let t=0;t<s.length;t++){const n=s[t];if(n.index===e)break;n.hidden||i.unshift(n.dataset)}return i}(e,i);r.push(sa({x:null,y:e.bottom},s));for(let t=0;t<o.length;t++){const e=o[t];for(let t=e.start;t<=e.end;t++)ra(n,a[t],r)}return new no({points:n,options:{}})}(t);if(\"shape\"===i)return!0;const n=function(t){const e=t.scale||{};if(e.getPointPositionForValue)return function(t){const{scale:e,fill:i}=t,s=e.options,n=e.getLabels().length,a=s.reverse?e.max:e.min,r=function(t,e,i){let s;return s=\"start\"===t?i:\"end\"===t?e.options.reverse?e.min:e.max:o(t)?t.value:e.getBaseValue(),s}(i,e,a),l=[];if(s.grid.circular){const t=e.getPointPositionForValue(0,a);return new ha({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}for(let t=0;t<n;++t)l.push(e.getPointPositionForValue(t,r));return l}(t);return function(t){const{scale:e={},fill:i}=t,s=function(t,e){let i=null;return\"start\"===t?i=e.bottom:\"end\"===t?i=e.top:o(t)?i=e.getPixelForValue(t.value):e.getBasePixel&&(i=e.getBasePixel()),i}(i,e);if(a(s)){const t=e.isHorizontal();return{x:t?s:null,y:t?null:s}}return null}(t)}(t);return n instanceof ha?n:sa(n,s)}function da(t,e,i){const s=ca(e),{line:n,scale:o,axis:a}=e,r=n.options,l=r.fill,h=r.backgroundColor,{above:c=h,below:d=h}=l||{};s&&n.points.length&&(Ie(t,i),function(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r}=e,l=i._loop?\"angle\":e.axis;t.save(),\"x\"===l&&o!==n&&(ua(t,s,a.top),fa(t,{line:i,target:s,color:n,scale:r,property:l}),t.restore(),t.save(),ua(t,s,a.bottom));fa(t,{line:i,target:s,color:o,scale:r,property:l}),t.restore()}(t,{line:n,target:s,above:c,below:d,area:i,scale:o,axis:a}),ze(t))}function ua(t,e,i){const{segments:s,points:n}=e;let o=!0,a=!1;t.beginPath();for(const r of s){const{start:s,end:l}=r,h=n[s],c=n[ea(s,l,n)];o?(t.moveTo(h.x,h.y),o=!1):(t.lineTo(h.x,i),t.lineTo(h.x,h.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}t.lineTo(e.first().x,i),t.closePath(),t.clip()}function fa(t,e){const{line:i,target:s,property:n,color:o,scale:a}=e,r=function(t,e,i){const s=t.segments,n=t.points,o=e.points,a=[];for(const t of s){let{start:s,end:r}=t;r=ea(s,r,n);const l=ta(i,n[s],n[r],t.loop);if(!e.segments){a.push({source:t,target:l,start:n[s],end:n[r]});continue}const h=Ii(e,l);for(const e of h){const s=ta(i,o[e.start],o[e.end],e.loop),r=Ri(t,n,s);for(const t of r)a.push({source:t,target:e,start:{[i]:ia(l,s,\"start\",Math.max)},end:{[i]:ia(l,s,\"end\",Math.min)}})}}return a}(i,s,n);for(const{source:e,target:l,start:h,end:c}of r){const{style:{backgroundColor:r=o}={}}=e,d=!0!==s;t.save(),t.fillStyle=r,ga(t,a,d&&ta(n,h,c)),t.beginPath();const u=!!i.pathSegment(t,e);let f;if(d){u?t.closePath():pa(t,s,c,n);const e=!!s.pathSegment(t,l,{move:u,reverse:!0});f=u&&e,f||pa(t,s,h,n)}t.closePath(),t.fill(f?\"evenodd\":\"nonzero\"),t.restore()}}function ga(t,e,i){const{top:s,bottom:n}=e.chart.chartArea,{property:o,start:a,end:r}=i||{};\"x\"===o&&(t.beginPath(),t.rect(a,s,r-a,n-s),t.clip())}function pa(t,e,i,s){const n=e.interpolate(i,s);n&&t.lineTo(n.x,n.y)}var ma={id:\"filler\",afterDatasetsUpdate(t,e,i){const s=(t.data.datasets||[]).length,n=[];let o,a,r,l;for(a=0;a<s;++a)o=t.getDatasetMeta(a),r=o.dataset,l=null,r&&r.options&&r instanceof no&&(l={visible:t.isDatasetVisible(a),index:a,fill:aa(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=l,n.push(l);for(a=0;a<s;++a)l=n[a],l&&!1!==l.fill&&(l.fill=oa(n,a,i.propagate))},beforeDraw(t,e,i){const s=\"beforeDraw\"===i.drawTime,n=t.getSortedVisibleDatasetMetas(),o=t.chartArea;for(let e=n.length-1;e>=0;--e){const i=n[e].$filler;i&&(i.line.updateControlPoints(o,i.axis),s&&i.fill&&da(t.ctx,i,o))}},beforeDatasetsDraw(t,e,i){if(\"beforeDatasetsDraw\"!==i.drawTime)return;const s=t.getSortedVisibleDatasetMetas();for(let e=s.length-1;e>=0;--e){const i=s[e].$filler;na(i)&&da(t.ctx,i,t.chartArea)}},beforeDatasetDraw(t,e,i){const s=e.meta.$filler;na(s)&&\"beforeDatasetDraw\"===i.drawTime&&da(t.ctx,s,t.chartArea)},defaults:{propagate:!0,drawTime:\"beforeDatasetDraw\"}};const ba=(t,e)=>{let{boxHeight:i=e,boxWidth:s=e}=t;return t.usePointStyle&&(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}};class xa extends Hs{constructor(t){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,i){this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=d(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter((e=>t.filter(e,this.chart.data)))),t.sort&&(e=e.sort(((e,i)=>t.sort(e,i,this.chart.data)))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display)return void(this.width=this.height=0);const i=t.labels,s=Si(i.font),n=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:r}=ba(i,n);let l,h;e.font=s.string,this.isHorizontal()?(l=this.maxWidth,h=this._fitRows(o,n,a,r)+10):(h=this.maxHeight,l=this._fitCols(o,s,a,r)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.lineWidths=[0],h=s+a;let c=t;n.textAlign=\"left\",n.textBaseline=\"middle\";let d=-1,u=-h;return this.legendItems.forEach(((t,f)=>{const g=i+e/2+n.measureText(t.text).width;(0===f||l[l.length-1]+g+2*a>o)&&(c+=h,l[l.length-(f>0?0:1)]=0,u+=h,d++),r[f]={left:0,top:u,row:d,width:g,height:s},l[l.length-1]+=g+a})),c}_fitCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=this,r=this.legendHitBoxes=[],l=this.columnSizes=[],h=o-t;let c=a,d=0,u=0,f=0,g=0;return this.legendItems.forEach(((t,o)=>{const{itemWidth:p,itemHeight:m}=function(t,e,i,s,n){const o=function(t,e,i,s){let n=t.text;n&&\"string\"!=typeof n&&(n=n.reduce(((t,e)=>t.length>e.length?t:e)));return e+i.size/2+s.measureText(n).width}(s,t,e,i),a=function(t,e,i){let s=t;\"string\"!=typeof e.text&&(s=_a(e,i));return s}(n,s,e.lineHeight);return{itemWidth:o,itemHeight:a}}(i,e,n,t,s);o>0&&u+m+2*a>h&&(c+=d+a,l.push({width:d,height:u}),f+=d+a,g++,d=u=0),r[o]={left:f,top:u,col:g,width:p,height:m},d=Math.max(d,p),u+=m+a})),c+=d,l.push({width:d,height:u}),c}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=this,o=Oi(n,this.left,this.width);if(this.isHorizontal()){let n=0,a=ft(i,this.left+s,this.right-this.lineWidths[n]);for(const r of e)n!==r.row&&(n=r.row,a=ft(i,this.left+s,this.right-this.lineWidths[n])),r.top+=this.top+t+s,r.left=o.leftForLtr(o.x(a),r.width),a+=r.width+s}else{let n=0,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height);for(const r of e)r.col!==n&&(n=r.col,a=ft(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),r.top=a,r.left+=this.left+s,r.left=o.leftForLtr(o.x(r.left),r.width),a+=r.height+s}}isHorizontal(){return\"top\"===this.options.position||\"bottom\"===this.options.position}draw(){if(this.options.display){const t=this.ctx;Ie(t,this),this._draw(),ze(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=this,{align:n,labels:o}=t,a=ue.color,r=Oi(t.rtl,this.left,this.width),h=Si(o.font),{padding:c}=o,d=h.size,u=d/2;let f;this.drawTitle(),s.textAlign=r.textAlign(\"left\"),s.textBaseline=\"middle\",s.lineWidth=.5,s.font=h.string;const{boxWidth:g,boxHeight:p,itemHeight:m}=ba(o,d),b=this.isHorizontal(),x=this._computeTitleHeight();f=b?{x:ft(n,this.left+c,this.right-i[0]),y:this.top+c+x,line:0}:{x:this.left+c,y:ft(n,this.top+x+c,this.bottom-e[0].height),line:0},Ai(this.ctx,t.textDirection);const _=m+c;this.legendItems.forEach(((y,v)=>{s.strokeStyle=y.fontColor,s.fillStyle=y.fontColor;const M=s.measureText(y.text).width,w=r.textAlign(y.textAlign||(y.textAlign=o.textAlign)),k=g+u+M;let S=f.x,P=f.y;r.setWidth(this.width),b?v>0&&S+k+c>this.right&&(P=f.y+=_,f.line++,S=f.x=ft(n,this.left+c,this.right-i[f.line])):v>0&&P+_>this.bottom&&(S=f.x=S+e[f.line].width+c,f.line++,P=f.y=ft(n,this.top+x+c,this.bottom-e[f.line].height));if(function(t,e,i){if(isNaN(g)||g<=0||isNaN(p)||p<0)return;s.save();const n=l(i.lineWidth,1);if(s.fillStyle=l(i.fillStyle,a),s.lineCap=l(i.lineCap,\"butt\"),s.lineDashOffset=l(i.lineDashOffset,0),s.lineJoin=l(i.lineJoin,\"miter\"),s.lineWidth=n,s.strokeStyle=l(i.strokeStyle,a),s.setLineDash(l(i.lineDash,[])),o.usePointStyle){const a={radius:p*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},l=r.xPlus(t,g/2);Ee(s,a,l,e+u,o.pointStyleWidth&&g)}else{const o=e+Math.max((d-p)/2,0),a=r.leftForLtr(t,g),l=wi(i.borderRadius);s.beginPath(),Object.values(l).some((t=>0!==t))?He(s,{x:a,y:o,w:g,h:p,radius:l}):s.rect(a,o,g,p),s.fill(),0!==n&&s.stroke()}s.restore()}(r.x(S),P,y),S=gt(w,S+g+u,b?S+k:this.right,t.rtl),function(t,e,i){Ne(s,i.text,t,e+m/2,h,{strikethrough:i.hidden,textAlign:r.textAlign(i.textAlign)})}(r.x(S),P,y),b)f.x+=k+c;else if(\"string\"!=typeof y.text){const t=h.lineHeight;f.y+=_a(y,t)+c}else f.y+=_})),Ti(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,i=Si(e.font),s=ki(e.padding);if(!e.display)return;const n=Oi(t.rtl,this.left,this.width),o=this.ctx,a=e.position,r=i.size/2,l=s.top+r;let h,c=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),h=this.top+l,c=ft(t.align,c,this.right-d);else{const e=this.columnSizes.reduce(((t,e)=>Math.max(t,e.height)),0);h=l+ft(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}const u=ft(a,c,c+d);o.textAlign=n.textAlign(ut(a)),o.textBaseline=\"middle\",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ne(o,e.text,u,h,i)}_computeTitleHeight(){const t=this.options.title,e=Si(t.font),i=ki(t.padding);return t.display?e.lineHeight+i.height:0}_getLegendItemAt(t,e){let i,s,n;if(tt(t,this.left,this.right)&&tt(e,this.top,this.bottom))for(n=this.legendHitBoxes,i=0;i<n.length;++i)if(s=n[i],tt(t,s.left,s.left+s.width)&&tt(e,s.top,s.top+s.height))return this.legendItems[i];return null}handleEvent(t){const e=this.options;if(!function(t,e){if((\"mousemove\"===t||\"mouseout\"===t)&&(e.onHover||e.onLeave))return!0;if(e.onClick&&(\"click\"===t||\"mouseup\"===t))return!0;return!1}(t.type,e))return;const i=this._getLegendItemAt(t.x,t.y);if(\"mousemove\"===t.type||\"mouseout\"===t.type){const o=this._hoveredItem,a=(n=i,null!==(s=o)&&null!==n&&s.datasetIndex===n.datasetIndex&&s.index===n.index);o&&!a&&d(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&&!a&&d(e.onHover,[t,i,this],this)}else i&&d(e.onClick,[t,i,this],this);var s,n}}function _a(t,e){return e*(t.text?t.text.length:0)}var ya={id:\"legend\",_element:xa,start(t,e,i){const s=t.legend=new xa({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s)},stop(t){as.removeBox(t,t.legend),delete t.legend},beforeUpdate(t,e,i){const s=t.legend;as.configure(t,s,i),s.options=i},afterUpdate(t){const e=t.legend;e.buildLabels(),e.adjustHitBoxes()},afterEvent(t,e){e.replay||t.legend.handleEvent(e.event)},defaults:{display:!0,position:\"top\",align:\"center\",fullSize:!0,reverse:!1,weight:1e3,onClick(t,e,i){const s=e.datasetIndex,n=i.chart;n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)},onHover:null,onLeave:null,labels:{color:t=>t.chart.options.color,boxWidth:40,padding:10,generateLabels(t){const e=t.data.datasets,{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o,useBorderRadius:a,borderRadius:r}}=t.legend.options;return t._getSortedDatasetMetas().map((t=>{const l=t.controller.getStyle(i?0:void 0),h=ki(l.borderWidth);return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(h.width+h.height)/4,strokeStyle:l.borderColor,pointStyle:s||l.pointStyle,rotation:l.rotation,textAlign:n||l.textAlign,borderRadius:a&&(r||l.borderRadius),datasetIndex:t.index}}),this)}},title:{color:t=>t.chart.options.color,display:!1,position:\"center\",text:\"\"}},descriptors:{_scriptable:t=>!t.startsWith(\"on\"),labels:{_scriptable:t=>![\"generateLabels\",\"filter\",\"sort\"].includes(t)}}};class va extends Hs{constructor(t){super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const i=this.options;if(this.left=0,this.top=0,!i.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=t,this.height=this.bottom=e;const s=n(i.text)?i.text.length:1;this._padding=ki(i.padding);const o=s*Si(i.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=o:this.width=o}isHorizontal(){const t=this.options.position;return\"top\"===t||\"bottom\"===t}_drawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=this,a=o.align;let r,l,h,c=0;return this.isHorizontal()?(l=ft(a,i,n),h=e+t,r=n-i):(\"left\"===o.position?(l=i+t,h=ft(a,s,e),c=-.5*C):(l=n-t,h=ft(a,e,s),c=.5*C),r=s-e),{titleX:l,titleY:h,maxWidth:r,rotation:c}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const i=Si(e.font),s=i.lineHeight/2+this._padding.top,{titleX:n,titleY:o,maxWidth:a,rotation:r}=this._drawArgs(s);Ne(t,e.text,0,0,i,{color:e.color,maxWidth:a,rotation:r,textAlign:ut(e.align),textBaseline:\"middle\",translation:[n,o]})}}var Ma={id:\"title\",_element:va,start(t,e,i){!function(t,e){const i=new va({ctx:t.ctx,options:e,chart:t});as.configure(t,i,e),as.addBox(t,i),t.titleBlock=i}(t,i)},stop(t){const e=t.titleBlock;as.removeBox(t,e),delete t.titleBlock},beforeUpdate(t,e,i){const s=t.titleBlock;as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"bold\"},fullSize:!0,padding:10,position:\"top\",text:\"\",weight:2e3},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const wa=new WeakMap;var ka={id:\"subtitle\",start(t,e,i){const s=new va({ctx:t.ctx,options:i,chart:t});as.configure(t,s,i),as.addBox(t,s),wa.set(t,s)},stop(t){as.removeBox(t,wa.get(t)),wa.delete(t)},beforeUpdate(t,e,i){const s=wa.get(t);as.configure(t,s,i),s.options=i},defaults:{align:\"center\",display:!1,font:{weight:\"normal\"},fullSize:!0,padding:0,position:\"top\",text:\"\",weight:1500},defaultRoutes:{color:\"color\"},descriptors:{_scriptable:!0,_indexable:!1}};const Sa={average(t){if(!t.length)return!1;let e,i,s=0,n=0,o=0;for(e=0,i=t.length;e<i;++e){const i=t[e].element;if(i&&i.hasValue()){const t=i.tooltipPosition();s+=t.x,n+=t.y,++o}}return{x:s/o,y:n/o}},nearest(t,e){if(!t.length)return!1;let i,s,n,o=e.x,a=e.y,r=Number.POSITIVE_INFINITY;for(i=0,s=t.length;i<s;++i){const s=t[i].element;if(s&&s.hasValue()){const t=q(e,s.getCenterPoint());t<r&&(r=t,n=s)}}if(n){const t=n.tooltipPosition();o=t.x,a=t.y}return{x:o,y:a}}};function Pa(t,e){return e&&(n(e)?Array.prototype.push.apply(t,e):t.push(e)),t}function Da(t){return(\"string\"==typeof t||t instanceof String)&&t.indexOf(\"\\n\")>-1?t.split(\"\\n\"):t}function Ca(t,e){const{element:i,datasetIndex:s,index:n}=e,o=t.getDatasetMeta(s).controller,{label:a,value:r}=o.getLabelAndValue(n);return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}function Oa(t,e){const i=t.chart.ctx,{body:s,footer:n,title:o}=t,{boxWidth:a,boxHeight:r}=e,l=Si(e.bodyFont),h=Si(e.titleFont),c=Si(e.footerFont),d=o.length,f=n.length,g=s.length,p=ki(e.padding);let m=p.height,b=0,x=s.reduce(((t,e)=>t+e.before.length+e.lines.length+e.after.length),0);if(x+=t.beforeBody.length+t.afterBody.length,d&&(m+=d*h.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),x){m+=g*(e.displayColors?Math.max(r,l.lineHeight):l.lineHeight)+(x-g)*l.lineHeight+(x-1)*e.bodySpacing}f&&(m+=e.footerMarginTop+f*c.lineHeight+(f-1)*e.footerSpacing);let _=0;const y=function(t){b=Math.max(b,i.measureText(t).width+_)};return i.save(),i.font=h.string,u(t.title,y),i.font=l.string,u(t.beforeBody.concat(t.afterBody),y),_=e.displayColors?a+2+e.boxPadding:0,u(s,(t=>{u(t.before,y),u(t.lines,y),u(t.after,y)})),_=0,i.font=c.string,u(t.footer,y),i.restore(),b+=p.width,{width:b,height:m}}function Aa(t,e,i,s){const{x:n,width:o}=i,{width:a,chartArea:{left:r,right:l}}=t;let h=\"center\";return\"center\"===s?h=n<=(r+l)/2?\"left\":\"right\":n<=o/2?h=\"left\":n>=a-o/2&&(h=\"right\"),function(t,e,i,s){const{x:n,width:o}=s,a=i.caretSize+i.caretPadding;return\"left\"===t&&n+o+a>e.width||\"right\"===t&&n-o-a<0||void 0}(h,t,e,i)&&(h=\"center\"),h}function Ta(t,e,i){const s=i.yAlign||e.yAlign||function(t,e){const{y:i,height:s}=e;return i<s/2?\"top\":i>t.height-s/2?\"bottom\":\"center\"}(t,i);return{xAlign:i.xAlign||e.xAlign||Aa(t,e,i,s),yAlign:s}}function La(t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:a}=t,{xAlign:r,yAlign:l}=i,h=n+o,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(a);let g=function(t,e){let{x:i,width:s}=t;return\"right\"===e?i-=s:\"center\"===e&&(i-=s/2),i}(e,r);const p=function(t,e,i){let{y:s,height:n}=t;return\"top\"===e?s+=i:s-=\"bottom\"===e?n+i:n/2,s}(e,l,h);return\"center\"===l?\"left\"===r?g+=h:\"right\"===r&&(g-=h):\"left\"===r?g-=Math.max(c,u)+n:\"right\"===r&&(g+=Math.max(d,f)+n),{x:J(g,0,s.width-e.width),y:J(p,0,s.height-e.height)}}function Ea(t,e,i){const s=ki(i.padding);return\"center\"===e?t.x+t.width/2:\"right\"===e?t.x+t.width-s.right:t.x+s.left}function Ra(t){return Pa([],Da(t))}function Ia(t,e){const i=e&&e.dataset&&e.dataset.tooltip&&e.dataset.tooltip.callbacks;return i?t.override(i):t}const za={beforeTitle:e,title(t){if(t.length>0){const e=t[0],i=e.chart.data.labels,s=i?i.length:0;if(this&&this.options&&\"dataset\"===this.options.mode)return e.dataset.label||\"\";if(e.label)return e.label;if(s>0&&e.dataIndex<s)return i[e.dataIndex]}return\"\"},afterTitle:e,beforeBody:e,beforeLabel:e,label(t){if(this&&this.options&&\"dataset\"===this.options.mode)return t.label+\": \"+t.formattedValue||t.formattedValue;let e=t.dataset.label||\"\";e&&(e+=\": \");const i=t.formattedValue;return s(i)||(e+=i),e},labelColor(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(t){const e=t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:e,afterBody:e,beforeFooter:e,footer:e,afterFooter:e};function Fa(t,e,i,s){const n=t[e].call(i,s);return void 0===n?za[e].call(i,s):n}class Va extends Hs{static positioners=Sa;constructor(t){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,i=this.options.setContext(this.getContext()),s=i.enabled&&e.options.animation&&i.animations,n=new Os(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(n)),n}getContext(){return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,Ci(t,{tooltip:e,tooltipItems:i,type:\"tooltip\"})));var t,e,i}getTitle(t,e){const{callbacks:i}=e,s=Fa(i,\"beforeTitle\",this,t),n=Fa(i,\"title\",this,t),o=Fa(i,\"afterTitle\",this,t);let a=[];return a=Pa(a,Da(s)),a=Pa(a,Da(n)),a=Pa(a,Da(o)),a}getBeforeBody(t,e){return Ra(Fa(e.callbacks,\"beforeBody\",this,t))}getBody(t,e){const{callbacks:i}=e,s=[];return u(t,(t=>{const e={before:[],lines:[],after:[]},n=Ia(i,t);Pa(e.before,Da(Fa(n,\"beforeLabel\",this,t))),Pa(e.lines,Fa(n,\"label\",this,t)),Pa(e.after,Da(Fa(n,\"afterLabel\",this,t))),s.push(e)})),s}getAfterBody(t,e){return Ra(Fa(e.callbacks,\"afterBody\",this,t))}getFooter(t,e){const{callbacks:i}=e,s=Fa(i,\"beforeFooter\",this,t),n=Fa(i,\"footer\",this,t),o=Fa(i,\"afterFooter\",this,t);let a=[];return a=Pa(a,Da(s)),a=Pa(a,Da(n)),a=Pa(a,Da(o)),a}_createItems(t){const e=this._active,i=this.chart.data,s=[],n=[],o=[];let a,r,l=[];for(a=0,r=e.length;a<r;++a)l.push(Ca(this.chart,e[a]));return t.filter&&(l=l.filter(((e,s,n)=>t.filter(e,s,n,i)))),t.itemSort&&(l=l.sort(((e,s)=>t.itemSort(e,s,i)))),u(l,(e=>{const i=Ia(t.callbacks,e);s.push(Fa(i,\"labelColor\",this,e)),n.push(Fa(i,\"labelPointStyle\",this,e)),o.push(Fa(i,\"labelTextColor\",this,e))})),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=l,l}update(t,e){const i=this.options.setContext(this.getContext()),s=this._active;let n,o=[];if(s.length){const t=Sa[i.position].call(this,s,this._eventPosition);o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);const e=this._size=Oa(this,i),a=Object.assign({},t,e),r=Ta(this.chart,i,a),l=La(i,a,r,this.chart);this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:l.x,y:l.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}else 0!==this.opacity&&(n={opacity:0});this._tooltipItems=o,this.$context=void 0,n&&this._resolveAnimations().update(this,n),t&&i.external&&i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,i,s){const n=this.getCaretPosition(t,i,s);e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}getCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=this,{caretSize:o,cornerRadius:a}=i,{topLeft:r,topRight:l,bottomLeft:h,bottomRight:c}=wi(a),{x:d,y:u}=t,{width:f,height:g}=e;let p,m,b,x,_,y;return\"center\"===n?(_=u+g/2,\"left\"===s?(p=d,m=p-o,x=_+o,y=_-o):(p=d+f,m=p+o,x=_-o,y=_+o),b=p):(m=\"left\"===s?d+Math.max(r,h)+o:\"right\"===s?d+f-Math.max(l,c)-o:this.caretX,\"top\"===n?(x=u,_=x-o,p=m-o,b=m+o):(x=u+g,_=x+o,p=m+o,b=m-o),y=x),{x1:p,x2:m,x3:b,y1:x,y2:_,y3:y}}drawTitle(t,e,i){const s=this.title,n=s.length;let o,a,r;if(n){const l=Oi(i.rtl,this.x,this.width);for(t.x=Ea(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline=\"middle\",o=Si(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,r=0;r<n;++r)e.fillText(s[r],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,r+1===n&&(t.y+=i.titleMarginBottom-a)}}_drawColorBox(t,e,i,s,n){const a=this.labelColors[i],r=this.labelPointStyles[i],{boxHeight:l,boxWidth:h}=n,c=Si(n.bodyFont),d=Ea(this,\"left\",n),u=s.x(d),f=l<c.lineHeight?(c.lineHeight-l)/2:0,g=e.y+f;if(n.usePointStyle){const e={radius:Math.min(h,l)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},i=s.leftForLtr(u,h)+h/2,o=g+l/2;t.strokeStyle=n.multiKeyBackground,t.fillStyle=n.multiKeyBackground,Le(t,e,i,o),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,Le(t,e,i,o)}else{t.lineWidth=o(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;const e=s.leftForLtr(u,h),i=s.leftForLtr(s.xPlus(u,1),h-2),r=wi(a.borderRadius);Object.values(r).some((t=>0!==t))?(t.beginPath(),t.fillStyle=n.multiKeyBackground,He(t,{x:e,y:g,w:h,h:l,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),He(t,{x:i,y:g+1,w:h-2,h:l-2,radius:r}),t.fill()):(t.fillStyle=n.multiKeyBackground,t.fillRect(e,g,h,l),t.strokeRect(e,g,h,l),t.fillStyle=a.backgroundColor,t.fillRect(i,g+1,h-2,l-2))}t.fillStyle=this.labelTextColors[i]}drawBody(t,e,i){const{body:s}=this,{bodySpacing:n,bodyAlign:o,displayColors:a,boxHeight:r,boxWidth:l,boxPadding:h}=i,c=Si(i.bodyFont);let d=c.lineHeight,f=0;const g=Oi(i.rtl,this.x,this.width),p=function(i){e.fillText(i,g.x(t.x+f),t.y+d/2),t.y+=d+n},m=g.textAlign(o);let b,x,_,y,v,M,w;for(e.textAlign=o,e.textBaseline=\"middle\",e.font=c.string,t.x=Ea(this,m,i),e.fillStyle=i.bodyColor,u(this.beforeBody,p),f=a&&\"right\"!==m?\"center\"===o?l/2+h:l+2+h:0,y=0,M=s.length;y<M;++y){for(b=s[y],x=this.labelTextColors[y],e.fillStyle=x,u(b.before,p),_=b.lines,a&&_.length&&(this._drawColorBox(e,t,y,g,i),d=Math.max(c.lineHeight,r)),v=0,w=_.length;v<w;++v)p(_[v]),d=c.lineHeight;u(b.after,p)}f=0,d=c.lineHeight,u(this.afterBody,p),t.y-=n}drawFooter(t,e,i){const s=this.footer,n=s.length;let o,a;if(n){const r=Oi(i.rtl,this.x,this.width);for(t.x=Ea(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=r.textAlign(i.footerAlign),e.textBaseline=\"middle\",o=Si(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a<n;++a)e.fillText(s[a],r.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}}drawBackground(t,e,i,s){const{xAlign:n,yAlign:o}=this,{x:a,y:r}=t,{width:l,height:h}=i,{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=wi(s.cornerRadius);e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+c,r),\"top\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+l-d,r),e.quadraticCurveTo(a+l,r,a+l,r+d),\"center\"===o&&\"right\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a+l,r+h-f),e.quadraticCurveTo(a+l,r+h,a+l-f,r+h),\"bottom\"===o&&this.drawCaret(t,e,i,s),e.lineTo(a+u,r+h),e.quadraticCurveTo(a,r+h,a,r+h-u),\"center\"===o&&\"left\"===n&&this.drawCaret(t,e,i,s),e.lineTo(a,r+c),e.quadraticCurveTo(a,r,a+c,r),e.closePath(),e.fill(),s.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,i=this.$animations,s=i&&i.x,n=i&&i.y;if(s||n){const i=Sa[t.position].call(this,this._active,this._eventPosition);if(!i)return;const o=this._size=Oa(this,t),a=Object.assign({},i,this._size),r=Ta(e,t,a),l=La(t,a,r,e);s._to===l.x&&n._to===l.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(t){const e=this.options.setContext(this.getContext());let i=this.opacity;if(!i)return;this._updateAnimationTarget(e);const s={width:this.width,height:this.height},n={x:this.x,y:this.y};i=Math.abs(i)<.001?0:i;const o=ki(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),Ai(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),Ti(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const i=this._active,s=t.map((({datasetIndex:t,index:e})=>{const i=this.chart.getDatasetMeta(t);if(!i)throw new Error(\"Cannot find a dataset at index \"+t);return{datasetIndex:t,element:i.data[e],index:e}})),n=!f(i,s),o=this._positionChanged(s,e);(n||o)&&(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,i=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,n=this._active||[],o=this._getActiveElements(t,n,e,i),a=this._positionChanged(o,t),r=e||!f(o,n)||a;return r&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),r}_getActiveElements(t,e,i,s){const n=this.options;if(\"mouseout\"===t.type)return[];if(!s)return e.filter((t=>this.chart.data.datasets[t.datasetIndex]&&void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index)));const o=this.chart.getElementsAtEventForMode(t,n.mode,n,i);return n.reverse&&o.reverse(),o}_positionChanged(t,e){const{caretX:i,caretY:s,options:n}=this,o=Sa[n.position].call(this,t,e);return!1!==o&&(i!==o.x||s!==o.y)}}var Ba={id:\"tooltip\",_element:Va,positioners:Sa,afterInit(t,e,i){i&&(t.tooltip=new Va({chart:t,options:i}))},beforeUpdate(t,e,i){t.tooltip&&t.tooltip.initialize(i)},reset(t,e,i){t.tooltip&&t.tooltip.initialize(i)},afterDraw(t){const e=t.tooltip;if(e&&e._willRender()){const i={tooltip:e};if(!1===t.notifyPlugins(\"beforeTooltipDraw\",{...i,cancelable:!0}))return;e.draw(t.ctx),t.notifyPlugins(\"afterTooltipDraw\",i)}},afterEvent(t,e){if(t.tooltip){const i=e.replay;t.tooltip.handleEvent(e.event,i,e.inChartArea)&&(e.changed=!0)}},defaults:{enabled:!0,external:null,position:\"average\",backgroundColor:\"rgba(0,0,0,0.8)\",titleColor:\"#fff\",titleFont:{weight:\"bold\"},titleSpacing:2,titleMarginBottom:6,titleAlign:\"left\",bodyColor:\"#fff\",bodySpacing:2,bodyFont:{},bodyAlign:\"left\",footerColor:\"#fff\",footerSpacing:2,footerMarginTop:6,footerFont:{weight:\"bold\"},footerAlign:\"left\",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(t,e)=>e.bodyFont.size,boxWidth:(t,e)=>e.bodyFont.size,multiKeyBackground:\"#fff\",displayColors:!0,boxPadding:0,borderColor:\"rgba(0,0,0,0)\",borderWidth:0,animation:{duration:400,easing:\"easeOutQuart\"},animations:{numbers:{type:\"number\",properties:[\"x\",\"y\",\"width\",\"height\",\"caretX\",\"caretY\"]},opacity:{easing:\"linear\",duration:200}},callbacks:za},defaultRoutes:{bodyFont:\"font\",footerFont:\"font\",titleFont:\"font\"},descriptors:{_scriptable:t=>\"filter\"!==t&&\"itemSort\"!==t&&\"external\"!==t,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:\"animation\"}},additionalOptionScopes:[\"interaction\"]};return An.register(Yn,jo,fo,t),An.helpers={...Wi},An._adapters=Rn,An.Animation=Cs,An.Animations=Os,An.animator=xt,An.controllers=en.controllers.items,An.DatasetController=Ns,An.Element=Hs,An.elements=fo,An.Interaction=Xi,An.layouts=as,An.platforms=Ss,An.Scale=Js,An.Ticks=ae,Object.assign(An,Yn,jo,fo,t,Ss),An.Chart=An,\"undefined\"!=typeof window&&(window.Chart=An),An}));\n//# sourceMappingURL=chart.umd.js.map\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type Chart from '../core/core.controller.js';\nimport type {ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\n\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta, chartArea) {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta, this.chartArea);\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the envent inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<string, string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: TimeUnit): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: TimeUnit): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek'): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<string, string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase\n};\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, 𝜃) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, /** @type {Unit} */ (parser))\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n","import {DoughnutController, PolarAreaController} from '../index.js';\nimport type {Chart, ChartDataset} from '../types.js';\n\nexport interface ColorsPluginOptions {\n  enabled?: boolean;\n  forceOverride?: boolean;\n}\n\ninterface ColorsDescriptor {\n  backgroundColor?: unknown;\n  borderColor?: unknown;\n}\n\nconst BORDER_COLORS = [\n  'rgb(54, 162, 235)', // blue\n  'rgb(255, 99, 132)', // red\n  'rgb(255, 159, 64)', // orange\n  'rgb(255, 205, 86)', // yellow\n  'rgb(75, 192, 192)', // green\n  'rgb(153, 102, 255)', // purple\n  'rgb(201, 203, 207)' // grey\n];\n\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map(color => color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\n\nfunction getBorderColor(i: number) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\n\nfunction getBackgroundColor(i: number) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\n\nfunction colorizeDefaultDataset(dataset: ChartDataset, i: number) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n\n  return ++i;\n}\n\nfunction colorizeDoughnutDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n\n  return i;\n}\n\nfunction colorizePolarAreaDataset(dataset: ChartDataset, i: number) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n\n  return i;\n}\n\nfunction getColorizer(chart: Chart) {\n  let i = 0;\n\n  return (dataset: ChartDataset, datasetIndex: number) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\n\nfunction containsColorsDefinitions(\n  descriptors: ColorsDescriptor[] | Record<string, ColorsDescriptor>\n) {\n  let k: number | string;\n\n  for (k in descriptors) {\n    if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction containsColorsDefinition(\n  descriptor: ColorsDescriptor\n) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\n\nexport default {\n  id: 'colors',\n\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  } as ColorsPluginOptions,\n\n  beforeLayout(chart: Chart, _args, options: ColorsPluginOptions) {\n    if (!options.enabled) {\n      return;\n    }\n\n    const {\n      data: {datasets},\n      options: chartOptions\n    } = chart.config;\n    const {elements} = chartOptions;\n\n    if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || (elements && containsColorsDefinitions(elements)))) {\n      return;\n    }\n\n    const colorizer = getColorizer(chart);\n\n    datasets.forEach(colorizer);\n  }\n};\n","import {_limitValue, _lookupByKey, isNullOrUndef, resolve} from '../helpers/index.js';\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  /**\n   * Implementation of the Largest Triangle Three Buckets algorithm.\n   *\n   * This implementation is based on the original implementation by Sveinn Steinarsson\n   * in https://github.com/sveinn-steinarsson/flot-downsample/blob/master/jquery.flot.downsample.js\n   *\n   * The original implementation is MIT licensed.\n   */\n  const samples = options.samples || availableWidth;\n  // There are less points than the threshold, returning the whole array\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n\n  const decimated = [];\n\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  // Starting from offset\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n\n  decimated[sampledIndex++] = data[a];\n\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n\n    // Adding offset\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n\n    // Adding offset\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {x: pointAx, y: pointAy} = data[a];\n\n    // Note that this is changed from the original algorithm which initializes these\n    // values to 1. The reason for this change is that if the area is small, nextA\n    // would never be set and thus a crash would occur in the next loop as `a` would become\n    // `undefined`. Since the area is always positive, but could be 0 in the case of a flat trace,\n    // initializing with a negative number is the correct solution.\n    maxArea = area = -1;\n\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs(\n        (pointAx - avgX) * (data[j].y - pointAy) -\n        (pointAx - data[j].x) * (avgY - pointAy)\n      );\n\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n\n  // Include the last point\n  decimated[sampledIndex++] = data[endIndex];\n\n  return decimated;\n}\n\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      // Use point.x here because we're computing the average data `x` value\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      // Push up to 4 points, 3 for the last interval and the first point for this interval\n      const lastIndex = i - 1;\n\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        // The interval is defined by 4 points: start, min, max, end.\n        // The starting point is already considered at this point, so we need to determine which\n        // of the other points to add. We need to sort these points to ensure the decimated data\n        // is still sorted and then ensure there are no duplicates.\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex1],\n            x: avgX,\n          });\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push({\n            ...data[intermediateIndex2],\n            x: avgX\n          });\n        }\n      }\n\n      // lastIndex === startIndex will occur when a range has only 1 point which could\n      // happen with very uneven data\n      if (i > 0 && lastIndex !== startIndex) {\n        // Last point in the previous interval\n        decimated.push(data[lastIndex]);\n      }\n\n      // Start of the new interval\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n\n  return decimated;\n}\n\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, 'data', {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data,\n    });\n  }\n}\n\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\n\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count;\n\n  const {iScale} = meta;\n  const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n\n  return {start, count};\n}\n\nexport default {\n  id: 'decimation',\n\n  defaults: {\n    algorithm: 'min-max',\n    enabled: false,\n  },\n\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      // The decimation plugin may have been previously enabled. Need to remove old `dataset._data` handlers\n      cleanDecimatedData(chart);\n      return;\n    }\n\n    // Assume the entire chart is available to show a few more points than needed\n    const availableWidth = chart.width;\n\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {_data, indexAxis} = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n\n      if (resolve([indexAxis, chart.options.indexAxis]) === 'y') {\n        // Decimation is only supported for lines that have an X indexAxis\n        return;\n      }\n\n      if (!meta.controller.supportsDecimation) {\n        // Only line datasets are supported\n        return;\n      }\n\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n        // Only linear interpolation is supported\n        return;\n      }\n\n      if (chart.options.parsing) {\n        // Plugin only supports data that does not need parsing\n        return;\n      }\n\n      let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        // No decimation is required until we are above this threshold\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n\n      if (isNullOrUndef(_data)) {\n        // First time we are seeing this dataset\n        // We override the 'data' property with a setter that stores the\n        // raw data in _data, but reads the decimated data from _decimated\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, 'data', {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n\n      // Point the chart to the decimated data\n      let decimated;\n      switch (options.algorithm) {\n      case 'lttb':\n        decimated = lttbDecimation(data, start, count, availableWidth, options);\n        break;\n      case 'min-max':\n        decimated = minMaxDecimation(data, start, count, availableWidth);\n        break;\n      default:\n        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n\n      dataset._decimated = decimated;\n    });\n  },\n\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\n","import {_boundSegment, _boundSegments, _normalizeAngle} from '../../helpers/index.js';\n\nexport function _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n\n  for (const segment of segments) {\n    let {start, end} = segment;\n    end = _findSegmentEnd(start, end, points);\n\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n\n    if (!target.segments) {\n      // Special case for boundary not supporting `segments` (simpleArc)\n      // Bounds are provided as `target` for partial circle, or undefined for full circle\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n\n    // Get all segments from `target` that intersect the bounds of current segment of `line`\n    const targetSegments = _boundSegments(target, bounds);\n\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\n\nexport function _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n\n  if (property === 'angle') {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {property, start, end};\n}\n\nexport function _pointsFromSegments(boundary, line) {\n  const {x = null, y = null} = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({start, end}) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({x: first.x, y});\n      points.push({x: last.x, y});\n    } else if (x !== null) {\n      points.push({x, y: first.y});\n      points.push({x, y: last.y});\n    }\n  });\n  return points;\n}\n\nexport function _findSegmentEnd(start, end, points) {\n  for (;end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\n\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {isArray} from '../../helpers/index.js';\nimport {_pointsFromSegments} from './filler.segment.js';\n\n/**\n * @param {PointElement[] | { x: number; y: number; }} boundary\n * @param {LineElement} line\n * @return {LineElement?}\n */\nexport function _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n\n  if (isArray(boundary)) {\n    _loop = true;\n    // @ts-ignore\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n\n  return points.length ? new LineElement({\n    points,\n    options: {tension: 0},\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\n\nexport function _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\n","import {isObject, isFinite, valueOrDefault} from '../../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.line.js').default } LineElement\n * @typedef { import('../../types/index.js').FillTarget } FillTarget\n * @typedef { import('../../types/index.js').ComplexFillTarget } ComplexFillTarget\n */\n\nexport function _resolveTarget(sources, index, propagate) {\n  const source = sources[index];\n  let fill = source.fill;\n  const visited = [index];\n  let target;\n\n  if (!propagate) {\n    return fill;\n  }\n\n  while (fill !== false && visited.indexOf(fill) === -1) {\n    if (!isFinite(fill)) {\n      return fill;\n    }\n\n    target = sources[fill];\n    if (!target) {\n      return false;\n    }\n\n    if (target.visible) {\n      return fill;\n    }\n\n    visited.push(fill);\n    fill = target.fill;\n  }\n\n  return false;\n}\n\n/**\n * @param {LineElement} line\n * @param {number} index\n * @param {number} count\n */\nexport function _decodeFill(line, index, count) {\n  /** @type {string | {value: number}} */\n  const fill = parseFillOption(line);\n\n  if (isObject(fill)) {\n    return isNaN(fill.value) ? false : fill;\n  }\n\n  let target = parseFloat(fill);\n\n  if (isFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill[0], index, target, count);\n  }\n\n  return ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 && fill;\n}\n\nfunction decodeTargetIndex(firstCh, index, target, count) {\n  if (firstCh === '-' || firstCh === '+') {\n    target = index + target;\n  }\n\n  if (target === index || target < 0 || target >= count) {\n    return false;\n  }\n\n  return target;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @returns {number | null}\n */\nexport function _getTargetPixel(fill, scale) {\n  let pixel = null;\n  if (fill === 'start') {\n    pixel = scale.bottom;\n  } else if (fill === 'end') {\n    pixel = scale.top;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    pixel = scale.getPixelForValue(fill.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\n\n/**\n * @param {FillTarget | ComplexFillTarget} fill\n * @param {Scale} scale\n * @param {number} startValue\n * @returns {number | undefined}\n */\nexport function _getTargetValue(fill, scale, startValue) {\n  let value;\n\n  if (fill === 'start') {\n    value = startValue;\n  } else if (fill === 'end') {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill)) {\n    // @ts-ignore\n    value = fill.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\n\n/**\n * @param {LineElement} line\n */\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n\n  if (fill === undefined) {\n    fill = !!options.backgroundColor;\n  }\n\n  if (fill === false || fill === null) {\n    return false;\n  }\n\n  if (fill === true) {\n    return 'origin';\n  }\n  return fill;\n}\n","/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nimport {LineElement} from '../../elements/index.js';\nimport {_isBetween} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\n\n/**\n * @param {{ chart: Chart; scale: Scale; index: number; line: LineElement; }} source\n * @return {LineElement}\n */\nexport function _buildStackLine(source) {\n  const {scale, index, line} = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index);\n  linesBelow.push(_createBoundaryLine({x: null, y: scale.bottom}, line));\n\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({points, options: {}});\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @return {LineElement[]}\n */\nfunction getLinesBelow(scale, index) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas('line');\n\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\n\n/**\n * @param {PointElement[]} points\n * @param {PointElement} sourcePoint\n * @param {LineElement[]} linesBelow\n */\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {first, last, point} = findPoint(line, sourcePoint, 'x');\n\n    if (!point || (first && last)) {\n      continue;\n    }\n    if (first) {\n      // First point of an segment -> need to add another point before this,\n      // from next line below.\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        // In the middle of an segment, no need to add more points.\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\n\n/**\n * @param {LineElement} line\n * @param {PointElement} sourcePoint\n * @param {string} property\n * @returns {{point?: PointElement, first?: boolean, last?: boolean}}\n */\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {first, last, point};\n}\n","import {TAU} from '../../helpers/index.js';\n\n// TODO: use elements.ArcElement instead\nexport class simpleArc {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n\n  pathSegment(ctx, bounds, opts) {\n    const {x, y, radius} = this;\n    bounds = bounds || {start: 0, end: TAU};\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n\n  interpolate(point) {\n    const {x, y, radius} = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n}\n","import {isFinite} from '../../helpers/index.js';\nimport {_createBoundaryLine} from './filler.helper.js';\nimport {_getTargetPixel, _getTargetValue} from './filler.options.js';\nimport {_buildStackLine} from './filler.target.stack.js';\nimport {simpleArc} from './simpleArc.js';\n\n/**\n * @typedef { import('../../core/core.controller.js').default } Chart\n * @typedef { import('../../core/core.scale.js').default } Scale\n * @typedef { import('../../elements/element.point.js').default } PointElement\n */\n\nexport function _getTarget(source) {\n  const {chart, fill, line} = source;\n\n  if (isFinite(fill)) {\n    return getLineByIndex(chart, fill);\n  }\n\n  if (fill === 'stack') {\n    return _buildStackLine(source);\n  }\n\n  if (fill === 'shape') {\n    return true;\n  }\n\n  const boundary = computeBoundary(source);\n\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n\n  return _createBoundaryLine(boundary, line);\n}\n\n/**\n * @param {Chart} chart\n * @param {number} index\n */\nfunction getLineByIndex(chart, index) {\n  const meta = chart.getDatasetMeta(index);\n  const visible = meta && chart.isDatasetVisible(index);\n  return visible ? meta.dataset : null;\n}\n\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\n\n\nfunction computeLinearBoundary(source) {\n  const {scale = {}, fill} = source;\n  const pixel = _getTargetPixel(fill, scale);\n\n  if (isFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n\n  return null;\n}\n\nfunction computeCircularBoundary(source) {\n  const {scale, fill} = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill, scale, start);\n  const target = [];\n\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\n\n","import {clipArea, unclipArea} from '../../helpers/index.js';\nimport {_findSegmentEnd, _getBounds, _segments} from './filler.segment.js';\nimport {_getTarget} from './filler.target.js';\n\nexport function _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {line, scale, axis} = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color = lineOpts.backgroundColor;\n  const {above = color, below = color} = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {line, target, above, below, area, scale, axis});\n    unclipArea(ctx);\n  }\n}\n\nfunction doFill(ctx, cfg) {\n  const {line, target, above, below, area, scale} = cfg;\n  const property = line._loop ? 'angle' : cfg.axis;\n\n  ctx.save();\n\n  if (property === 'x' && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {line, target, color: above, scale, property});\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {line, target, color: below, scale, property});\n\n  ctx.restore();\n}\n\nfunction clipVertical(ctx, target, clipY) {\n  const {segments, points} = target;\n  let first = true;\n  let lineLoop = false;\n\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {start, end} = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {move: lineLoop});\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction fill(ctx, cfg) {\n  const {line, target, property, color, scale} = cfg;\n  const segments = _segments(line, target, property);\n\n  for (const {source: src, target: tgt, start, end} of segments) {\n    const {style: {backgroundColor = color} = {}} = src;\n    const notShape = target !== true;\n\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n\n    ctx.beginPath();\n\n    const lineLoop = !!line.pathSegment(ctx, src);\n\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n\n      const targetLoop = !!target.pathSegment(ctx, tgt, {move: lineLoop, reverse: true});\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n\n    ctx.closePath();\n    ctx.fill(loop ? 'evenodd' : 'nonzero');\n\n    ctx.restore();\n  }\n}\n\nfunction clipBounds(ctx, scale, bounds) {\n  const {top, bottom} = scale.chart.chartArea;\n  const {property, start, end} = bounds || {};\n  if (property === 'x') {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\n\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\n\n","/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\nimport LineElement from '../../elements/element.line.js';\nimport {_drawfill} from './filler.drawing.js';\nimport {_shouldApplyFill} from './filler.helper.js';\nimport {_decodeFill, _resolveTarget} from './filler.options.js';\n\nexport default {\n  id: 'filler',\n\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line,\n        };\n      }\n\n      meta.$filler = source;\n      sources.push(source);\n    }\n\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n\n  beforeDraw(chart, _args, options) {\n    const draw = options.drawTime === 'beforeDraw';\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n\n      source.line.updateControlPoints(area, source.axis);\n      if (draw && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== 'beforeDatasetsDraw') {\n      return;\n    }\n\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n\n    if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n      return;\n    }\n\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n\n  defaults: {\n    propagate: true,\n    drawTime: 'beforeDatasetDraw'\n  }\n};\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n\n/**\n * @namespace Chart\n */\nimport Chart from './core/core.controller.js';\n\nimport * as helpers from './helpers/index.js';\nimport _adapters from './core/core.adapters.js';\nimport Animation from './core/core.animation.js';\nimport animator from './core/core.animator.js';\nimport Animations from './core/core.animations.js';\nimport * as controllers from './controllers/index.js';\nimport DatasetController from './core/core.datasetController.js';\nimport Element from './core/core.element.js';\nimport * as elements from './elements/index.js';\nimport Interaction from './core/core.interaction.js';\nimport layouts from './core/core.layouts.js';\nimport * as platforms from './platform/index.js';\nimport * as plugins from './plugins/index.js';\nimport registry from './core/core.registry.js';\nimport Scale from './core/core.scale.js';\nimport * as scales from './scales/index.js';\nimport Ticks from './core/core.ticks.js';\n\n// Register built-ins\nChart.register(controllers, scales, elements, plugins);\n\nChart.helpers = {...helpers};\nChart._adapters = _adapters;\nChart.Animation = Animation;\nChart.Animations = Animations;\nChart.animator = animator;\nChart.controllers = registry.controllers.items;\nChart.DatasetController = DatasetController;\nChart.Element = Element;\nChart.elements = elements;\nChart.Interaction = Interaction;\nChart.layouts = layouts;\nChart.platforms = platforms;\nChart.Scale = Scale;\nChart.Ticks = Ticks;\n\n// Compatibility with ESM extensions\nObject.assign(Chart, controllers, scales, elements, plugins, platforms);\nChart.Chart = Chart;\n\nif (typeof window !== 'undefined') {\n  window.Chart = Chart;\n}\n\nexport default Chart;\n\n"],"names":["t","e","Ht","Object","freeze","__proto__","Colors","Go","Decimation","Qo","Filler","ma","Legend","ya","SubTitle","ka","Title","Ma","Tooltip","Ba","i","s","n","Array","isArray","prototype","toString","call","slice","o","a","Number","isFinite","r","l","h","endsWith","parseFloat","c","d","apply","u","length","keys","f","datasetIndex","index","g","map","create","p","indexOf","m","b","merger","x","_","hasOwnProperty","y","v","split","push","M","w","charAt","toUpperCase","k","S","P","size","has","D","type","C","Math","PI","O","A","T","POSITIVE_INFINITY","L","E","R","I","z","log10","F","sign","V","abs","B","round","pow","floor","W","sqrt","sort","pop","N","isNaN","H","j","min","max","$","Y","U","X","atan2","angle","distance","q","K","G","Z","J","Q","tt","et","lo","hi","it","st","nt","ot","at","_chartjs","listeners","defineProperty","configurable","enumerable","value","forEach","rt","splice","lt","Set","from","ht","window","requestAnimationFrame","ct","dt","clearTimeout","setTimeout","ut","ft","gt","pt","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","start","count","mt","xScale","yScale","_scaleRanges","xmin","xmax","ymin","ymax","assign","xt","constructor","_request","_charts","Map","_running","_lastDate","_notify","duration","chart","initial","numSteps","currentStep","_refresh","_update","Date","now","running","items","_active","_total","tick","draw","_getAnims","get","complete","progress","set","listen","add","reduce","_duration","stop","cancel","remove","delete","_t","yt","vt","Mt","wt","kt","St","Pt","Dt","Ct","Ot","Tt","Lt","Et","Rt","It","zt","Vt","Wt","Nt","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","$t","Yt","Ut","Xt","qt","Kt","Zt","jt","replace","parseInt","transparent","toLowerCase","exec","Bt","_rgb","_valid","valid","rgb","rgbString","hexString","hslString","mix","interpolate","clone","alpha","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","rotate","Jt","Qt","te","ee","ie","se","ne","JSON","stringify","Intl","NumberFormat","format","oe","values","numeric","options","locale","notation","minimumFractionDigits","maximumFractionDigits","ticks","logarithmic","includes","significand","ae","formatters","re","le","he","ce","ue","animation","backgroundColor","borderColor","color","datasets","devicePixelRatio","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","weight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","defineProperties","writable","_scriptable","startsWith","_indexable","_fallback","delay","easing","fn","loop","to","colors","properties","numbers","active","resize","show","animations","visible","hide","autoPadding","padding","top","right","bottom","left","display","offset","reverse","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","border","dash","dashOffset","width","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","callback","minor","major","align","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","fe","document","ge","parentNode","host","pe","me","ownerDocument","defaultView","getComputedStyle","be","getPropertyValue","xe","_e","height","ye","shadowRoot","ve","canvas","currentDevicePixelRatio","boxSizing","box","touches","offsetX","offsetY","target","getBoundingClientRect","clientX","clientY","Me","we","maxWidth","maxHeight","clientWidth","clientHeight","ke","ctx","setTransform","Se","passive","addEventListener","removeEventListener","Pe","match","De","Ce","measureText","Oe","data","garbageCollect","save","restore","Ae","Te","getContext","resetTransform","clearRect","Le","Ee","pointStyle","rotation","radius","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","sin","cos","lineTo","SQRT1_2","rect","fill","borderWidth","stroke","Re","Ie","ze","Fe","Ve","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","Ne","strokeWidth","strokeColor","string","translation","fillStyle","textAlign","textBaseline","backdrop","We","fillRect","strokeStyle","strokeText","fillText","Be","strikethrough","underline","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","decorationWidth","He","topLeft","bottomLeft","bottomRight","topRight","je","ti","Symbol","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","qe","Ue","Je","getOwnPropertyDescriptor","Reflect","getPrototypeOf","ei","ownKeys","_storage","$e","_proxy","_context","_subProxy","_stack","_descriptors","Ye","setContext","isScriptable","Error","join","filter","isIndexable","allKeys","scriptable","indexable","_allKeys","Ge","Ze","ii","key","_parsing","parse","si","EPSILON","ni","skip","oi","ai","previous","next","ri","li","spanGaps","cubicInterpolationMode","tension","capBezierPoints","ci","di","ui","fi","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","gi","pi","mi","bi","xi","_i","yi","vi","Mi","wi","ki","Si","console","warn","Pi","cacheable","Di","Ci","Oi","setWidth","xPlus","leftForLtr","Ai","getPropertyPriority","setProperty","prevTextDirection","Ti","Li","between","compare","normalize","Ei","end","Ri","property","Ii","segments","points","zi","_loop","Fi","_fullLoop","_chart","Vi","_datasetIndex","Bi","p0","p1","p0DataIndex","p1DataIndex","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","Wi","HALF_PI","INFINITY","PITAU","QUARTER_PI","RAD_PER_DEG","TAU","TWO_THIRDS_PI","_addGrace","_alignPixel","_alignStartEnd","_angleBetween","_angleDiff","_arrayUnique","_attachContext","_bezierCurveTo","_bezierInterpolation","_boundSegment","_boundSegments","_capitalize","_computeSegments","_createResolver","_decimalPlaces","_deprecated","_elementsEqual","_factorize","_filterBetween","_getParentNode","_getStartAndCountOfVisiblePoints","_int16Range","_isBetween","_isClickEvent","_isDomSupported","_isPointInArea","_limitValue","_longestText","_lookup","_lookupByKey","_measureText","_merger","_mergerIf","_normalizeAngle","_parseObjectDataRadialScale","_pointInLine","_readValueToProps","_rlookupByKey","_scaleRangesChanged","_setMinAndMaxByKey","_splitKey","_steppedInterpolation","_steppedLineTo","_textX","_toLeftRightCenter","_updateBezierControlPoints","addRoundedRectPath","almostEquals","almostWhole","clearCanvas","clipArea","createContext","debounce","defined","distanceBetweenPoints","drawPoint","drawPointLegend","each","easingEffects","finiteOrDefault","fontString","formatNumber","getAngleFromPoint","getHoverColor","getMaximumSize","getRelativePosition","getRtlAdapter","getStyle","isFunction","isNullOrUndef","isNumber","isObject","isPatternOrGradient","listenArrayEvents","merge","mergeIf","niceNum","noop","overrideTextDirection","readUsedSize","renderText","requestAnimFrame","resolve","resolveObjectKey","restoreTextDirection","retinaScale","setsEqual","splineCurve","splineCurveMonotone","supportsEventListenerOptions","throttled","toDegrees","toDimension","toFont","toFontString","toLineHeight","toPadding","toPercentage","toRadians","toTRBL","toTRBLCorners","uid","unclipArea","unlistenArrayEvents","valueOrDefault","Hi","getSortedVisibleDatasetMetas","Ni","controller","_cachedMeta","_reversePixels","_sharedOptions","getRange","ji","isPointInArea","chartArea","inRange","element","Yi","$i","getCenterPoint","startAngle","endAngle","getProps","Ui","Xi","evaluateInteractionItems","modes","dataset","getDatasetMeta","point","nearest","qi","Ki","pos","Gi","Zi","Qi","ts","ss","update","is","maxPadding","horizontal","same","other","es","stack","getPadding","outerWidth","outerHeight","fullSize","ns","os","placed","stackWeight","as","addBox","boxes","position","_layers","removeBox","configure","layout","isHorizontal","leftAndTop","concat","rightAndBottom","vertical","beforeLayout","availableWidth","availableHeight","vBoxMaxWidth","hBoxMaxHeight","Ji","rs","acquireContext","releaseContext","isAttached","updateConfig","ls","hs","cs","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","ds","us","gs","contains","ps","MutationObserver","addedNodes","removedNodes","observe","childList","subtree","ms","bs","xs","_s","ys","ResizeObserver","contentRect","vs","disconnect","Ms","native","ws","getAttribute","removeAttribute","setAttribute","$proxies","attach","detach","isConnected","ks","OffscreenCanvas","Ss","BasePlatform","BasicPlatform","DomPlatform","_detectPlatform","Ps","Ds","boolean","number","Cs","_fn","_easing","_start","_target","_prop","_from","_to","_promises","wait","Promise","res","rej","Os","_properties","getOwnPropertyNames","_animateOptions","$shared","$animations","_createAnimations","all","then","As","Ts","_getSortedDatasetMetas","Ls","Es","stacked","Is","getMatchingVisibleMetas","zs","_stacks","vScale","id","Rs","_top","_bottom","_visualValues","Fs","shift","Vs","Bs","Ws","Ns","defaults","datasetElementType","dataElementType","_ctx","_cachedDataOpts","getMeta","_type","_data","_objectData","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","getDataset","xAxisID","yAxisID","rAxisID","iAxisID","vAxisID","getScaleForId","rScale","_getOtherScale","reset","_destroy","_dataCheck","isExtensible","buildOrUpdateElements","_resyncElements","config","datasetScopeKeys","getOptionScopes","createResolver","parseArrayData","parseObjectData","parsePrimitiveData","getLabels","xAxisKey","yAxisKey","getParsed","getDataElement","applyStack","updateRangeFromParsed","NaN","getMinMax","hidden","NEGATIVE_INFINITY","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","disabled","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","parsed","raw","_resolveElementOptions","datasetElementScopeKeys","resolveNamedOptions","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","_animationsDisabled","_getSharedOptions","updateSharedOptions","sharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","_insertElements","_removeElements","updateElements","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","_onDataUnshift","Hs","defaultRoutes","tooltipPosition","hasValue","$s","ceil","Ys","Us","Xs","Ks","Gs","Js","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_length","_maxLength","_longestTextCache","_startPixel","_endPixel","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_cache","_dataLimitsCached","init","suggestedMin","suggestedMax","getTicks","labels","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","source","js","_tickSize","maxTicksLimit","enabled","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","_isVisible","_getLabelSizes","widest","highest","asin","first","last","_calculatePadding","_handleMargins","getPixelForTick","isFullSize","_computeLabelSizes","_resolveTickFontOptions","gc","widths","heights","getValueForPixel","getPixelForDecimal","getDecimalForPixel","getBasePixel","getBaseValue","_computeGridLineItems","tickBorderDash","tickBorderDashOffset","qs","tx1","ty1","tx2","ty2","x1","y1","x2","y2","_getXAxisLabelAlignment","_getYAxisLabelAlignment","textOffset","_computeLabelArea","drawBackground","getLineWidthForValue","findIndex","drawGrid","setLineDash","lineDashOffset","drawBorder","drawLabels","drawTitle","titleX","titleY","_maxDigits","Qs","scope","isForType","isPrototypeOf","register","descriptors","overrides","unregister","en","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getElement","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","_getRegistryForType","_exec","sn","_init","notify","_createDescriptors","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","on","local","pluginScopeKeys","some","an","rn","ln","hn","dn","cn","error","un","gn","pn","mn","bn","_config","_scopeCache","_resolverCache","clearCache","clear","additionalOptionScopes","_cachedScopes","chartOptionScopes","resolver","subPrefixes","xn","_n","yn","vn","Mn","wn","onComplete","kn","onProgress","Sn","getElementById","Pn","Dn","On","An","instances","registry","version","getChart","Tn","aspectRatio","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","onResize","render","ensureScalesHaveIDs","buildOrUpdateScales","dposition","dtype","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","_dataset","buildOrUpdateControllers","order","isDatasetVisible","_resetElements","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","unbindEvents","method","_getUniformDataChanges","Cn","_idx","_updateDataset","meta","_drawDatasets","_drawDataset","getElementsAtEventForMode","getVisibleDatasetCount","setDatasetVisibility","toggleDataVisibility","getDataVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","updateHoverStyle","getActiveElements","setActiveElements","event","replay","inChartArea","_handleEvent","changed","_getActiveElements","Ln","En","formats","diff","startOf","endOf","Rn","_date","zn","_custom","barStart","barEnd","Fn","Vn","Wn","Nn","jn","animateRotate","animateScale","cutout","circumference","spacing","legend","generateLabels","fontColor","innerRadius","outerRadius","_getRotation","_getCircumference","_getRotationExtents","getMaxBorderWidth","getMaxOffset","_getRingWeight","ratioX","ratioY","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","borderAlign","hoverBorderWidth","hoverOffset","$n","angleLines","circular","pointLabels","bind","_updateRadius","cutoutPercentage","xCenter","yCenter","getIndexAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","Yn","BarController","categoryPercentage","barPercentage","grouped","_index_","_value_","_getRuler","base","head","_calculateBarValuePixels","_calculateBarIndexPixels","enableBorderRadius","center","Bn","borderSkipped","Hn","inflateAmount","ratio","_getStacks","_getStackCount","_getStackIndex","barThickness","In","$bar","pixels","stackCount","minBarLength","skipNull","maxBarThickness","chunk","BubbleController","DoughnutController","LineController","_decimated","segment","animated","updateControlPoints","PieController","PolarAreaController","RadarController","line","getPointPositionForValue","ScatterController","Xn","qn","pixelMargin","outerStart","outerEnd","innerStart","innerEnd","Un","borderRadius","Gn","lineCap","lineJoin","Zn","Jn","ilen","Qn","stepped","move","eo","io","Path2D","no","_path","_points","_segments","_pointsUpdated","pathSegment","path","oo","hitRadius","ao","ro","ho","co","uo","fo","ArcElement","fullCircles","Kn","BarElement","inner","outer","inXRange","inYRange","LineElement","PointElement","hoverRadius","po","mo","bo","_startValue","_endValue","_valueRange","handleTickRangeOptions","getTickLimit","stepSize","computeTickLimit","step","precision","maxTicks","maxDigits","includeBounds","xo","_o","yo","vo","Mo","ko","_zero","wo","So","Po","Lo","getPointPosition","Eo","animate","centerPointLabels","drawingArea","_pointLabels","_pointLabelItems","_padding","Do","getPointLabelContext","Co","setCenterPoint","extra","additionalAngle","Oo","Ao","getValueForDistanceFromCenter","getBasePosition","getPointLabelPosition","To","Ro","millisecond","common","steps","second","minute","hour","day","week","month","quarter","year","Io","zo","Fo","_adapter","parser","isoWeekday","_parseOpts","Vo","MAX_SAFE_INTEGER","Bo","Wo","No","adapters","time","unit","minUnit","displayFormats","_unit","_majorUnit","_offsets","_normalized","date","normalized","_getLabelBounds","getLabelTimestamps","_generate","_getLabelCapacity","initOffsets","offsetAfterAutoskip","getDecimalForValue","factor","getDataTimestamps","tooltipFormat","datetime","_tickFormatFunction","_getLabelSize","Ho","jo","CategoryScale","_addedLabels","go","unshift","lastIndexOf","LinearScale","LogarithmicScale","RadialLinearScale","TimeScale","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","$o","Yo","Uo","Xo","Ko","forceOverride","Zo","Jo","algorithm","beforeElementsUpdate","threshold","samples","ta","ea","ia","sa","na","ha","da","ca","ra","la","above","below","area","ua","fa","ga","pa","afterDatasetsUpdate","aa","$filler","oa","propagate","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","ba","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","xa","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","_computeTitleHeight","_fitRows","_fitCols","row","itemWidth","_a","col","adjustHitBoxes","rtl","_draw","textDirection","lineDash","SQRT2","_getLegendItemAt","handleEvent","onLeave","_element","afterEvent","useBorderRadius","va","_drawArgs","titleBlock","wa","WeakMap","Sa","average","Pa","Da","String","Oa","body","footer","bodyFont","titleFont","footerFont","before","lines","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","boxPadding","Ta","yAlign","xAlign","Aa","caretSize","caretPadding","La","cornerRadius","Ea","Ia","tooltip","callbacks","za","beforeTitle","afterTitle","beforeLabel","formattedValue","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","Fa","Va","positioners","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","tooltipItems","getTitle","getBeforeBody","getBody","getAfterBody","getFooter","_createItems","Ca","itemSort","external","drawCaret","getCaretPosition","x3","y3","titleAlign","titleColor","_drawColorBox","multiKeyBackground","strokeRect","drawBody","bodyAlign","drawFooter","footerAlign","footerColor","quadraticCurveTo","_updateAnimationTarget","_willRender","globalAlpha","_positionChanged","_ignoreReplayEvents","afterInit","afterDraw","helpers","_adapters","Animation","Animations","animator","DatasetController","Element","Interaction","layouts","platforms","Scale","Ticks","Chart","exports","module","define","amd","globalThis","self","isNumberFinite","defaultValue","dimension","args","thisArg","loopable","len","a0","a1","v0","v1","klen","isValidKey","tval","sval","sources","current","keyResolvers","parts","tmp","part","obj","_getKeyResolver","str","item","epsilon","range","roundedRange","niceRange","fraction","result","rounded","array","degrees","radians","isFiniteNumber","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","pt1","pt2","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","table","cmp","mid","arrayEvents","listener","this","object","stub","argsToUse","ticking","timeout","animationsDisabled","pointCount","newRanges","Animator","undefined","anims","remaining","charts","cb","acc","cur","lim","p2b","n2b","b2n","n2p","map$1","hex","h1","h2","eq","isShort","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","rgb2hsl","hueValue","calln","hsl2rgb","hue","hueParse","p2","hwb2rgb","hsv2rgb","names$1","names","nameParse","unpacked","tkeys","ok","nk","unpack","RGB_RE","modHSL","proto","fromObject","input","functionParse","rgbParse","Color","ret","c1","c2","w2","w1","rgb1","rgb2","val","deg","intlCache","num","cacheKey","formatter","getNumberFormat","tickValue","delta","maxTick","calculateDelta","logDelta","numDecimal","remain","getScope","node","root","Defaults","_appliers","context","name","targetScope","targetName","scopeObject","targetScopeObject","privateName","appliers","domNode","parent","parseMaxStyle","styleValue","parentProperty","valueInPixels","el","positions","getPositionedStyle","styles","suffix","useOffsetPos","borderBox","paddings","borders","getCanvasPosition","xOffset","yOffset","round1","bbWidth","bbHeight","margins","containerSize","container","containerStyle","containerBorder","containerPadding","getContainerSize","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","passiveSupported","matches","longest","textWidth","arrayOfThings","cache","jlen","thing","nestedThing","gcLen","pixel","halfWidth","xOffsetW","yOffsetW","rad","margin","flip","midpoint","decorateText","opts","metrics","yDecoration","drawBackdrop","oldColor","setRenderOpts","scopes","prefixes","rootScopes","fallback","getTarget","finalRootScopes","_resolve","prop","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getKeysFromAllScopes","storage","subProxy","descriptorDefaults","receiver","getValue","_resolveScriptable","arr","_resolveArray","_resolveWithContext","resolveFallback","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","getPoint","getValueAxis","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fb","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","controlPoints","prev","inArea","inAreaPrev","inAreaNext","atEdge","elasticIn","elasticOut","effects","cp1","cp2","LINE_HEIGHT","FONT_STYLE","numberOrZero","props","objProps","read","inputs","info","minmax","change","keepZero","parentContext","rectX","getRightToLeftAdapter","_itemWidth","direction","original","propertyFn","normalizeSegment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","sub","segmentOptions","findStartAndEnd","splitByStyles","solidSegments","chartContext","baseStyle","readStyle","prevStyle","addStyle","dir","styleChanged","doSplitByStyles","replacer","pixelSize","fontStyle","fontFamily","binarySearch","metaset","lookupMethod","handler","metasets","getIntersectItems","useFinalPosition","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getNearestItems","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","params","stacks","wrap","buildStacks","getCombinedMax","updateMaxPadding","updateDims","newWidth","newHeight","widthChanged","heightChanged","getMargins","marginForPositions","fitBoxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","buildLayoutBoxes","verticalBoxes","horizontalBoxes","visibleVerticalBoxCount","updatePos","handleMaxPadding","EXPANDO_KEY","EVENT_TYPES","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","createAttachObserver","observer","entries","trigger","entry","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","listenDevicePixelRatioChanges","releaseObserver","unlistenDevicePixelRatioChanges","createProxyAndListen","fromNativeEvent","addListener","renderHeight","renderWidth","displayWidth","displayHeight","initCanvas","proxies","interpolators","c0","helpersColor","cfg","currentValue","elapsed","promises","resolved","animationOptions","animatedProps","option","newOptions","resolveTargetOptions","anim","awaitAll","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","dsIndex","singleMode","otherValue","isStacked","getOrCreateStack","stackKey","indexValue","subStack","getLastIndexInStack","positive","updateStacks","iAxis","vAxis","indexScale","valueScale","getStackKey","getFirstScaleId","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","static","chooseId","xid","yid","rid","iid","vid","scaleID","adata","convertObjectDataToArray","resetNewElements","stackChanged","oldStacked","scopeKeys","sorted","isNotInOrderComparedToPrev","singleScale","parsedValue","canStack","otherScale","createStack","otherMin","otherMax","_skip","toClip","defaultClip","createDataContext","createDatasetContext","elementType","sharing","transition","firstOpts","previouslySharedOptions","arg1","arg2","numMeta","numData","removed","newCount","final","tickOpts","determinedMaxTicks","maxScale","maxChart","determineMaxTicks","ticksLimit","majorIndices","getMajorIndices","numMajorIndices","newTicks","skipMajors","evenMajorSpacing","getEvenSpacing","factors","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","edge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","reverseAlign","super","metas","samplingEnabled","startPixel","endPixel","reversePixels","numTicks","maxLabelDiagonal","labelSizes","maxLabelWidth","maxLabelHeight","minSize","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","isRotated","labelsBelowTicks","offsetLeft","offsetRight","caches","tickFont","nestedLabel","widestLabelSize","highestLabelSize","valueAt","idx","decimal","createTickContext","optionTicks","rot","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","positionAxisID","limit","optsAtIndex","optsAtIndexBorder","lineColor","tickAndPadding","hTickAndPadding","lineCount","halfCount","tickTextAlign","labelPadding","drawLine","lastLineWidth","renderTextOptions","titleArgs","tz","gz","bz","axisID","fontSize","TypedRegistry","parentScope","isIChartComponent","itemDefaults","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","Registry","typedRegistry","arg","reg","itemReg","component","camelMethod","PluginService","hook","descriptor","callCallback","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","scaleOptions","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","initConfig","datasetType","mainScope","resetCache","keyLists","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onAnimationProgress","getCanvas","moveNumericKeys","intKey","getSizeForArea","field","invalidatePlugins","userConfig","initialCanvas","existingChart","newSize","newRatio","axisOptions","scaleOpts","updated","isRadial","scaleType","hasUpdated","newControllers","ControllerClass","animsDisabled","existingEvents","newEvents","changes","datasetCount","makeSet","changeSet","noArea","layers","useClip","getDatasetArea","_add","_remove","detached","activeElements","lastActive","pluginId","hoverOptions","deactivated","activated","eventFilter","isClick","lastEvent","determineLastEvent","abstract","DateAdapterBase","members","computeMinSampleSize","visibleMetas","getAllScaleValues","curr","updateMinAndPrev","parseValue","startValue","endValue","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","borderProps","parseEdge","orig","v2","startEnd","setInflateAmount","legendItem","getter","arcs","maxSize","chartWeight","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","animationOpts","centerX","centerY","metaData","ringWeightOffset","datasetStartAngle","defaultAngle","iAxisKey","vAxisKey","bars","ruler","vpixels","ipixels","baseValue","actualBase","floating","barSign","halfGrid","Infinity","percent","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","pointPosition","parseBorderRadius","angleDelta","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","rThetaToXY","theta","pathArc","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","angleMargin","clipArc","setStyle","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","lineMethod","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","strokePathWithCache","segmentMethod","strokePathDirect","_interpolate","_getInterpolationMethod","interpolated","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","addRectPath","mouseX","mouseY","findOrAddLabel","addedLabels","addIfString","_getLabelForValue","relativeLabelSize","minSpacing","LinearScaleBase","setMin","setMax","minSign","maxSign","generationOptions","dataRange","maxSpaces","rmin","rmax","countDefined","niceMin","niceMax","numSpaces","decimalPlaces","generateTicks","log10Floor","changeExponent","isMajor","tickVal","rangeExp","rangeStep","minExp","exp","startExp","lastTick","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","pointLabelOpts","plFont","textSize","updateLimits","itemOpts","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","labelCount","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","drawPointLabels","gridLineOpts","drawRadiusLine","INTERVALS","UNITS","sorter","adapter","determineUnitForAutoTicks","capacity","interval","addTick","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","_applyBounds","timeOpts","determineUnitForFormatting","determineMajorUnit","weekday","hasWeekday","fmt","minorFormat","majorFormat","offsets","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","added","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","getColorizer","colorizeDoughnutDataset","colorizePolarAreaDataset","colorizeDefaultDataset","containsColorsDefinitions","plugin_colors","_args","chartOptions","colorizer","cleanDecimatedDataset","cleanDecimatedData","plugin_decimation","xAxis","getStartAndCountOfVisiblePointsSimplified","decimated","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","lttbDecimation","minIndex","maxIndex","startIndex","xMin","dx","lastIndex","intermediateIndex1","intermediateIndex2","minMaxDecimation","_getBounds","_findSegmentEnd","_getEdge","_createBoundaryLine","boundary","linePoints","_pointsFromSegments","_shouldApplyFill","_resolveTarget","visited","_decodeFill","fillOption","parseFillOption","firstCh","decodeTargetIndex","addPointsBelow","sourcePoint","linesBelow","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","sourcePoints","getLinesBelow","_buildStackLine","_getTargetValue","computeCircularBoundary","_getTargetPixel","computeLinearBoundary","computeBoundary","_drawfill","lineOpts","clipVertical","doFill","clipY","lineLoop","tpoints","targetSegments","tgt","subBounds","fillSources","fillSource","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","getBoxSize","labelOpts","labelFont","hitboxes","totalHeight","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","rtlHelper","hitbox","defaultColor","halfFontSize","cursor","drawOptions","yBoxTop","xBoxLeft","drawLegendBox","titlePadding","topPaddingPlusHalfFontSize","hitBox","lh","isListened","hoveredItem","sameItem","plugin_legend","fontOpts","plugin_title","createTitle","plugin_subtitle","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","createTooltipItem","getTooltipSize","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","widthPadding","maxLineWidth","determineXAlign","chartWidth","caret","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","tooltipItem","invokeCallbackWithFallback","bodyItems","scoped","positionAndSize","backgroundPoint","tooltipPoint","caretPosition","ptX","ptY","colorX","rtlColorX","yOffSet","colorY","outerX","innerX","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","tooltipSize","animX","animY","hasTooltipContent","positionChanged","plugin_tooltip"],"version":3,"file":"index.ed39b8c1.js.map"}